\chapter{Background}

{
\singlespacing
\begin{verbatim}
- Problem
  - Clojure is a Lisp with macros
  - don't want to write typing rules for each macro
    - don't want to burden users
    - so we expand them before checking
    - but sometimes it's really helpful to write custom rules
- Possible solutions
  - pre expansion
  - interleaved analysis and evaluation
- Constraints
  - Soundness?
    - tension between soundness and user extensibility
  - advantages of pre-expanding
    - can't have "wrong" expansion in pre-expanded code
      - we check the actual expansion that gets wr
  - wrapper macros needed in all of these systems
\end{verbatim}
}

\chapter{Typed Clojure's initial design}

Typed Clojure's initial design was inspired by Typed Racket.
There, syntax is fully expanded before Typed Racket checks it.

Pros to expanding up front:

\begin{itemize}
  \item Separation of concerns (expander does expansion)
\end{itemize}

Cons to expanding up front:

\begin{itemize}
  \item Lose contextual information from unexpanded macros while type checking.
  \item Requires wrapper macros which pollute runtime expansions and
        often require copying implementation details (brittle).
\end{itemize}

\figref{fig:analyzer:control-flow-pre-expand} demonstrates 
how Typed Clojure checks code using the pre-expansion approach.
It uses \texttt{tools.analyzer} to analyze and expand code.
\texttt{tools.analyzer} is an analyzer for Clojure code that creates
a map-based abstract-syntax-trees (AST) for given Clojure forms.
It is implemented using a nano-pass style and traverses over the ASTs
several times to incrementally add features like hygienic scope
and JVM reflection resolution.

To simplify presentation we assume \texttt{tools.analyzer}
uses only 2 passes. The first pass \texttt{analyze} creates
a bare AST with no platform specific information.
The second pass is composed of two tree traversals.
The first is a pre-traversal \texttt{pre-passes} which
is called before we traverse an AST node.
The second is a post-traversal \texttt{post-passes} which
is called after we traverse an AST node.

\begin{figure}
\singlespacing
\begin{verbatim}
time | (let [...]  | (cond ...   | (+ ...)))
 |   | ---------------------------------------
 v   | analyze    >|             |
     |             | analyze >   |
     |             |             | analyze    >
     |             |             |<analyze
     |             |<analyze     |
     |<analyze     |             |
     | pre-passes >|             |
     |             | pre-passes >|
     |             |             | pre-passes >
     |             |             |<post-passes
     |             |<post-passes |
     |<post-passes |             |
     | check>      |             |
     |             | check>      |
     |             |             | check>
     |             |             |<check
     |             |<check       |
     |<check       |             |
\end{verbatim}
  \caption{Control flow when Typed Clojure checks pre-expanded code.
  Three levels of nesting are used as an example.
  }
  \label{fig:analyzer:control-flow-pre-expand}
\end{figure}

\chapter{Extensibility in Pre-expanded checking}

{
\singlespacing
\begin{verbatim}
- how to communicate to type system via expanded code?
  - eg. tc-ignore, ann-form
  - (do :special-form ...)
- how to define custom rules?
  - Approach 1: custom expansions for embedding typing rules in expansion
  - Approach 2: "typing rules by analogy"
\end{verbatim}
}

\chapter{Interleaved expansion and checking}

{
\singlespacing
\begin{verbatim}
- Goals
  1. Build a better tools.analyzer
     - too slow
  2. Extensibility
     - we want custom rules for syntax BEFORE expansion
- (This is the Turnstile approach)
  - Except we don't have syntax objects, how to do it?
- Create a single-pass tools.analyzer variant that can be paused in
  the middle of analysis
  - `analyze` now expands absolute minimum (usually 1 macro)
- now `check` has access to the raw Clojure forms before they are expanded
  - much power = much reponsibility
    - top-level evaluation side effects
    - expansion side effects
      - talk about that in a different chapter
    - must manually manage local scope
    - avoiding double macro expansion
    - avoiding double evaluation
    - double analysis is OK though, no side effects
      - so we can "reinsert" a fully analyzed AST back into
        a macro call so it can be expanded as usual.
        - eg. (my-macro (unexpanded))
            =>
              (my-macro ~(check (unexpanded) ...))
- Pros
  - now have access to original macro forms for higher-level reasoning
- Cons
  - no longer checking the implementation of macros
    - although were we ever, really?
      - wrapper macros are copied implementation details
  - must carefully manage compile-time side effects
\end{verbatim}
}

\begin{figure*}
\singlespacing
\begin{verbatim}
time | (let [...]  | (cond ...   | (+ ...)))
 |   | ---------------------------------------
 v   | check      >|             |
     | analyze    >|             |
     | pre-passes >|             |
     | check      >|             |
     |             | check      >|
     |             | analyze    >|
     |             | pre-passes >|
     |             | check      >|
     |             |             | check      >
     |             |             | analyze    >
     |             |             | pre-passes >
     |             |             | check      >
     |             |             |<check
     |             |             |<post-passes
     |             |             |<check
     |             |<post-passes |
     |             |<check       |
     |<post-passes |             |
     |<check       |             |
\end{verbatim}
  \caption{Control flow when Typed Clojure incrementally expands code as it checks.
  Three levels of nesting are used as an example.
  }
\end{figure*}

\chapter{Extensibility in Interleaved checking}

\chapter{Managing Analysis Side effects}

{
\singlespacing
\begin{verbatim}
- introduce Clojure's evaluation model
  - `do` children treated as top-level
    - eg. (do e1 e2)
      - e1 is completely expanded+evaluated before e2 is expanded.
      - e2 can depend on evaluation-time side effects of e1
    - eg. (let [] (do e1 e2))
      - e1 is ONLY expanded before e2
      - e2 cannot depend on evaluation-time side effects of e1
- introduce *ns*, global thread-local variable that holds the current namespace
  - probably the most important evaluation-time side effect
    - changing namespaces
- introduce AOT-compilation
  - macroexpansions are performed upfront
    - so relying on expansion side-effects are uncommon and unreliable
- since checking & evaluation are interleaved, important that
  order-of-checking == order-of-evaluation
- but what about order-of-macroexpansion?
  - unaware of examples where order of macroexpansion side-effects are important
    outside of top-level forms
    - we have serious problems otherwise for any analysis tool
      - eg. (fn [] (change-ns-at-mexpansion-time) (relys-on-previous-macro-to-resolve))
        - this evaluates just fine in Clojure since there is
          no special handling of *ns* and things never pause and always just happen
          in order
        - but seems intractable for things like typing rules
          - custom typing rules must check forms in the order they are mexpanded!
            - seems very restrictive and error prone.
          - eg. ((fn [] ...) args ...)
            - imagine delaying checking a `fn` before its arguments.
              - but if args depend on fn body to expand, then we are forced
                to fully expand (ie. CHECK) the fn before checking the args.
                - very restrictive
- Relevant reading:
  - Flatt, "You want it, when?"
  - SamTH, Scheme 2011 (good for lispy background), PLDI 2011 (general audience)
\end{verbatim}
}

\begin{figure*}
\singlespacing
\begin{verbatim}
time | (do          | (defn a ...)| (defn b ...))
 |   | ----------------------------------------
 v   | analyze+eval>|             |
     | analyze     >|             |
     | pre-passes  >|             |
     |              | analyze >   |
     |              |<analyze     |
     |              | pre-passes >|
     |              |<post-passes |
     |              | check>      |
     |              |<check       |
     |              | eval  >     |
     |              |<eval        |
     |<analyze+eval |             |
     | analyze+eval>|             |
     |              |             | analyze >   
     |              |             |<analyze     
     |              |             | pre-passes >
     |              |             |<post-passes 
     |              |             | check>      
     |              |             |<check       
     |              |             | eval >
     |              |             |<eval
     |<post-passes  |             |
     |<analyze+eval |             |
\end{verbatim}
  \caption{}
  \label{fig:analyzer:control-flow-pre-expand-side-effects}
\end{figure*}

\begin{figure*}
\singlespacing
\begin{verbatim}
time | (do         | (defn a ...)| (defn b ...))
 |   | ---------------------------------------
 v   | check       |             |
     | analyze     |             |
     | pre-passes  |             |
     | check-child |             |
     |             | analyze     |
     |             | pre-passes  |
     |             | check       |
     |             | post-passes |
     |             | eval        |
     | check-child |             |
     |             |             | analyze
     |             |             | pre-passes >
     |             |             | check
     |             |             | post-passes
     |             |             | eval
     | post-passes |             |
\end{verbatim}
  \caption{}
  \label{fig:analyzer:control-flow-incremental-side-effects}
\end{figure*}
