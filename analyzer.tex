\chapter{Background}

Clojure is a dialect of Lisp, and so supports metaprogramming
via macros.
This immediately poses an interesting problem for Clojure
type systems: how do we check a macro call?
Ideally, we don't want to require special typing rules for each
macro, since that imposes additional burden on the programmer
to define special rules for their own macros.
On the other hand, sometimes its helpful to write custom rules
for customized error messages, or a higher-level specification
for a macro's usage.

In this part we explore several solutions to this problem,
from the standard approach of expanding macros to
primitive forms before checking, to more involved solutions
that allow extensible typing rules for each macro.

Several constraints guide us through our designs.
There is a question of soundness: does what we actually
check match up with the code being evaluated?
There is a natural tension between soundness and user extensibility.
Allowing custom rules for macros gives a kind of flexibility
that makes it hard to relate type checking semantics with
the running code---which is the whole idea behind a soundness result.
On the other hand, expanding code before checking ensures
we check the actual code being run.
In all of these cases, wrappers that communicate information
to the type system are needed, but they interact
with evaluated code differently.

We also consider the experience of using these solutions.
Error messages can be unrelated to the source problem
if pre-expanding code, but we may miss actual errors
by using a poorly written typing rule.
We are interested in the difficultly of extending each system,
including any additional annotation burden,
additional knowledge needed to manage evaluation semantics
in typing rules, and additional type system knowledge required
to write typing rules. Finally, we also consider implications
to type checking performance and amenability to iterative development.

The following chapters present several designs of Typed Clojure,
their extensibility stories, and general implementation concerns for
Clojure type system designers.

%{
%\singlespacing
%\begin{verbatim}
%- Problem
%  - Clojure is a Lisp with macros
%  - don't want to write typing rules for each macro
%    - don't want to burden users
%    - so we expand them before checking
%    - but sometimes it's really helpful to write custom rules
%- Possible solutions
%  - pre expansion
%  - interleaved analysis and evaluation
%- Constraints
%  - Soundness?
%    - tension between soundness and user extensibility
%  - advantages of pre-expanding
%    - can't have "wrong" expansion in pre-expanded code
%      - we check the actual expansion that gets wr
%  - wrapper macros needed in all of these systems
%\end{verbatim}
%}

\chapter{Expand before checking}

Typed Clojure's initial design was inspired by Typed Racket,
which checks Racket code by first expanding until it consists
of only primitives, and then checking using fixed rules for each
primitive.
This chapter goes into this design in more detail, starting
with our choice of analyzer and then how to handle extensibility.

\section{Upfront Analysis with \texttt{tools.analyzer}}

Instead of using Clojure's compiler to analyze code,
we opted to use \texttt{tools.analyzer}, a standalone nano-pass
analyzer providing an idiomatic map-based AST format providing
passes for hygienic transformations and Java reflection resolution.

%{
%\singlespacing
%\begin{verbatim}
%- Pros to expanding up front:
%  - Separation of concerns (expander does expansion)
%- Cons to expanding up front:
%  - Lose contextual information from unexpanded macros while type checking.
%  - Requires wrapper macros which pollute runtime expansions and
%    often require copying implementation details (brittle).
%\end{verbatim}
%}

\figref{fig:analyzer:control-flow-pre-expand} demonstrates 
how Typed Clojure checks code using the pre-expansion approach.
To simplify presentation we assume \texttt{tools.analyzer}
uses only 2 passes. The first pass \texttt{analyze} creates
a bare AST with no platform specific information.
The second pass is composed of two tree traversals.
The first is a pre-traversal \texttt{pre-passes} which
is called before we visit the children of an AST node.
The second is a post-traversal \texttt{post-passes} which
is called after we visit the children of an AST node.

This arrangement is convenient as a type system implementer,
insofar as there is a clean separation of concerns: the analyzer
handles expansion and evaluation, while the type system
merely checks.
However, much contextual information is lost from the expansion
process that is needed for checking.
We now present how we surmount this challenge while still
preserving the pre-expanded checking model.

\begin{figure}
\singlespacing
$$
  \begin{array}{r||l|l|l|}
    \text{Time} & \text{\clj{(let [...]}} & \text{\clj{(cond ...}} & \text{\clj{(+ ...)))}}\\
    \hline
     0          & \text{\clj{analyze}}^{>}    &                             &                      \\
     1          &                             & \text{\clj{analyze}}^{>}    &                      \\
     2          &                             &                             & \text{\clj{analyze}}^{>} \\
     3          &                             &                             & \text{\clj{analyze}}^{<} \\
     4          &                             & \text{\clj{analyze}}^{<}    &                      \\
     5          & \text{\clj{analyze}}^{<}    &                             &                      \\
     6          & \text{\clj{pre-passes}}^{>} &                             &                      \\
     7          &                             & \text{\clj{pre-passes}}^{>} &                      \\
     8          &                             &                             & \text{\clj{pre-passes}}^{>} \\
     9          &                             &                             & \text{\clj{post-passes}}^{<} \\
     10         &                             & \text{\clj{post-passes}}^{<}&                      \\
     11         & \text{\clj{post-passes}}^{<}&                             &                      \\
     12         & \text{\clj{check}}^{>}      &                             &                      \\
     13         &                             & \text{\clj{check}}^{>}      &                      \\
     14         &                             &                             & \text{\clj{check}}^{>} \\
     15         &                             &                             & \text{\clj{check}}^{<} \\
     16         &                             & \text{\clj{check}}^{<}      &                      \\
     17         & \text{\clj{check}}^{<}      &                             &                      \\
  \end{array}
$$
%\begin{verbatim}
%time | (let [...]  | (cond ...   | (+ ...)))
% |   | ---------------------------------------
% v   | analyze    >|             |
%     |             | analyze >   |
%     |             |             | analyze    >
%     |             |             |<analyze
%     |             |<analyze     |
%     |<analyze     |             |
%     | pre-passes >|             |
%     |             | pre-passes >|
%     |             |             | pre-passes >
%     |             |             |<post-passes
%     |             |<post-passes |
%     |<post-passes |             |
%     | check>      |             |
%     |             | check>      |
%     |             |             | check>
%     |             |             |<check
%     |             |<check       |
%     |<check       |             |
%\end{verbatim}
  \caption{Illustrative control flow when
  using \texttt{tools.analyzer} to expand code via \clj{analyze} and several passes,
  followed by Typed Clojure checking.
  The partial expression \clj{(let [...] (cond ... (+ ...)))}
  was chosen since it has at least 3 levels of nesting.
  Many more levels will be revealed after expansion by \clj{analyze}, which we do not picture.
  ${}^>$ and ${}^<$ indicate work done to a node before and after processing its children, respectively.
  }
  \label{fig:analyzer:control-flow-pre-expand}
\end{figure}

\section{Extensibility}

%{
%\singlespacing
%\begin{verbatim}
%- Problem
%  - need to communicate between type system and Clojure runtime
%- Constraints
%  - a "typed" program must evaluate unchanged via normal Clojure compilation
%    - extensions must be done via macros provided by Typed Clojure
%      - imported and used as normal by Clojure programmers
%    - in contrast to #lang system
%      - which always guarantees the type system is in charge of expanding
%      - (both approaches use macros for extension and to share information)
%- how to communicate to type system via expanded code?
%  - eg. tc-ignore, ann-form
%  - in Racket you would use syntax properties, or side effects
%  - Clojure has metadata, but not as robust as syntax properties
%    - how metadata is compiled is implementation dependent (I forgot how?)
%    - we decided to emit special `do` forms to communicate with type system
%      - (do :special-form ...)
%      - "variable protocol" in Advanced Macrology
%  - side effects
%    - Clojure's compilation strategy is straightforward
%      - files are just sequences of top-level forms
%      - evaluate each in turn
%      - side effects of expanding/evaluating a previous form
%        can be used to compile a subsequent form
%      - members of top-level `do` forms are also top-level forms, and thus
%        are evaluated in turn
%    - Typed Clojure collects global type annotations by evaluation side effects
%      - macroexpansion side effects not used in case AOT compiled
%- how to define custom rules?
%  - Approach 1: custom expansions for embedding typing rules in expansion
%  - Approach 2: "typing rules by analogy"
%    - lose ability to check actual expansion
%\end{verbatim}
%}

Now that we have outlined how we use \texttt{tools.analyzer} to pre-expand code before type checking,
we describe Typed Clojure's approach to sharing information between the programs it checks
and the type system.
We deviate significantly from Typed Racket's approach~\cite{Culpepper07advancedmacrology}
mostly because of differences in compilation models between Clojure and Racket.

One constraint we must consider in Typed Clojure is that a ``typed'' Clojure program must
evaluate unchanged under normal Clojure compilation. In Racket, we could instead specify
the language under which a module is compiled using the \texttt{\#lang} directive---this is Typed
Racket's approach. 
In Clojure, there is just one language and no built-in facilities to extend the compilation
process, so Typed Clojure provides a suite of macros for communicating with the type system that
users must explicitly load and use.

These macros come in several flavors:

\begin{itemize}
  \item syntax-based communication to type checker,
  \item side-effectful communication to type checker, and
  \item wrappers for existing untyped macros.
    %to avoid checking complex expansions
    %or provide .
\end{itemize}

We discuss each in the following sections.

\subsection{Syntax-based communication}

A simple macro provided by Typed Clojure that communicates to the checker
via syntax is \clj{tc-ignore}, which takes a number of forms, places
them in a \clj{do} form, and tells the checker to ignore the resulting
form and assign it type \clj{Any}.

\begin{figure*}
\begin{cljlisting}
(defmacro tc-ignore 
  "Ignore forms in body during type checking"
  [& body]
  `(do :clojure.core.typed.special-form/special-form
       :clojure.core.typed/tc-ignore
       ~@(or body [nil])))
\end{cljlisting}
  \caption{Public facing macro definition for \clj{tc-ignore}.}
  \label{fig:analyzer:tc-ignore}
\end{figure*}

\figref{fig:analyzer:tc-ignore} shows the implementation of the \clj{tc-ignore} macro.
It demonstrates the \clj{do}-special-form protocol:
if the first member of a \clj{do} is the keyword
\clj{:clojure.core.typed.special-form/special-form},
the following keyword names a special typing rule to use
to check the entire form.
A corresponding typing rule must then be registered with the type checker under this name,
like in \figref{fig:analyzer:tc-ignore-do-op}.

\begin{figure*}
\begin{cljlisting}
(defmethod internal-special-form :clojure.core.typed/tc-ignore
  [expr expected]
  (tc-ignore/check-tc-ignore check-expr expr expected))
\end{cljlisting}
  \caption{Registering a corresponding typing rule for \clj{tc-ignore} via the \clj{do}-special-form protocol.}
  \label{fig:analyzer:tc-ignore-do-op}
\end{figure*}

Clojure's compilation and runtime models make \clj{do} statements an excellent candidate for the basis of
an extensible syntax-based communication protocol.
First, it naturally inherits the top-level characteristics of \clj{do}, which is key to defining
wrapper macros that operate at the top-level.
A usage of \clj{tc-ignore} that relies on this is demonstrated in \figref{fig:analyzer:tc-ignore-usage}.
Second, it avoids the need to pre-expand its arguments to attach information, or
have special cases for particular arguments.
On the other hand, a communication protocol based on attaching metadata properties
would require pre-expanding arguments, since metadata is lost on macroexpansion,
and in some cases would not be possible, since many common Clojure forms do not support metadata
(such as keywords, numbers, and nil).
Third, the information can be compiled away using standard techniques,
since they are constant statements---extra information can be provided via a map of constant values
placed after the typing rule name, as in
the definition of \clj{ann-form} (\figref{fig:analyzer:ann-form-definition}).

\begin{figure*}
\begin{cljlisting}
(defmacro ann-form
  "Annotate a form with an expected type."
  [form ty]
  `(do :clojure.core.typed.special-form/special-form
       :clojure.core.typed/ann-form
       {:type '~ty}
       ~form))
\end{cljlisting}
  \caption{The definition of \clj{ann-form} shows how to communicate extra information to the type checker}
  \label{fig:analyzer:ann-form-definition}
\end{figure*}

While a strong choice, there are some downsides to basing our communication protocol on \clj{do}
statements.
There is no guarantee the information will be compiled away at runtime, and
thus may contribute to bloating the runtime.
On the other hand, \clj{tools.analyzer} must be carefully configured to not erase these constant
values before Typed Clojure can access them.

Alternative \clj{do}-based protocols could be similarly effective
such as attaching metadata directly to the symbol \clj{do} or list \clj{(do ...)}.
We felt embedding the information directly in programs had the best chance of forward-compatibility,
since the interaction between metadata and compilation is not well documented and
can be platform-dependent (in our experience ClojureScript has handled some cases differently,
like evaluating metadata instead of simply quoting it as in Clojure).

\begin{figure}
\begin{cljlisting}
(tc-ignore
  (defmacro reverse-app [a f] `(~f ~a))
  (reverse-app 1 inc)) ;=> 2
\end{cljlisting}
  \caption{Example top-level usage of \clj{tc-ignore}
           where the second form must expand after the first evaluates.
  It works because \clj{tc-ignore} wraps only with \clj{do}.}
  \label{fig:analyzer:tc-ignore-usage}
\end{figure}

\subsection{Side-effectful communication}

Racket has a sophisticated system for managing compile-time side effects
to accompany its module system.
Clojure does not have a module system, and instead relies on conventions
and a simple compilation model to write effective programs.

The unit of compilation in Clojure is a top-level form. A top-level Clojure form
is guaranteed to have all previous top-level forms fully expanded
and evaluated before it is expanded and evaluated itself.
This blurs the lines between compile-time and runtime, compared to the
distinct phases of Racket compilation.

When checking a file with Typed Clojure, we have similar guarantees:
when checking a top-level form, we can depend on the fact that all
previous top-level forms have been expanded, evaluated, and checked,
and that the current form has been fully expanded.

Thus, we have a choice of (at least) three times to send side-effectful communication
to the type checker:
expansion-time, evaluation-time, and checking-time.
\figref{fig:analyzer:ann-definition} shows the most frequently used
side-effectful macro \clj{ann}, which registers the type of a var in the
global environment.
It expands to code that uses internal function \clj{ann*}, which does
the registering. This is a \emph{evaluation-time} side effect,
and we similarly perform most communication at this time.
We now elaborate on why this is a good choice.

A previous implementation of Typed Clojure (which was used by CircleCI
in \secref{sec:casestudy}) only collected top-level annotations
from \clj{ann} at checking-time. This forced Typed Clojure to recursively
check other files just to collection annotations.
We decided the natural behavior of rechecking a file would be to
recheck its dependencies so, among other benefits, top-level annotations
would be kept up-to-date.
Unfortunately, the checker was much slower at evaluating files
than the Clojure compiler, meaning iterative development was hampered.
To fix this, we made checking of transitive file dependencies optional, and
so dependencies containing top-level annotations would potentially only 
be evaluated by the Clojure compiler.
Evaluation-time was then the natural time to collect these annotations.

A side-effect of this design choice is that it is no longer a sound idea to
infer types for unannotated top-level bindings. In the aforementioned 
implementation, if the checker finds an unannotated top-level \clj{def}
like \clj{(def a 1)}, it will update the global environment with the 
inferred type of the right-hand-side.
Now that transitive dependencies are optionally checked, it is not guaranteed
the checker will infer these annotations, and so more top-level annotations
via \clj{ann} are needed to recover consistent checking behavior.
This unfortunately increases the annotation burden even more, however the rewards
are great.
We believe that Clojure programmers will enjoy the ability to rapidly recheck
small parts of their code base, just like they are used to in untyped Clojure.

Now, we discuss the merits of collection at evaluation-time over expansion-time.
We avoid expansion-time for side-effects because Clojure code can be
evaluated in two ways: from the original source code in interpreted mode, and 
from precompiled JVM bytecode in ahead-of-time compilation mode.
In the latter, code is expanded ahead-of-time (potentially in a different environment)
and thus expansion-time side-effects are lost.
We applied the standard solution to this problem: remove the side-effect from
the macro itself and move it to the evaluation of the code it expands into.


%\begin{verbatim}
%- not forced to recursively check other files just to collect annotations
%  - problem identified with CircleCI
%  - simply need to evaluate a file normally
%  - in turn requires more annotations
%    - tradeof between annotation burden and performance
%- avoid relying on expansion-time side effects
%  - lost with AOT compilation
%- "staged at checking time": under Typed Racket AOT compilation, it stages global type annotations for eval time
%  - we don't have a similar mode
%    - compiling a Typed Clojure file does not require checking
%\end{verbatim}


\begin{figure*}
\begin{cljlisting}
(defmacro ann 
  "Register top-level var with type."
  [varsym typesyn]
  (let [qsym (qualify-in-current-ns varsym)
        opts (meta varsym)
        check? (not (:no-check opts))]
    `(tc-ignore (ann* '~qsym '~typesyn '~check? '~&form))))
(defn ann* 
  "Internal use only. Use ann."
  [qsym typesyn check? form]
  ; omitted - registers `qsym` at type `typesym`
  )
\end{cljlisting}
  \caption{Implementation of \clj{ann}, which expands to code that registers types at evaluation-time.}
  \label{fig:analyzer:ann-definition}
\end{figure*}

\subsection{Wrapper macros}

Several situations call for wrapper macros for existing untyped macros.
In practice, this often means the type system author provides an alternative
implementation for a macro, and the type system user
replaces any usages of the original macro in type-checked code with the alternative implementation.
Sometimes this choice is aesthetic, providing a prettier 
way to write annotations. For example, the \clj{fn} wrapper
enables writing annotations like
\clj{(fn [a :- Int] ...)}
instead of the more verbose
\clj{(ann-form (fn [a] ...) [Int -> Any])}.

The more pressing need for wrapper macros when checking pre-expanded
code is to manage complex expansions.
Some macro expansions are too complex for Typed Clojure to reason about,
so it becomes necessary to rewrite these expansions to be more palatable
for the checker.
For example, the \clj{for} macro is a lazy sequence builder using
a list-comprehension syntax---however it expands into local
loops using local mutable state, which are problematic to check.
The wrapper macro for \clj{for} expands (and thus evaluates) similarly, but inserts user-provided
type annotations strategically into the expansion so it more easily type checks.

The problem with this kind of wrapper macros is that large amounts
of implementation code must be copied to preserve the original semantics.
Instead of checking a higher-level specification of the macro's behavior,
we are tied closely to a particular implementation.
This has the advantage of checking the actual code that gets evaluated, but
unfortunately
requires the type system writer to closely follow the original implementations
(hampering both backwards- and forwards-compatibility with versions of the original macro).
Furthermore, users not only must use wrapper macros where necessary, but
also recognize when they are required---usually attempting to check a complex
expansion yields an incomprehensible error as Typed Clojure fails to check it.
It is rarely apparent that a wrapper macro is needed from such an error message.

\chapter{Interleaved expansion and checking}

The previous chapter outlined a design for Typed Clojure that fully expands code
before checking.
We identified several problems with the user experience of Typed Clojure's initial design,
including bad error messages, and excessive copying of macro implementations for wrapper
macros.
Additionally, we identified several issues with \texttt{tools.analyzer} that we have
not yet discussed.

First, \texttt{tools.analyzer}'s goals of being mostly platform-agnostic made analysis particularly 
slow, and so added an undesirable performance overhead to type checking.
In particular, a copy of the
global scope is maintained for every namespace. While it enables a convenient platform-agnostic API
for symbol resolution,
it comes at a performance cost since it must be updated (from scratch) frequently.
Furthermore, some macroexpansion side effects are not (yet) recognized by the analyzer
which means analysis sometimes deviates from Clojure compiler, an undesirable situation
since Typed Clojure intends to model how code runs \emph{outside} of type checking.
Unfortunately, fixing some of these differences would require even more frequent costly updates.

Second, it is impractical to recover contextual information lost via analysis.
This is both because \texttt{tools.analyzer} has no way of representing unanalyzed
code (so there is no choice but to expand immediately), and
because \texttt{tools.analyzer} uses at least 2 passes over the AST
(so there is no obvious place to recover contextual information since pre-traversal
passes run \emph{after} the entire program has been expanded).
For example, \figref{fig:analyzer:control-flow-pre-expand}
illustrates \texttt{tools.analyzer}'s control flow with just 2 traversals.
Say at time 1 we wished to take advantage of the unexpanded \clj{cond}
form with a special rule (before it expands and contextual information is lost).
In fact, \texttt{tools.analyzer} provides the extension point \clj{macroexpand-1}
for just this purpose, which allows the user to specify exactly how a form is expanded.
Unfortunately, time 0 introduced local bindings that are unhygienic, and the hygienic
transformation pass (required for checking because occurrence typing's propositions do not recognize variable shadowing)
happens at time 6 with \clj{pre-passes}.
So, there is no room for a checking rule for \clj{cond} until time 13, well
after the \clj{cond} is expanded away.

Fortunately, \texttt{tools.analyzer}'s design and implementation
is otherwise brilliant and innovative, and forms a great base to build a new Clojure analyzer better suited to help solve
many of the aforementioned analysis and checking problems---we did exactly that in \texttt{core.typed.analyzer}.

\section{Interleaved Analysis with \texttt{core.typed.analyzer}}

To replace \texttt{tools.analyzer}, we built \texttt{core.typed.analyzer}. In this section,
we describe how \texttt{core.typed.analyzer} works, and outline both the ideas we repurposed
from \texttt{tools.analyzer} and those specific to \texttt{core.typed.analyzer}.

\subsection{Overview}

\subsection{Implementation}

Passes in \texttt{tools.analyzer} are written completely separately and connected to other passes
via explicit dependencies specified via metadata.
This allows a separate scheduler to arrange the passes into as few tree traversals as possible,
and means passes are highly modular, so we can choose just those that are relevant to type systems.
Furthermore, passes are almost always extensible via Clojure's multimethods, so it is trivial to add
support for new AST types, like an AST representation for unanalyzed code.

%{
%\singlespacing
%\begin{verbatim}
%- Goals
%  1. Build a better tools.analyzer
%     - too slow
%     - too many passes
%     - reuse the passes/scheduler/analysis
%       - and :unanalyzed
%         - instead of analyzing children, store context and return
%       - unforce one pass
%  2. Extensibility
%     - we want custom rules for syntax BEFORE expansion
%     - avoid need for wrapper macros
%       - avoid implementation-dependence
%       - better error messages for users
%     - but lose ability to check actual expansions
%- (This is the Turnstile approach)
%  - Except we don't have syntax objects, how to do it?
%- Create a single-pass tools.analyzer variant that can be paused in
%  the middle of analysis
%  - `analyze` now expands absolute minimum (usually 1 macro)
%- now `check` has access to the raw Clojure forms before they are expanded
%  - much power = much reponsibility
%    - top-level evaluation side effects
%    - expansion side effects
%      - talk about that in a different chapter
%    - must manually manage local scope
%    - avoiding double macro expansion
%    - avoiding double evaluation
%    - double analysis is OK though, no side effects
%      - so we can "reinsert" a fully analyzed AST back into
%        a macro call so it can be expanded as usual.
%        - eg. (my-macro (unexpanded))
%            =>
%              (my-macro ~(check (unexpanded) ...))
%- Pros
%  - now have access to original macro forms for higher-level reasoning
%- Cons
%  - no longer checking the implementation of macros
%    - although were we ever, really?
%      - wrapper macros are copied implementation details
%  - must carefully manage compile-time side effects
%\end{verbatim}
%}

\begin{figure*}
\singlespacing
$$
  \begin{array}{r||l|l|l|}
    \text{Time} & \text{\clj{(let [...]}} & \text{\clj{(cond ...}} & \text{\clj{(+ ...)))}}\\
    \hline
     0          & \text{\clj{unanalyzed}}^{<}    &                               &                      \\
     1          & \text{\clj{analyze-outer}}^{*} &                               &                      \\
     2          & \text{\clj{pre-passes}}^{>}    &                               &                      \\
     3          & \text{\clj{check}}^{>}         &                               &                      \\
     4          &                                & \text{\clj{analyze-outer}}^{*}&                      \\
     5          &                                & \text{\clj{pre-passes}}^{>}   &                      \\
     6          &                                & \text{\clj{check}}^{>}        &                             \\
     7          &                                &                               & \text{\clj{analyze-outer}}^{*}                     \\
     8          &                                &                               & \text{\clj{pre-passes}}^{>}                        \\
     9          &                                &                               & \text{\clj{check}}^{>}                             \\
     10         &                                &                               & \text{\clj{post-passes}}^{<}                        \\
     11         &                                &                               & \text{\clj{check}}^{<}                             \\
     12         &                                & \text{\clj{post-passes}}^{<}  &                      \\
     13         &                                & \text{\clj{check}}^{<}        &                      \\
     14         & \text{\clj{post-passes}}^{<}   &                               &                      \\
     15         & \text{\clj{check}}^{<}         &                               &                      \\
  \end{array}
$$
%\begin{verbatim}
%time | (let [...]  | (cond ...   | (+ ...)))
% |   | ---------------------------------------
% v   | unanalyzed  |             |
%     | check      >|             |
%     | analyze-outer *|             |
%     | pre-passes >|             |
%     |             | check      >|
%     |             | analyze-outer   *|
%     |             | pre-passes >|
%     |             |             | check      >
%     |             |             | analyze-outer   *
%     |             |             | pre-passes >
%     |             |             |<check
%     |             |             |<post-passes
%     |             |             |<check
%     |             |<post-passes |
%     |             |<check       |
%     |<post-passes |             |
%     |<check       |             |
%\end{verbatim}
  \begin{cljlisting}
(defn check-expr
  "Check an AST node has the expected type."
  [expr expected]
  (if (= :unanalyzed (:op expr))
    (check-expr (analyze-outer expr) expected)
    (run-post-passes
      (check (run-pre-passes expr)
             expected))))
(defn check-form
  "Check a Clojure expression has the expected type"
  [form expected]
  (check-expr (unanalyzed form (empty-env))
              expected))
\end{cljlisting}

  \caption{Control flow when Typed Clojure incrementally expands code as it checks.
      ${}^*$ denotes zero or more calls.
  }
\end{figure*}


\begin{figure*}
\begin{cljlisting}
; tools.analyzer version
(defn parse-if
  "Convert a Clojure `(if <test> <then> <else>)` form to an AST."
  [[_ test then else :as form] env]
  {:op      :if
   :form     form
   :env      env
   :test     (__red>analyze-form<red__ test (assoc env :context :ctx/expr))
   :then     (__red>analyze-form<red__ then env)
   :else     (__red>analyze-form<red__ else env)
   :children [:test :then :else]})

; core.typed.analyzer version
(defn parse-if
  "Convert a Clojure `(if <test> <then> <else>)` form to an AST."
  [[_ test then else :as form] env]
  {:op      :if
   :form     form
   :env      env
   :test     (__red>unanalyzed<red__ test (assoc env :context :ctx/expr))
   :then     (__red>unanalyzed<red__ then env)
   :else     (__red>unanalyzed<red__ else env)
   :children [:test :then :else]})
\end{cljlisting}

  \caption{Example of porting a \texttt{tools.analyzer} function
  to use \clj{unanalyzed} (differences highlighted).
  }
\end{figure*}

\section{Extensibility in Interleaved checking}

\chapter{Managing Analysis Side effects}

{
\singlespacing
\begin{verbatim}
- introduce Clojure's evaluation model
  - `do` children treated as top-level
    - eg. (do e1 e2)
      - e1 is completely expanded+evaluated before e2 is expanded.
      - e2 can depend on evaluation-time side effects of e1
    - eg. (let [] (do e1 e2))
      - e1 is ONLY expanded before e2
      - e2 cannot depend on evaluation-time side effects of e1
- introduce *ns*, global thread-local variable that holds the current namespace
  - probably the most important evaluation-time side effect
    - changing namespaces
- introduce AOT-compilation
  - macroexpansions are performed upfront
    - so relying on expansion side-effects are uncommon and unreliable
- since checking & evaluation are interleaved, important that
  order-of-checking == order-of-evaluation
- but what about order-of-macroexpansion?
  - unaware of examples where order of macroexpansion side-effects are important
    outside of top-level forms
    - we have serious problems otherwise for any analysis tool
      - eg. (fn [] (change-ns-at-mexpansion-time) (relys-on-previous-macro-to-resolve))
        - this evaluates just fine in Clojure since there is
          no special handling of *ns* and things never pause and always just happen
          in order
        - but seems intractable for things like typing rules
          - custom typing rules must check forms in the order they are mexpanded!
            - seems very restrictive and error prone.
          - eg. ((fn [] ...) args ...)
            - imagine delaying checking a `fn` before its arguments.
              - but if args depend on fn body to expand, then we are forced
                to fully expand (ie. CHECK) the fn before checking the args.
                - very restrictive
- Relevant reading:
  - Flatt, "You want it, when?"
  - SamTH, Scheme 2007 (good for lispy background), PLDI 2011 (general audience)
\end{verbatim}
}

\begin{figure*}
\singlespacing
\begin{verbatim}
time | (do          | (defn a ...)| (defn b ...))
 |   | ----------------------------------------
 v   | analyze+eval>|             |
     | analyze     >|             |
     | pre-passes  >|             |
     |              | analyze >   |
     |              |<analyze     |
     |              | pre-passes >|
     |              |<post-passes |
     |              | check>      |
     |              |<check       |
     |              | eval  >     |
     |              |<eval        |
     |<analyze+eval |             |
     | analyze+eval>|             |
     |              |             | analyze >   
     |              |             |<analyze     
     |              |             | pre-passes >
     |              |             |<post-passes 
     |              |             | check>      
     |              |             |<check       
     |              |             | eval >
     |              |             |<eval
     |<post-passes  |             |
     |<analyze+eval |             |
\end{verbatim}
  \caption{}
  \label{fig:analyzer:control-flow-pre-expand-side-effects}
\end{figure*}

\begin{figure*}
\singlespacing
\begin{verbatim}
time | (do         | (defn a ...)| (defn b ...))
 |   | ---------------------------------------
 v   | check-tplvl |             |
     | analyze     |             |
     | pre-passes  |             |
     | check-child>|             |
     |             | analyze     |
     |             | pre-passes  |
     |             | check       |
     |             | post-passes |
     |             | eval        |
     | check-child<|             |
     |             |             | analyze
     |             |             | pre-passes >
     |             |             | check
     |             |             | post-passes
     |             |             | eval
     | post-passes |             |
\end{verbatim}
  \caption{}
  \label{fig:analyzer:control-flow-incremental-side-effects}
\end{figure*}
