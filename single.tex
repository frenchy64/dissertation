%% For double-blind review submission
%\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
\documentclass[acmlarge]{acmart}%\settopmatter{printfolios=true}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
%\usepackage{booktabs}   %% For formal tables:
%                        %% http://ctan.org/pkg/booktabs
%\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%                        %% http://ctan.org/pkg/subcaption
\usepackage{listings}
\lstdefinelanguage{clojure}%
{morekeywords={*,*1,*2,*3,*agent*,*allow-unresolved-vars*,*assert*,*clojure-version*,*command-line-args*,%
*compile-files*,*compile-path*,*e,*err*,*file*,*flush-on-newline*,*in*,*macro-meta*,%
*math-context*,*ns*,*out*,*print-dup*,*print-length*,*print-level*,*print-meta*,*print-readably*,%
*read-eval*,*source-path*,*use-context-classloader*,*warn-on-reflection*,+,-,->,->>,..,/,:else,%
<,<=,=,==,>,>=,@,accessor,aclone,add-classpath,add-watch,agent,agent-errors,aget,alength,alias,%
all-ns,alter,alter-meta!,alter-var-root,amap,ancestors,and,apply,areduce,array-map,aset,%
aset-boolean,aset-byte,aset-char,aset-double,aset-float,aset-int,aset-long,aset-short,assert,%
assoc,assoc!,assoc-in,associative?,atom,await,await-for,await1,bases,bean,bigdec,bigint,binding,%
bit-and,bit-and-not,bit-clear,bit-flip,bit-not,bit-or,bit-set,bit-shift-left,bit-shift-right,%
bit-test,bit-xor,boolean,boolean-array,booleans,bound-fn,bound-fn*,butlast,byte,byte-array,%
bytes,cast,char,char-array,char-escape-string,char-name-string,char?,chars,chunk,chunk-append,%
chunk-buffer,chunk-cons,chunk-first,chunk-next,chunk-rest,chunked-seq?,class,class?,%
clear-agent-errors,clojure-version,coll?,comment,commute,comp,comparator,compare,compare-and-set!,%
compile,complement,concat,cond,condp,conj,conj!,cons,constantly,construct-proxy,contains?,count,%
counted?,create-ns,create-struct,cycle,dec,decimal?,declare,def,definline,defmacro,defmethod,%
defmulti,defn,defn-,defonce,defprotocol,defstruct,deftype,delay,delay?,deliver,deref,derive,%
descendants,destructure,disj,disj!,dissoc,dissoc!,distinct,distinct?,do,do-template,doall,doc,%
dorun,doseq,dosync,dotimes,doto,double,double-array,doubles,drop,drop-last,drop-while,empty,empty?,%
ensure,enumeration-seq,eval,even?,every?,false,false?,ffirst,file-seq,filter,finally,find,find-doc,%
find-ns,find-var,first,float,float-array,float?,floats,flush,fn,fn?,fnext,for,force,format,future,%
future-call,future-cancel,future-cancelled?,future-done?,future?,gen-class,gen-interface,gensym,%
get,get-in,get-method,get-proxy-class,get-thread-bindings,get-validator,hash,hash-map,hash-set,%
identical?,identity,if,if-let,if-not,ifn?,import,in-ns,inc,init-proxy,instance?,int,int-array,%
integer?,interleave,intern,interpose,into,into-array,ints,io!,isa?,iterate,iterator-seq,juxt,%
key,keys,keyword,keyword?,last,lazy-cat,lazy-seq,let,letfn,line-seq,list,list*,list?,load,load-file,%
load-reader,load-string,loaded-libs,locking,long,long-array,longs,loop,macroexpand,macroexpand-1,%
make-array,make-hierarchy,map,map?,mapcat,max,max-key,memfn,memoize,merge,merge-with,meta,%
method-sig,methods,min,min-key,mod,monitor-enter,monitor-exit,name,namespace,neg?,new,newline,%
next,nfirst,nil,nil?,nnext,not,not-any?,not-empty,not-every?,not=,ns,ns-aliases,ns-imports,%
ns-interns,ns-map,ns-name,ns-publics,ns-refers,ns-resolve,ns-unalias,ns-unmap,nth,nthnext,num,%
number?,odd?,or,parents,partial,partition,pcalls,peek,persistent!,pmap,pop,pop!,pop-thread-bindings,%
pos?,pr,pr-str,prefer-method,prefers,primitives-classnames,print,print-ctor,print-doc,print-dup,%
print-method,print-namespace-doc,print-simple,print-special-doc,print-str,printf,println,println-str,%
prn,prn-str,promise,proxy,proxy-call-with-super,proxy-mappings,proxy-name,proxy-super,%
push-thread-bindings,pvalues,quot,rand,rand-int,range,ratio?,rational?,rationalize,re-find,%
re-groups,re-matcher,re-matches,re-pattern,re-seq,read,read-line,read-string,recur,reduce,ref,%
ref-history-count,ref-max-history,ref-min-history,ref-set,refer,refer-clojure,reify,%
release-pending-sends,rem,remove,remove-method,remove-ns,remove-watch,repeat,repeatedly,%
replace,replicate,require,reset!,reset-meta!,resolve,rest,resultset-seq,reverse,reversible?,%
rseq,rsubseq,second,select-keys,send,send-off,seq,seq?,seque,sequence,sequential?,set,set!,%
set-validator!,set?,short,short-array,shorts,shutdown-agents,slurp,some,sort,sort-by,sorted-map,%
sorted-map-by,sorted-set,sorted-set-by,sorted?,special-form-anchor,special-symbol?,split-at,%
split-with,str,stream?,string?,struct,struct-map,subs,subseq,subvec,supers,swap!,symbol,symbol?,%
sync,syntax-symbol-anchor,take,take-last,take-nth,take-while,test,the-ns,throw,time,to-array,%
to-array-2d,trampoline,transient,tree-seq,true,true?,try,type,unchecked-add,unchecked-dec,%
unchecked-divide,unchecked-inc,unchecked-multiply,unchecked-negate,unchecked-remainder,%
unchecked-subtract,underive,unquote,unquote-splicing,update-in,update-proxy,use,val,vals,%
var,var-get,var-set,var?,vary-meta,vec,vector,vector?,when,when-first,when-let,when-not,%
while,with-bindings,with-bindings*,with-in-str,with-loading-context,with-local-vars,%
with-meta,with-open,with-out-str,with-precision,xml-seq,zero?,zipmap
},%
   sensitive,% ???
   alsodigit=-,%
   morecomment=[l];,%
   morestring=[b]"%
  }[keywords,comments,strings]%

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{stringgray}{rgb}{0.4,0.4,0.4}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{types}{rgb}{0.16, 0.32, 0.75}
%\definecolor{types}{rgb}{0.0, 0.75, 1.0}
\definecolor{turnstile}{rgb}{0.0, 0.5, 1.0}
%\definecolor{interop}{rgb}{0,0.8,0}
%\definecolor{interop}{rgb}{0.89, 0.44, 0.48}
\definecolor{interop}{rgb}{0.01, 0.75, 0.24}
\definecolor{invoke}{rgb}{0,0,0}

\lstset{ %
  upquote=true,
  language=clojure,                % choose the language of the code
  columns=fixed,basewidth=.5em,
  basicstyle=\ttfamily,       % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\small\ttfamily,      % the size of the fonts that are used for the line-numbers
  %stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
  %numbersep=5pt,                  % how far the line-numbers are from the code
  %backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  %showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  %showtabs=false,                 % show tabs within strings adding particular underscores
  %frame=single,           % adds a frame around the code
  %tabsize=2,          % sets default tabsize to 2 spaces
  %captionpos=t,           % sets the caption-position to bottom
  %breaklines=true,        % sets automatic line breaking
  %breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
  %escapeinside={\%*}{*)},          % if you want to add a comment within your code
  literate= 
            %{\#\{*set\ }{{\textcolor{red}{\#\{}}}1
            %{\ set*\}} {{\textcolor{red}{\}}}}1
            {\{}{{\textcolor{mygray}{\{}}}1
            {\}} {{\textcolor{mygray}{\}}}}1
            {\{*map\ }{{\textcolor{red}{\{}}}1
            {\ map*\}} {{\textcolor{red}{\}}}}1
            {[}  {{\textcolor{mygray}{[}}}1
            {]}  {{\textcolor{mygray}{]}}}1     
            {(}  {{\textcolor{mygray}{(}}}1
            {)}  {{\textcolor{mygray}{)}}}1     
            {:-}  {{\textcolor{types}{:-}}}1     
            {->}  {{\textcolor{mygray}{->}}}1     
            {[*vec\ }  {{\textcolor{red}{[}}}1
            {\ vec*]}  {{\textcolor{red}{]}}}1     
            {(*list\ }  {{\textcolor{red}{(}}}1
            {\ list*)}  {{\textcolor{red}{)}}}1     
            {(*interop\ }  {{\textcolor{interop}{(}}}1     
            {\ interop*)}  {{\textcolor{interop}{)}}}1     
            {(*typed\ }  {{\textcolor{types}{(}}}1     
            {\ typed*)}  {{\textcolor{types}{)}}}1     
            {(*invoke\ }  {{\textcolor{invoke}{(}}}1     
            {\ invoke*)}  {{\textcolor{invoke}{)}}}1     
}

\lstset{ %
  %backgroundcolor=\color{white},   % choose the background color
  %basicstyle=\footnotesize,        % size of fonts used for the code
  commentstyle=\color{mygray},    % comment style
  escapeinside={(*@}{@*)},
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\textbf,       % keyword style
  stringstyle=\color{stringgray}\textit,     % string literal style
}

\newcommand{\clj}[1]{\lstinline{#1}}
\newcommand{\java}[1]{\lstinline{#1}}
\newcommand{\rkt}[1]{\lstinline{#1}}

\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{alltt,fancyvrb}
\usepackage{mmm}
\usepackage{style}
\usepackage{tikz}
\usepackage{tikz-qtree}
\bibliographystyle{abbrvnat}
\include{bibliography.bib}

\newcommand{\cL}{{\cal L}}



%\makeatletter\if@ACM@journal\makeatother
%%% Journal information (used by PACMPL format)
%%% Supplied to authors by publisher for camera-ready submission
%\acmJournal{PACMPL}
%\acmVolume{1}
%\acmNumber{1}
%\acmArticle{1}
%\acmYear{2017}
%\acmMonth{1}
%\acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}
%\else\makeatother
%%% Conference information (used by SIGPLAN proceedings format)
%%% Supplied to authors by publisher for camera-ready submission
%\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
%\acmYear{2017}
%\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}
%\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
%\bibliographystyle{splncs03}
%\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
%\citestyle{acmauthoryear}   %% For author/year citations



\begin{document}

%\title{Development and study of Verification Tools for Clojure}
%\title{Typed Clojure in Practice}
%\title{Theory and Practice of Verification Tools for Clojure}
%\title{Theory, Practice, and Study of }
\title{Thesis Proposal: Theory, Practice, and Study of Clojure Verification Techniques for Clojure}

%% Author with single affiliation.
\author{Ambrose Bonnaire-Sergeant}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{Computer Science}              %% \department is recommended
  \institution{Indiana University}            %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  %\state{State1}
  %\postcode{Post-Code1}
  \country{USA}
}
\email{abonnair@indiana.edu}          %% \email is recommended

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
The Clojure programming language has existing tooling runtime and compile-time
verification.

This thesis argues Typed Clojure is sound and practical,
that we can improve usability with automatic annotations based on runtime observations,
and by repurposing this annotation technology to generate clojure.spec,
we can answer broad questions about how Clojure is used.

I will first present Typed Clojure, an optional type system for Clojure.
I will show a formal model of Typed Clojure that includes
key features like hash-maps, multimethods, Java interoperability, and occurrence typing,
and prove the model type sound.
Then, I will demonstrate that Typed Clojure's design is useful and corresponds to actual usage patterns
with an emperical study of real-world Typed Clojure usage in over 19,000 lines of code.

Next, I will present a tool that automatically generates Typed Clojure annotations based on observed
program behavior.
First, I will show a formal model of the tool, including its runtime instrumentation phase that
collects samples from a running program, and type reconstruction phase
that creates useful annotations from these samples.
Then, I will synthesize these ideas into a practical implementation that

\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
%\keywords{keyword1, keyword2, keyword3}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}


\subsection{Typed Clojure}

\subsection{Automatic Type Annotations}

\subsection{Investigation}

\section{Thesis Statement}

My thesis statement is:

\begin{quotation}
Typed Clojure is a sound and practical optional type system for Clojure whose annotation burden is partially-automatable, and this automation technology can be repurposed to further reveal how Clojure is used in real projects.
%Typed Clojure is sound, practical, and its annotation burden is partially-automatable,
%and we can repurpose this annotation technology to
%answer broad questions about how Clojure is used.
%Typed Clojure is a well-founded and practical optional type system for Clojure
%whose useability can be improved by
%developing a tool to automatically generate type annotations,
%and, by repurposing this tool, we can study general Clojure idioms and practices across
%hundreds of projects by generating, running, and exercising clojure.spec runtime specifications.
\end{quotation}

I will support this thesis statement with the following:

\begin{itemize}
  \item \emph{Typed Clojure is sound} We formalize Typed Clojure, including
    its characteristic features like hash-maps, multimethods, and Java interoperability,
    and prove the model type sound.
  \item \emph{Typed Clojure is practical} We present an emperical study of real-world Typed Clojure usage
    over 19,000 lines of code, showing its features correspond to actual usage patterns.
  \item \emph{Typed Clojure's annotation burden is partially-automatable} We formalize and implement a tool to generate
    type annotations, and emperically study the manual changes needed for the generated annotations
    to pass type checking.
  %\item \emph{clojure.spec model and Automatic Annotations} 
  \item \emph{Repurpose automation technology}
    We describe how to automatically generate clojure.spec annotations (``specs'') for existing programs.
    We present a formal model of clojure.spec (an existing and popular runtime verification tool for Clojure)
    and implement the model in Redex.
  \item \emph{Further reveal how Clojure is used in real projects}
    We conduct a study of general Clojure idioms and practices by generating, enforcing, and exercising specs
    across hundreds of projects, as well as justifying design choices in Typed Clojure's type system,
    clojure.spec's features, and our automatic annotation tool.
\end{itemize}

\section{Technical Overview}

\section{Related Work}

% Cite a few of the early papers here.
%http://www.cs.washington.edu/research/projects/cecil/www/pubs/
\paragraph{Multimethods} 
Millstein and collaborators present a sequence of
systems~\cite{Chambers:1992:OMC,Chambers:1994:TMM,MS02} with statically-typed multimethods
and modular type checking.  In contrast to Typed Clojure, in these
system methods declare the types of arguments that they expect which
corresponds to exclusively using \clj{class} as the dispatch function
in Typed Clojure. However, Typed Clojure does not attempt to rule out
failed dispatches.

% one sentence
% TC based on TR, already covered

\paragraph{Occurrence Typing} 
Occurrence typing~\cite{TF08,TF10} extends the type 
system with a \emph{proposition environment} that represents 
the information on the types of bindings down conditional branches.
These propositions are then used to update the types associated
with bindings in the \emph{type environment} down branches
so binding occurrences are given different types 
depending on the branches they appear in, and the conditionals
that lead to that branch.

% What's diff about TC from the related work
% small summary for deisel....
% - diesel supports x
%- - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wand89typeinference,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

TeJaS~\cite{TeJaS}, another type system for JavaScript,
also supports similar HMaps, with the ability to
record the presence and absence of entries, but lacks a compositional
flow-checking approach like occurrence typing.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

\paragraph{Java Interoperability in Statically Typed Languages}
Scala~\cite{OCD+} has nullable references for compatibility with Java.
Programmers must manually check for
\java{null} as in Java to avoid null-pointer exceptions. 


\paragraph{Other optional and gradual type systems}
%In addition to Typed Racket, 
Several other gradual type
systems have been developed for existing
dynamically-typed languages.  Reticulated Python~\cite{Vitousek14} is
an experimental gradually typed system for Python, implemented as a
source-to-source translation that inserts dynamic checks at language
boundaries and supporting Python's first-class object system. 
Clojure's nominal classes avoids the need to support
first-class object system in Typed Clojure, however HMaps offer an alternative to
the structural objects offered by Reticulated. Similarly,
Gradualtalk~\cite{gradualtalk} offers gradual typing for Smalltalk,
with nominal classes.

Optional types
%, requiring less implementation effort and avoiding
%runtime cost, 
have been  adopted in industry, including Hack~\cite{hack}, and Flow~\cite{flow} and
TypeScript~\cite{typescript}, two extensions of JavaScript. These
systems  support  limited forms of occurrence typing,
and do not include the other features we
present.

%  \item GradualTalk
%  \item Flow
%\end{itemize}

\paragraph{Automatic annotations}
There are two common implementation strategies for such tools. The first
strategy, ``ruling-out'' (for invariant detection), assumes all invariants are true 
and then use runtime analysis results to rule out
impossible invariants. The second ``building-up'' strategy (for dynamic type inference)
assumes nothing and then uses runtime analysis results to build up invariant/type knowledge.

Examples of invariant detection tools include Daikon \cite{Ernst06thedaikon},
DIDUCE \cite{hangal2002tracking}, and Carrot \cite{pytlik2003automated}, and
typically enhance statically typed languages with more expressive types or contracts.
Examples of dynamic type inference include Rubydust \cite{An10dynamicinference},
JSTrace \cite{saftoiu2010jstrace}, and TypeDevil \cite{pradel2015typedevil},
and typically target untyped languages.

Both strategies have different space behavior with respect to representing
the set of known invariants.
The ruling-out strategy typically uses a lot of memory at the beginning,
but then can free memory as it rules out invariants. For example, if
\texttt{odd(x)} and \texttt{even(x)} are assumed, observing \texttt{x = 1}
means we can delete and free the memory recording \texttt{even(x)}.
Alternatively, the building-up strategy uses the least memory storing
known invariants/types at the beginning, but increases memory usage
as more the more samples are collected. For example, if we know
\texttt{x : Bottom}, and we observe \texttt{x = "a"} and \texttt{x = 1}
at different points in the program, we must use more memory to
store the union \texttt{x : String $\cup$ Integer} in our set of known invariants.

\paragraph{Daikon}
Daikon can reason about very expressive relationships between variables
using properties like ordering ($x < y$), linear relationships ($y = ax + b$),
and containment ($x \in y$). It also supports reasoning with ``derived variables''
like fields ($x.f$), and array accesses ($a[i]$).

Typed Clojure's dynamic inference can record heterogeneous data structures
like vectors and hash-maps, but otherwise cannot express relationships
between variables.

There are several reasons for this. The most prominent is that Daikon
primarily targets Java-like languages, so inferring simple type information
would be redundant with the explicit typing disciplines of these languages.
On the other hand, the process of moving from Clojure to Typed Clojure
mostly involves writing simple type signatures without dependencies
between variables. Typed Clojure recovers relevant dependent information
via occurrence typing, and gives the option to manually annotate necessary
dependencies in function signatures when needed.

% Inference and Evolution of TypeScript Declaration Files
% - they submit pull requests from their tool's output
% https://cs.au.dk/~amoeller/papers/tstools/paper.pdf

\section{Research Plan and Timeline}

I plan to publish the following papers:

\begin{itemize}
  \item \textbf{ESOP 2016 - Published} \emph{Practical Optional Types for Clojure}.
    A paper that provides a formal model of Typed Clojure and presents an emperical
    study of usage patterns.
  \item \textbf{Spring 2018} \emph{}
\end{itemize}

\bibliography{bibliography}


\end{document}
