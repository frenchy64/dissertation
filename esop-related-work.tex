\chapter{Related Work to Typed Clojure}

% Cite a few of the early papers here.
%http://www.cs.washington.edu/research/projects/cecil/www/pubs/
\paragraph{Multimethods} 
\cite{MS02} and collaborators present a sequence of
systems~\cite{Chambers:1992:OMC,Chambers:1994:TMM,MS02} with statically-typed multimethods
and modular type checking.  In contrast to Typed Clojure, in these
system methods declare the types of arguments that they expect which
corresponds to exclusively using \clj{class} as the dispatch function
in Typed Clojure. However, Typed Clojure does not attempt to rule out
failed dispatches.

% one sentence
% TC based on TR, already covered

%\paragraph{Occurrence Typing} 
%Occurrence typing~\cite{TF08,TF10} extends the type 
%system with a \emph{proposition environment} that represents 
%the information on the types of bindings down conditional branches.
%These propositions are then used to update the types associated
%with bindings in the \emph{type environment} down branches
%so binding occurrences are given different types 
%depending on the branches they appear in, and the conditionals
%that lead to that branch.

% What's diff about TC from the related work
% small summary for deisel....
% - diesel supports x
%- - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wand89typeinference,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

TeJaS~\cite{TeJaS}, another type system for JavaScript,
also supports similar HMaps, with the ability to
record the presence and absence of entries, but lacks a compositional
flow-checking approach like occurrence typing.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

\paragraph{Java Interoperability in Statically Typed Languages}
Scala~\cite{OCD+} has nullable references for compatibility with Java.
Programmers must manually check for
\java{null} as in Java to avoid null-pointer exceptions. 


\paragraph{Other optional and gradual type systems}
%In addition to Typed Racket, 
Several other gradual type
systems have been developed for existing
dynamically-typed languages.  Reticulated Python~\cite{Vitousek14} is
an experimental gradually typed system for Python, implemented as a
source-to-source translation that inserts dynamic checks at language
boundaries and supporting Python's first-class object system. 
Clojure's nominal classes avoids the need to support
first-class object system in Typed Clojure, however HMaps offer an alternative to
the structural objects offered by Reticulated. Similarly,
Gradualtalk~\cite{gradualtalk} offers gradual typing for Smalltalk,
with nominal classes.

Optional types
%, requiring less implementation effort and avoiding
%runtime cost, 
have been  adopted in industry, including Hack~\cite{hack}, and Flow~\cite{flow} and
TypeScript~\cite{typescript}, two extensions of JavaScript. These
systems  support  limited forms of occurrence typing,
and do not include the other features we
present.

%  \item GradualTalk
%  \item Flow
%\end{itemize}


