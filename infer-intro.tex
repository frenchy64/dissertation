\Dchapter{Introduction}
\label{infer:chapter:intro}

%\input{infer-old-pldi-intro}

Consider the exercise of counting binary tree nodes using JavaScript.
With a class-based tree representation, we naturally add a method
to each kind of node like so.

\begin{lstlisting}[language=JavaScript]
class Node { nodes() { return 1 + this.left.nodes() + this.right.nodes(); } }
class Leaf { nodes() { return 1; } }
new Node(new Leaf(1), new Leaf(2)).nodes(); //=> 3 (constructors implicit)
\end{lstlisting}

An alternative ``ad-hoc'' representation uses plain JavaScript Objects
with explicit tags.
Then, the method becomes a recursive function that explicitly takes a tree as input.
We trade the extensiblility and (presumably) speed of a method for a simple, reversible serialization to JSON.

\begin{lstlisting}[language=JavaScript]
function nodes(t) { switch t.op { 
                      case "node": return 1 + nodes(t.left) + nodes(t.right);
                      case "leaf": return 1; } }
nodes({op: "node", left:{op: "leaf", val: 1}, right:{op: "leaf", val: 2}})//=>3
\end{lstlisting}

Now, consider the problem of inferring type annotations for these programs.
The class-based representation is idiomatic to popular dynamic languages
like JavaScript and Python, and so many existing solutions support it.
%~\infercitep{saftoiu2010jstrace,pyannotate,typette18,An10dynamicinference,pytype,kristensen2017inference}
For example, TypeWiz~\infercitep{typewiz} uses dynamic analysis to generate
the following TypeScript annotations from the above example execution of \js{nodes}.

\begin{lstlisting}[language=JavaScript]
class Node { public left: @Leaf@; public right: @Leaf@; ... }
class Leaf { public val: @number@; ... }
\end{lstlisting}

The intuition behind inferring such a type is straightforward.
For example, an instance of \js{Leaf} was observed in \js{Node}'s \js{left} field,
and so the nominal type \js{Leaf} is used for its annotation.

The second ``ad-hoc'' style of programming seems peculiar in JavaScript, Python, and, indeed,
object-oriented style in general.
Correspondingly, existing state-of-the-art automatic annotation tools are not designed
to support them.
There are several ways to trivially handle such cases.
Some enumerate the tree representation verbatim, like TypeWiz~\infercitep{typewiz}.

\begin{lstlisting}[language=JavaScript]
function nodes(t: {left: {op: string, val: number}, op: string,
                   right: {op: string, val: number}}
                | {op: string, val: number}) ...
\end{lstlisting}

Others discard most (or all) structure, like Typette~\infercitep{typette18} 
and PyType~\infercitep{pytype} for Python.

\begin{lstlisting}[language=Python]
def nodes(t: Dict[(Sequence, object)]) -> int: ... // Typette
def nodes(t) -> int: ...                           // PyType
\end{lstlisting}

Each annotation is clearly insufficient to meaningfully check both the function definition
and valid usages. To show a desirable annotation for the ``ad-hoc'' program,
we show the same program in Clojure~\infercitep{Hic08}, where such programs
are idiomatic and fully supported by its built-in runtime verification library
clojure.spec and its primary optional type system Typed Clojure~\infercitep{bonnaire2016practical}.

\begin{cljlisting}
(defn nodes [t] (case (:op t)
                  :node (+ 1 (nodes (:left t)) (nodes (:right t)))
                  :leaf 1))
(nodes {:op :node, :left {:op :leaf, :val 1}, :right {:op :leaf, :val 2}}) ;=>3
\end{cljlisting}

% talk about "why" it's idiomatic in Clojure.
% - hamt's
% - multimethods give extensibility
% - functional programming with immutable values
