\Dchapter{Introduction}

Transitioning to an optional type system
requires adding type annotations,
a significant manual burden.
There has been significant interest in 
tooling to help create~\cite{saftoiu2010jstrace,pyannotate,typette18,An10dynamicinference,pytype} and
evolve~\cite{kristensen2017inference}
these annotations.

In common with most of these tools are
object orientation, % (JavaScript, Ruby, and Python)
and accessible class declarations.
Recursive types are then naturally inferred from local class invariants,
like a \texttt{Tree} class containing fields of type \texttt{Tree}.
Unfortunately, these approaches are dependent on these names to infer
further structure to their types, and so
do not extend to annotating plain recursive data
such as JSON or heterogeneous dictionaries.

Such recursive data is particularly common in Clojure programs.
For example, take \clj{nodes}, a Clojure function that counts
the nodes in a tree represented by nested maps.
\begin{cljlisting}
(defn nodes [t]
  (case (:op t)
    :leaf 1
    :node (+ 1 (nodes (:left t))
               (nodes (:right t)))))
(assert (= 3 (nodes
               {:op :node 
                :left {:op :leaf :val 2}
                :right {:op :leaf :val 3}})))
\end{cljlisting}
%
Existing automated annotation approaches cannot derive
any further structure to the input of \clj{nodes}, other
than its explicit runtime representation:
%
\begin{cljlisting}
(ann vertices ['{:op Keyword,
                 :left '{:op Keyword :val Int},
                 :right '{:op Keyword :val Int}}
               -> Int])
\end{cljlisting}
%
Our tool instead recognizes that the programmer
%
\begin{cljlisting}
(defalias Op 
  (U '{:op ':node, :left Op, :right Op}
     '{:op ':leaf, :val Int}))
(ann vertices [Op -> Int])
\end{cljlisting}

%, where plain
%heterogeneous hash-maps are idiomatic over predefined classes or records.
%Typed Clojure, in turn, has extensive support for specifying and checking
%heterogeneous maps.
%However, the high annotation burden has put off industrial users in practice.
%

% - set the scene for inferring types
%   - Typed Clojure
%   - optional/gradual typing requires annotations

% Typed Clojure has interesting idioms.
% Similarly we have to take into account specific idioms,
% Must deal with same realities as ESOP
% - need HMap's because we know.
% What does TypeScript auto ann do with `vertices`?
% - not class based
% - try python systems
% 
% - need to guess nominal names
% - need to guess grouping
% - nominal types: don't need to think about recursion
%  - just give a name, indirection is directed in a big table of names
%  - humans are used to referring things by name

% other 

% a class invariant is a recursive property "for free"
% - check locally, get recursion for free

% nothing for free in our setting

% we have names but not nominal types

This paper starts to address a major usability flaw
for gradually and optionally typed languages:
writing type annotations is a manual process.

Take \texttt{vertices} (\figref{infer:fig:vertices}),
written in Clojure.
As is good style, it comes with a unit test.
Our goal is to \textit{generate} Typed Clojure~\cite{bonnaire2016practical}
annotations
for this function, relieving most of the annotation
burden.

%\begin{figure}
%\begin{cljlisting}
%(defn nodes [t]
%  (case (:op t)
%    :leaf 1
%    :node (+ 1 (nodes (:left t))
%               (nodes (:right t)))))
%(assert (= 3 (nodes
%               {:op :node 
%                :left {:op :leaf :val 2}
%                :right {:op :leaf :val 3}})))
%\end{cljlisting}
%\caption{A Clojure function counting tree nodes, with test.}
%\label{infer:fig:vertices}
%\end{figure}

%\begin{figure}
%\begin{cljlisting}
%(defalias Op (U '{:op ':node ':left Op ':right Op}
%                '{:op ':leaf ':val Int}))
%(ann nodes [Op -> Int])
%\end{cljlisting}
%\caption{Automatically inferred Typed Clojure annotations.}
%\label{infer:fig:verticestype}
%\end{figure}

Our approach features several stages.
First, we \textit{instrument} top-level functions
(Section \ref{instrument-TODO}),
then run the unit tests and \textit{track}
how they are used at runtime
(Section \ref{track-TODO}).
At this point, we have a preliminary
annotation:

\begin{cljlisting}
(ann vertices ['{:op ':node,
                 :left '{:op ':leaf :val Int},
                 :right '{:op ':leaf :val Int}}
               -> Int])
\end{cljlisting}

This type is too specific---trees are recursively
defined---we \textit{squash} types to be
recursive from example unrollings (Section \ref{recursive-TODO}):

\begin{cljlisting}
(defalias Op 
  (U '{:op ':node, :left Op, :right Op}
     '{:op ':leaf, :val Int}))
(ann vertices [Op -> Int])
\end{cljlisting}

%\begin{Verbatim}
%(declare Node Leaf)
%(defalias Op (U Node Leaf))
%(defalias Node 
%  '{:op ':node :left Op :right Op})
%(defalias Leaf '{:op ':leaf :val int})
%(ann verbatim [Op -> Int]})
%\end{Verbatim}
%
If \texttt{Op} is used in multiple positions
in the program, local recursive types are redundant.
In this paper, we name and \textit{merge} recursive
types, reusing them in annotations.
 
\begin{cljlisting}
(ann vertices [Op -> Int])
(ann sum-tree [Op Op -> Op])
\end{cljlisting}
 
If minor variants of the recursive types occur
across a program,
we use \textit{optional} entries%~\cite{typed-clojure}
to reduce redundancy (Section \ref{optional-merge-TODO}).
 
\begin{cljlisting}
(defalias Op 
  (U '{:op ':node, :left Op, :right Op}
     (HMap :mandatory {:op ':leaf :val Int}
           :optional {:label Str})))
\end{cljlisting}

After inserting these annotations, we can run the
type checker over them to check their usefulness.
We found annotations to be readable and minimize
redundancy compared to hand-written annotations
(Section \ref{experiment1}).
Minimal changes were needed to successfully type check
functions with the generated annotations,
mostly consisting of local function and loop annotations,
and renaming of type aliases
(Section \ref{experiment2}).
Generating and running \textit{tests} improved the quality
of type annotations by exercising more paths through the
program (Section \ref{experiment3}).

%Several open questions remain.
%Automatically
%drawing the typed-untyped boundary in gradual typing
%would mean less manual casts are needed.
%(Section \ref{boundaries}).

%The Clojure programming language has several verification
%systems that require annotating your programs.
%Typed Clojure is a type system that supports many Clojure
%idioms. Here, we must provide type annotations for
%top level variables, local functions, and invoked libraries.
%Clojure.spec is a pseudo contract system
%that can also generate tests.
%Similarly, specifications (``specs'') must be provided
%for all top level variables.
%
%These annotations are useful for learning about our programs,
%but they can be burdensome to write and maintain.
%Currently, one must reverse engineer annotations
%by visual analysis of the source code.
%
%In this paper, we present a tool that automatically
%generates annotations, based on the tests already present
%in idiomatic Clojure programs.
%These annotations are readable, compact, feature good
%names, and recover recursively defined records.
%There is no guarantee the generated annotations will
%immediately type check, however.
%
%Our goal is to minimize the difference needed
%to type check programs from the generated annotations.
%We envision programmers running our tool, generating
%a few dozen lines of annotations, and only a fraction
%of them should need manual changing to actually type
%check a program.

% - give introductory example
%   - generate types + specs
%   - show delta needed to typecheck
% - enumerate our contributions
% - signpost the rest of the paper


\Dsection*{Contributions}
\begin{itemize}
\item We outline a generalized approach to automatically
    generating type annotations.
%\item
%  Our main contribution is a robust, easy to use, open source tool that 
%  Clojure programmers can use to help learn about and specify 
%  their programs.
\item
  We describe a novel approach to reconstructing recursively
  defined structural records from fully unrolled examples.
\item
  We report our experience using this algorithm to generate
  types, tests, and contracts on several
  Clojure libraries and programs.
\item
  We include a formal model of our inference algorithm.
\end{itemize}
