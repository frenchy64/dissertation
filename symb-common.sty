\usepackage{esop-common}
\usepackage{esop-clj-grammar}
\usepackage{color}
\usepackage{amssymb}
\usepackage{mathtools}

% support nesting arrays in mathpartir rules.
% this defines a command \arcr that is like \\ for inner arrays.
% from: https://gist.github.com/lambdageek/075ea17f362bc455467a
\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\newcommand\ltivarsymbol{\ma{x}}
\newmeta\ltivar{\ltivarsymbol}
\newmeta\ltivarp{\ltivarsymbol'}
\newmeta\ltivarpp{\ltivarsymbol''}
\newcommand\ltiEsymbol{\esope}
\newmeta\ltiE{\ltiEsymbol}
\newmeta\ltiEp{\ltiEsymbol'}
\newmeta\ltiEpp{\ltiEsymbol''}
\newcommand\ltiFsymbol{\ma{f}}
\newmeta\ltiF{\ltiFsymbol}
\newmeta\ltiFp{\ltiFsymbol'}
\newmeta\ltiFpp{\ltiFsymbol''}
% tagged terms
\newmeta\ltiEl{\ltiEsymbol^{}}
\newmeta\ltiElp{\ltiEsymbol'^{}}
\newmeta\ltiFl{\ltiFsymbol^{}}
\newmeta\ltiFlp{\ltiFsymbol'^{}}
\newcommand\ltiClosureIDsymbol{\ma{\mathbb{I}}}
\newmeta\ltiClosureID{\ma{\ltiClosureIDsymbol}}
\newmeta\ltiClosureIDp{\ma{\ltiClosureIDsymbol'}}
%\newcommand\ltifun[4]{\ma{\textbf{fun}[#1](\hastype{#2}{#3})#4}}
\newcommand\ltifun[4]{\ma{\abs{[#1]#2}{#3}{#4}}}
\newcommand\ltifuninterfaceLHS[2]{\ma{\l^{#1}(#2)}}
\newcommand\ltifuninterface[3]{\ma{{\ltifuninterfaceLHS{#1}{#2}} {#3}}}
% tvars T x
\newcommand\ltifuntparaminterfaceLHS[3]{\ma{\l[#1]^{#2} (#3)}}
% tvars T x e
\newcommand\ltifuntparaminterface[4]{\ma{{\ltifuntparaminterfaceLHS{#1}{#2}{#3}} {#4}}}
% tvars x Tin e
\newcommand\ltifuntparamargtype[4]{\ma{\l[#1](\hastypesmall{#2}{#3}) #4}}
% tvars x Tin Tout e
\newcommand\ltifuntparamargrettype[5]{\ma{\l[#1]\hastypesmall{(\hastypesmall{#2}{#3})}{#4} #5}}
% x Tin e
\newcommand\ltifunargtype[3]{\ma{\l(\hastypesmall{#1}{#2}) #3}}
% x Tin Tout e
\newcommand\ltifunargrettype[4]{\ma{\l\hastypesmall{(\hastypesmall{#1}{#2})}{#3} #4}}
% EnclosingFnStack => T
\newcommand\ltistackmappingsymbol{\ma{\vdash}}
\newcommand\ltistackmapping[2]{\ma{{#1} \ltistackmappingsymbol {#2}}}
\newcommand\ltifunmono[3]{\ma{\ltifuninterface{}{#2}{#3}}}
\newcommand\ltiufun[2]{\ma{\l (#1) #2}}
% ID
\newcommand\ltiufunelabentry[1]{\ma{#1}}
%% Closure-Tagged Term
% ElabEntry x E
\newcommand\ltiufunelab[3]{\ma{\l_{#1} (#2) #3}}
% ElabEntry T x E
\newcommand\ltiufunelabinterface[4]{\ma{\l^{#2}_{#1} (#3) #4}}
% T ElabEntry x E
\newcommand\ltifunelab[4]{\ma{\l^{#1}_{#2} #3 . #4}}
\newcommand\ltiappinfix[2]{\ma{#1(#2)}}
\newcommand\ltiappinst[3]{\ma{\ltiappinfix{#1[#2]}{#3}}}
\newcommand\ltiapp[2]{\ma{\ltiappinfix{#1}{#2}}}
\newcommand\ltiappParens[2]{\ma{\ltiapp{(#1)}{#2}}}
\newcommand\ltiann[2]{\ma{(\textsf{ann}\ #1\ #2)}}
\newcommand\ltianncolon[2]{\ma{(#1 : #2)}}
\newcommand\ltilet[3]{\ma{\textsf{let}\ {#1} = {#2}\ \textsf{in}\ {#3}}}
\newcommand\ltiif[3]{\ma{\textsf{if}\ {#1}\ \textsf{then}\ {#2}\ \textsf{else}\ {#3}}}
%\newcommand\ltisel[2]{\ma{\ltiapp{. #2}{#1}}}
\newcommand\ltisel[2]{\ma{#1.#2}}
\newcommand\ltirec[1]{\ma{\{#1\}}}
\newcommand\ltimatchsuper[2]{\ma{#1 \nearrow #2}}
\newcommand\ltimatchsub[2]{\ma{#1 \searrow #2}}
\newcommand\ltiALPHA{\alpha}
\newmeta\ltitvar{\ltiALPHA}
\newmeta\ltitvarp{\ltiALPHA'}
\newmeta\ltitvarpp{\ltiALPHA''}
\newcommand\ltiCletter{\ma{C}}
%Constraints
\newmeta\ltiC{\ma{\ltiCletter}}
\newmeta\ltiCp{\ma{\ltiCletter'}}
\newmeta\ltiCpp{\ma{\ltiCletter''}}
% (unused constraint metavariable)
\newmeta\ltiD{D}
\newmeta\ltiT{\esoptau}
\newmeta\ltiTp{\esoptau'}
\newmeta\ltiTpp{\esoptau''}
\newmeta\ltiS{\esopsigma}
\newmeta\ltiSp{\esopsigma'}
\newmeta\ltiSpp{\esopsigma''}
\newcommand\ltiRletter{\chi}
\newmeta\ltiR{\ltiRletter}
\newmeta\ltiRp{\ltiRletter'}
\newmeta\ltiRpp{\ltiRletter''}
\newmeta\ltiP{P}
\newmeta\ltiPp{P'}
\newmeta\ltiV{V}

% threaded environments
\newcommand\ltiFuelsymbol{\mathbb{F}}
\newmeta\ltiFuel{\ltiFuelsymbol}
\newmeta\ltiFuelp{\ltiFuelsymbol'}
\newmeta\ltiFuelpp{\ltiFuelsymbol''}
\newcommand\ltiClosureCachesymbol{\mathbb{E}}
\newcommand\ltiEmptyClosureCache{\ma{\varnothing}}
\newmeta\ltiClosureCache{\ltiClosureCachesymbol}
\newmeta\ltiClosureCachep{\ltiClosureCachesymbol'}
\newmeta\ltiClosureCachepp{\ltiClosureCachesymbol''}
% I -> ClosureCacheVal
\newcommand\ltiClosureCacheEntry[2]{\ma{#1 \Rightarrow #2}}
\newcommand\ltiClosureCacheVal[2]{\ma{\langle #1, #2 \rangle}}
\newcommand\ltiCombinedThreadedEnvsymbol{\ma{\Delta}}
\newmeta\ltiCombinedThreadedEnv{\ltiCombinedThreadedEnvsymbol}
\newmeta\ltiCombinedThreadedEnvp{\ltiCombinedThreadedEnvsymbol'}
\newmeta\ltiCombinedThreadedEnvpp{\ltiCombinedThreadedEnvsymbol''}
\newcommand\ltimakeCombinedThreadedEnv[2]{\ma{#1 ; #2}}

% combined stack environments
\newcommand\ltiCombinedStackEnvsymbol{\ma{\Sigma}}
\newmeta\ltiCombinedStackEnv{\ltiCombinedStackEnvsymbol}
\newmeta\ltiCombinedStackEnvp{\ltiCombinedStackEnvsymbol'}
\newcommand\ltimakeCombinedStackEnv[2]{\ma{#1 ; #2}}

\newmeta\ltinat{n}
\newcommand\ltiEmptyEnv{\ma{\epsilon}}
\newcommand\ltiEnvsymbol{\ma{\Gamma}}
\newmeta\ltiEnv{\ma{\ltiEnvsymbol}}
\newmeta\ltiEnvp{\ma{\ltiEnvsymbol'}}
\newmeta\ltiEnvpp{\ma{\ltiEnvsymbol''}}
\newcommand\ltiEnclosingFnStacksymbol{\ma{\mathbb{S}}}
\newmeta\ltiEnclosingFnStack{\ltiEnclosingFnStacksymbol}
\newmeta\ltiEnclosingFnStackp{\ltiEnclosingFnStacksymbol'}
\newmeta\ltiEnclosingFnStackpp{\ltiEnclosingFnStacksymbol''}
\newmeta\ltiSubtypeSeen{\ma{\mathbb{M}}}
\newmeta\ltiWild{?}
\newcommand\ltiTop{\ma{\top}}
\newcommand\ltiBot{\ma{\bot}}
\newcommand\ltiTypeCase[2]{\ma{(\mathsf{TCase}\ #1\ #2)}}
\newcommand\ltiTypeCaseClause[2]{\ma{#1 \Rightarrow #2}}
\newcommand\ltiEnclosingFnType[1]{\ma{(\mathsf{EnclFn}\ #1)}}
\newcommand\ltiMu[2]{\ma{\mu #1. #2}}
\newcommand\ltiAppAllOne[1]{\ma{(\mathsf{App}\ #1)}}
\newcommand\ltiAppAll[2]{\ma{\ltiAppAllOne{#1\ #2}}}
\newcommand\ltiUnion[1]{\ma{(\bigcup #1)}}
\newcommand\ltiIntersection[1]{\ma{(\bigcap #1)}}
\newcommand\ltiIntersecttwo[2]{\ma{(\cap\ #1\ #2)}}
\newcommand\ltiEmptyIntersection{\ma{(\cap)}}
\newcommand\ltiMeetLHS[2]{\ma{#1 \wedge #2}}
\newcommand\ltiMeetMany[1]{\ma{\bigwedge #1}}
\newcommand\ltiMeet[3]{\ma{\ltiMeetLHS{#1}{#2} = #3}}
\newcommand\ltiMeetalign[3]{\ma{\ltiMeetLHS{#1}{&#2} &=& #3}}
\newbfop\ltiSeqableOp{S}
\newbfop\ltiInt{I}
\newcommand\ltiEnvConcat[2]{\ma{#1 , #2}}
\newcommand\ltiEnvConcatParen[2]{\ma{(\ltiEnvConcat{#1}{#2})}}
\newcommand\ltiStackConcat[2]{\ma{#1 , #2}}
% Stack T
\newcommand\ltiStackEmpty{\ma{[]}}
\newcommand\ltiStackPush[2]{\ma{#1 :: #2}}
\newcommand\ltiSeenConcat[2]{\ma{#1 , #2}}
\newcommand\ltiSeenEntry[2]{\ma{\langle #1 , #2 \rangle}}
\newcommand\ltiSeqable[1]{\ma{\ltiSeqableOp #1}}
\newcommand\ltiRec[1]{\ma{\{#1\}}}
\newcommand\ltiPoly[2]{\ma{\forall #1. #2}}
\newcommand\ltiExists[2]{\ma{\exists #1. #2}}
\newcommand\ltiIFnsymbol{\ma{\bigcap}}
\newcommand\ltiIFn[1]{\ma{(\ltiIFnsymbol #1)}}
\newcommand\ltiSplitIFn[2]{\ma{({\ltiIFnsymbol}_{#2}^{#1})}}
\newcommand\ltiEmptyIFn{\ma{(\ltiIFnsymbol)}}
\newcommand\ltiFn[2]{\ma{[#1 \rightarrow #2]}}
% Env T T
\newcommand\ltiContextualFn[3]{\ma{\ltistackmapping{#1}{\ltiFn{#2}{#3}}}}
\newcommand\ltiPolyFn[3]{\ma{#1 \xrightarrow[]{#2} #3}}
\newcommand\ltiArrow[3]{\ma{(#1 \xrightarrow[]{#2} #3)}}
\newcommand\ltiArrowMono[2]{\ma{(#1 \xrightarrow[]{} #2)}}
% Stack Env Id E
\newcommand\ltiClosureWithStkID[3]{\ma{#1 @^{#2} #3}}
\newcommand\ltiClosureWithStkIDParens[3]{\ma{(\ltiClosureWithStkID{#1}{#2}{#3})}}
\newcommand\ltiClosure[2]{\ma{\ltiClosureWithStkID{#1}{}{#2}}}
% \sigma in Pierce & Turner
\newmeta\ltisubst{\ma{S}}
% Subst Type
\newcommand\ltiApplySubst[2]{\ma{#1 #2}}
% Constraint Result -> Subst
\newcommand\ltiSubst[3]{\ma{\metafunctionfont{genSubst}(#1 , #2) = #3}}
% v for x
\newcommand\ltireplaceentry[2]{\ma{#1 / #2}}
\newcommand\ltireplaceSingle[2]{\ma{[#1]#2}}
\newcommand\ltireplace[3]{\ma{\ltireplaceSingle{\ltireplaceentry{#1}{#2}}{#3}}}
\newcommand\ltireplaceova[3]{\ma{\ltireplaceSingle{\ova{\ltireplaceentry{#1}{#2}}}{#3}}}
\newcommand\ltireplaceoverrightarrowcaption[4]{\ma{\ltireplaceSingle{\overrightarrowcaption{\ltireplaceentry{#1}{#2}}^{#3}}{#4}}}
\newcommand\ltimapsto[3]{\ma{#1 [#2 \mapsto #3]}}
\newcommand\ltilookup[2]{\ma{#1[#2]}}
\newcommand\ltifvLHS[1]{\ma{\metafunctionfont{fv}(#1)}}
\newcommand\ltifv[2]{\ma{\ltifvLHS{#1} = #2}}
% Env -> Env
\newcommand\ltiEnvTVarsLHS[1]{\ma{\metafunctionfont{envTV}(#1)}}
\newcommand\ltiEnvTVars[2]{\ma{\ltiEnvTVarsLHS{#1} = #2}}
\newcommand\ltiEnvTVarsalign[2]{\ma{\ltiEnvTVarsLHS{#1} &=& #2}}
% DefEnv AppEnv -> Env
\newcommand\ltiEnvMissingTVarsLHS[2]{\ma{\metafunctionfont{addTV}(#1,#2)}}
\newcommand\ltiEnvMissingTVars[3]{\ma{\ltiEnvMissingTVarsLHS{#1}{#2} = #3}}
\newcommand\ltiEnvMissingTVarsalign[3]{\ma{\EnvMissingTVarsLHS{#1}{#2} &=& #3}}
% type inference algorithm
\newcommand\ltijudgement[4]{\ma{#1, #2 \vdash^{w} {\hastype{#3}{#4}}}}
% external type system
\newcommand\lticjudgementvdash{\ma{\vdash^{c}}}
\newcommand\lticjudgement[3]{\ma{#1 \lticjudgementvdash {\hastype{#2}{#3}}}}
% external type system with fuel
\newcommand\lticfjudgement[5]{\ma{#1, #2 \lticjudgementvdash {\hastype{#3}{#4}} \dashv  #5}}
% type argument calculations (internal language)
% Lang Env TVar* StackMapping<Env,R*> -> R*
\newcommand\ltiLfindTALHS[4]{\ma{\metafunctionfont{calcTA}(#2,#3,#4)}}
\newcommand\ltiLfindTA[5]{\ma{\ltiLfindTALHS{#1}{#2}{#3}{#4} = #5}}
% CombinedEnv Env TVar* StackMapping<Env,R*> -> R* ; CombinedEnv
\newcommand\ltiSfindTALHS[4]{\ma{\metafunctionfont{calcTAS}(#1,#2,#3,#4)}}
\newcommand\ltiSfindTA[6]{\ma{\ltiSfindTALHS{#1}{#2}{#3}{#4} = #5 ; #6}}

\newcommand\ltisubtypeseparator{\ma{\leq}}

% wrap in an extra pair of parens so superscripts work
\newcommand\overrightarrowcaption[1]{\ma{{\overrightarrow{#1}}}}

% top-level type inference
% Env E T => F
\newcommand\ltiinferTL[4]{\ma{#1 \vdash \hastype{#2}{#3} \hookrightarrow {#4}}}

%% Internal language (no symbolic closures, bidirectional type checking, or type arg synthesis)
\newcommand\ltiinternallabel{\ma{\ltilanguagelabelfont{I}}}
\newcommand\ltiLvdash[1]{\ma{\vdash_{#1}}}
\newcommand\ltiinternalvdash{\ma{\vdash}}
\newcommand\ltiinternalalgvdash{\ma{\vdash}}
% internal type system
% Env E : T
\newcommand\ltitjudgementNoElab[3]{\ma{#1 \ltiinternalalgvdash {\hastype{#2}{#3}}}}
% Env E : T => E'
\newcommand\ltitjudgement[4]{\ma{\ltitjudgementNoElab{#1}{#2}{#3} \Rightarrow #4}}
% subtype for internal types
% Env T <: T
\newcommand\ltiisubtype[3]{\ma{#2 \ltisubtypeseparator #3}}
% subtype for internal types with `seen` set
% Seen Env T <: T
\newcommand\ltiisubtypeseenSingleEnv[3]{\ma{#1 \ltiinternalvdash \ltiisubtype{#2}{#3}}}
\newcommand\ltiisubtypeseen[4]{\ma{\ltiisubtypeseenSingleEnv{#1}{#3}{#4}}}
% subtype (language agnostic
% Lang Seen+Env T T
\newcommand\ltiLsubtypeseenSingleEnv[4]{\ma{#2 \ltiLvdash{#1} #3 \ltisubtypeseparator #4}}
\newcommand\ltiLsubtypeEnv[4]{\ma{\ltiLsubtypeseenSingleEnv{#1}{#2}{#3}{#4}}}

\newcommand\ltilanguagelabelfont[1]{\ma{\textnormal{#1}}}

\newcommand\ltiexternallanglabel{\ma{\ltilanguagelabelfont{E}}}
%% symbolic closure language (no bidirectional type checking)
\newcommand\ltisclanglabel{\ma{\ltilanguagelabelfont{S}}}
\newcommand\ltisclangalgvdash{\ma{\vdash}}
\newcommand\ltisclangdeclvdash{\ma{\vdash_{\ltiexternallanglabel}}}
\newcommand\ltisclangvdash{\ma{\vdash}}
% symbolic closure type system
% ClosureCache Env |- E : T ; CombinedThreadedEnv ; E*
\newcommand\ltitSstkjudgementJustType[6]{\ma{{\hastype{#3}{#4}}}} %just e:t
\newcommand\ltitSstkjudgementNoElabCombined[6]{\ma{#2 \ltisclangalgvdash {\hastype{#3}{#4}}}} %omits elab, combined envs
\newcommand\ltitSstkjudgementNoElab[6]{\ma{#1 ; #2 \ltisclangalgvdash {\hastype{#3}{#4}} ; #5}} %omits elab
\newcommand\ltitSstkjudgementNoCombined[6]{\ma{#2 \ltisclangalgvdash {\hastype{#3}{#4}} ; #6}} %omits combined envs
\newcommand\ltitSstkjudgement[6]{\ma{\ltitSstkjudgementNoElab{#1}{#2}{#3}{#4}{#5}{} ; #6}}
% declarative symbolic closure type system
% Env E T => T ; E
\newcommand\ltitSdjudgement[4]{\ma{#1 \ltisclangdeclvdash {\hastype{#2}{#3}} \Rightarrow #4}}
% algorithmic subtyping for symbolic closure language types
% ThreadedEnv Env T T => T ThreadedEnv
\newcommand\ltiSsubtypeJustTypes[5]{\ma{#3 \ltisubtypeseparator #4}} % keeps just t <: t
\newcommand\ltiSsubtype[5]{\ma{#1 \ltisclangalgvdash #3 \ltisubtypeseparator #4 ; #5}}
% Seen ThreadedEnv Env T T => T ThreadedEnv
\newcommand\ltiSsubtypeseen[6]{\ma{#1 ; #2 \ltisclangalgvdash #4 \ltisubtypeseparator #5 ; #6}}
% declarative subtyping for symbolic closure language
% Env T <: T
\newcommand\ltiSdsubtype[3]{\ma{{#1} \ltisclangdeclvdash #2 \ltisubtypeseparator #3}}
% Seen Env T <: T
\newcommand\ltiSdsubtypeseen[4]{\ma{\ltiSdsubtype{#1;#2}{#3}{#4}}}
\newcommand\ltimergeTaggedTermssymbol{\ma{\metafunctionfont{mrg}}}
\newcommand\ltimergeTaggedTermsManyLHS[1]{\ma{\ltimergeTaggedTermssymbol\ #1}}
\newcommand\ltimergeTaggedTermsLHS[2]{\ma{\ltimergeTaggedTermssymbol(#1, #2)}}
\newcommand\ltimergeTaggedTermsLHSalign[2]{\ma{\ltimergeTaggedTermssymbol(#1, &#2)}}
\newcommand\ltimergeTaggedTerms[3]{\ma{\ltimergeTaggedTermsLHS{#1}{#2} = #3}}
\newcommand\ltimergeTaggedTermsalign[3]{\ma{\ltimergeTaggedTermsLHSalign{#1}{#2} &=& #3}}
% update closure cache
% ClosureCache ClosureID TVar* T_in T_out => ClosureCache
\newcommand\ltiupdateClosureCacheNoElabLHS[5]{\ma{\metafunctionfont{record}(#1,#2,#3,#4,#5)}}
\newcommand\ltiupdateClosureCacheNoElab[6]{\ma{\ltiupdateClosureCacheNoElabLHS{#1}{#2}{#3}{#4}{#5} = #6}}
\newcommand\ltiupdateClosureCacheNoElabalign[6]{\ma{\ltiupdateClosureCacheNoElabLHS{#1}{#2}{#3}{#4}{#5} &=& #6}}
% ClosureCache ClosureID TVar* T_in T_out E => ClosureCache
\newcommand\ltiupdateClosureCacheLHS[6]{\ma{\metafunctionfont{record}(#1,#2,#3,#4,#5,#6)}}
\newcommand\ltiupdateClosureCache[7]{\ma{\ltiupdateClosureCacheLHS{#1}{#2}{#3}{#4}{#5}{#6} = #7}}
\newcommand\ltiupdateClosureCachealign[7]{\ma{\ltiupdateClosureCacheLHS{#1}{#2}{#3}{#4}{#5}{#6} &=& #7}}
% Single
% ClosureCache ClosureID E => ClosureCache
\newcommand\ltiupdateClosureCacheSinglesymbol{\ma{\metafunctionfont{pick}}}
\newcommand\ltiupdateClosureCacheSingleLHS[3]{\ma{{\ltiupdateClosureCacheSinglesymbol}_{#1}(#2,#3)}}
\newcommand\ltiupdateClosureCacheSingle[4]{\ma{\ltiupdateClosureCacheSingleLHS{#1}{#2}{#3} = #4}}
\newcommand\ltiupdateClosureCacheSinglealign[4]{\ma{\ltiupdateClosureCacheSingleLHS{#1}{#2}{#3} &=& #4}}
% elabDriver
% E -> E ; T
\newcommand\ltielabDriverLHS[1]{\ma{\metafunctionfont{infer}(#1)}}
\newcommand\ltielabDriver[3]{\ma{\ltielabDriverLHS{#1} = \hastypesmall{#2}{#3}}}

\newcommand\lticsubtypesymbol{\ma{\leq}}
% subtype for external types 
\newcommand\lticsubtype[2]{\ma{#1 \lticsubtypesymbol #2}}
% subtype for external types, with fuel
\newcommand\lticfsubtype[4]{\ma{#1 \vdash #2 \lticsubtypesymbol #3 \dashv #4}}
% can't be used in a caption
\newcommand\ltiinvertedleq{\ma{\mathrel{\raisebox{.1em}{\reflectbox{\rotatebox[origin=c]{180}{$\leq$}}}}}}
% subtype for external types but inverted colors
\newcommand\lticsubtypeinv[2]{\ma{#1 \ltiinvertedleq #2}}
% subtype for external types but inverted colors with fuel
\newcommand\lticfsubtypeinv[4]{\ma{#1 \vdash #2 \ltiinvertedleq #3 \dashv #4}}
% expand EnclosingFn in internal language
% Stack T -> T
\newcommand\ltiexpandEnclosingFnLHS[2]{\ma{\metafunctionfont{res}(#1, #2)}}
\newcommand\ltiexpandEnclosingFn[3]{\ma{\ltiexpandEnclosingFnLHS{#1}{#2} = #3}}
\newcommand\ltiexpandEnclosingFnalign[3]{\ma{\ltiexpandEnclosingFnLHS{#1}{#2} &=& #3}}
\newcommand\ltiunfoldLHS[1]{\ma{\metafunctionfont{unfold}(#1)}}
\newcommand\ltiunfold[2]{\ma{\ltiunfoldLHS{#1} = #2}}
\newcommand\ltiunfoldalign[2]{\ma{\ltiunfoldLHS{#1} &=& #2}}
% Lang Env T => T
\newcommand\ltiresolveLHS[3]{\ma{\metafunctionfont{resolve}(#2,#3)}}
\newcommand\ltiresolve[4]{\ma{\ltiresolveLHS{#1}{#2}{#3} = #4}}
\newcommand\ltiresolvealign[4]{\ma{\ltiresolveLHS{#1}{#2}{#3} &=& #4}}
% CombinedEnv Env T => T ; CombinedEnv
\newcommand\ltiresolveSCLHS[3]{\ma{\metafunctionfont{resolveS}(#1,#2,#3)}}
\newcommand\ltiresolveSC[5]{\ma{\ltiresolveSCLHS{#1}{#2}{#3} = #4 ; #5}}
\newcommand\ltiresolveSCalign[5]{\ma{\ltiresolveSCLHS{#1}{#2}{#3} &=& #4 ; #5}}
% Lang StackMapping, Env => T
\newcommand\ltiunifyContextsLHS[3]{\ma{\metafunctionfont{unifyCtx}(#2,#3)}}
\newcommand\ltiunifyContexts[4]{\ma{\ltiunifyContextsLHS{#1}{#2}{#3} = #4}}
\newcommand\ltiunifyContextsalign[4]{\ma{\ltiunifyContextsLHS{#1}{#2}{&#3} &=& #4}}
% Lang AccumEnv StackMapping, CurrentEnv => T
\newcommand\ltiunifyContextsHsymbol{\ma{\metafunctionfont{uc}}}
\newcommand\ltiunifyContextsHLHS[4]{\ma{\ltiunifyContextsHsymbol(#2,#3,#4)}}
\newcommand\ltiunifyContextsH[5]{\ma{\ltiunifyContextsHLHS{#1}{#2}{#3}{#4} = #5}}
\newcommand\ltiunifyContextsHalign[5]{\ma{\ltiunifyContextsHLHS{#1}{#2}{#3}{&#4} &=& #5}}
% CombinedEnv StackMapping, Env => T ; CombinedEnv
\newcommand\ltiunifyContextsSCLHS[3]{\ma{\metafunctionfont{unifyCtxS}(#1,#2,#3)}}
\newcommand\ltiunifyContextsSCRHS[2]{\ma{#1 ; #2}}
\newcommand\ltiunifyContextsSC[4]{\ma{\ltiunifyContextsSCLHS{#1}{#2}{#3} = #4}}
\newcommand\ltiunifyContextsSCalign[4]{\ma{\ltiunifyContextsSCLHS{#1}{#2}{&#3} &=& #4}}
% CombinedEnv AccumEnv StackMapping, CurrentEnv => T ; CombinedEnv
\newcommand\ltiunifyContextsHSCLHS[4]{\ma{\metafunctionfont{ucSC}(#1,#2,#3,#4)}}
\newcommand\ltiunifyContextsHSCRHS[2]{\ma{#1 ; #2}}
\newcommand\ltiunifyContextsHSC[5]{\ma{\ltiunifyContextsHSCLHS{#1}{#2}{#3}{#4} = #5}}
\newcommand\ltiunifyContextsHSCalign[5]{\ma{\ltiunifyContextsHSCLHS{#1}{#2}{#3}{&#4} &=& #5}}
% ClosureCache e -> e
\newcommand\ltielimClossymbol{\ma{\metafunctionfont{elab}}}
\newcommand\ltielimClosLHS[2]{\ma{\ltielimClossymbol(#1, #2)}}
\newcommand\ltielimClos[3]{\ma{\ltielimClosLHS{#1}{#2} = #3}}
\newcommand\ltielimClosalign[3]{\ma{\ltielimClosLHS{#1}{#2} &=& #3}}
% ClosureID* ClosureCache t -> t
\newcommand\ltielimClosTsymbol{\ma{\metafunctionfont{elim}}}
\newcommand\ltielimClosTLHS[3]{\ma{\ltielimClosTsymbol(#1, #2, #3)}}
\newcommand\ltielimClosT[4]{\ma{\ltielimClosTLHS{#1}{#2}{#3} = #4}}
\newcommand\ltielimClosTalign[4]{\ma{\ltielimClosTLHS{#1}{#2}{#3} &=& #4}}
% ClosureCache Env -> Env
\newcommand\ltielimClosEnvLHS[2]{\ma{\metafunctionfont{elabEnv}(#1, #2)}}
\newcommand\ltielimClosEnv[3]{\ma{\ltielimClosEnvLHS{#1}{#2} = #3}}
\newcommand\ltielimClosEnvalign[3]{\ma{\ltielimClosEnvLHS{#1}{#2} &=& #3}}

\newcommand\ltiagreeexcepttvars[3]{\ma{#1 \triangleleft_{#2} #3}}
\newcommand\lticoincideinherited[2]{\ma{#1 \sim #2}}
\newcommand\ltigenconstraint[5]{\ma{#1 \vdash_{#2} #3 \mathbin{<:} #4 \Rightarrow #5}}
\newcommand\ltigendconstraint[6]{\ma{#1 \vdash_{#2} #3 \mathbin{<:} #4 \Rightarrow #5, #6}}
% CombinedEnv X DEntry C => C ; CombinedEnv
\newcommand\ltiprocessDelay[5]{\ma{\metafunctionfont{processDly}(#1,#2,#3) = #4;#5}}
% CombinedEnv X C => C ; CombinedEnv
\newcommand\ltiprocessDelays[4]{\ma{\metafunctionfont{processDlys}(#1,#2) = #3;#4}}
\newcommand\ltiCUnion[2]{\ma{#1 \cup #2}}
\newcommand\ltiCEmpty{\ma{\emptyset}}
\newcommand\ltiEnvLookup[2]{\ma{#1(#2)}}
\newcommand\ltipromote[3]{\ma{#1 \Uparrow^{#2} #3}}
\newcommand\ltidemote[3]{\ma{#1 \Downarrow^{#2} #3}}
\newcommand\ltitv[1]{\ma{\text{tv}(#1)}}
% TVar T
\newcommand\ltivariance[2]{\ma{\metafunctionfont{variance}(#1,#2)}}
% C -> DEntry*
\newcommand\ltiorderDelaysLHS[1]{\ma{\metafunctionfont{orderDelays}(#1)}}
\newcommand\ltiorderDelays[2]{\ma{\ltiorderDelaysLHS{#1} = #2}}
\newcommand\ltivariancefont[1]{\ma{\texttt{#1}}}
\newcommand\ltivcovariant{\ma{\ltivariancefont{covariant}}}
\newcommand\ltivconstant{\ma{\ltivariancefont{constant}}}
\newcommand\ltiCSet[1]{\ma{\{#1\}}}
\newcommand\ltiCDep[3]{\ma{\metafunctionfont{dep}_{#1}^{#2}(#3)}}
\newcommand\ltiCEntry[3]{\ma{#1 \mathbin{<:} #2 \mathbin{<:} #3}}
\newcommand\ltiDEntry[2]{\ma{#1 \mathbin{<:}_d #2}}
% V X Closure <: IFn
\newcommand\ltiDEntryVX[4]{\ma{#3 \mathbin{<:}^{#1}_{#2} #4}}
\newcommand\ltiCIntersect[2]{\ma{#1 \land #2}}
\newcommand\ltiaccessibletv[2]{\ma{\metafunctionfont{accessibletv}_{#1}(#2)}}
\newcommand\lticheckorder[6]{\ma{\metafunctionfont{checkorder}(#1, #2, #3, #4, #5, #6)}}

\newcommand\ltiSyn[1]{\ma{{\color{blue} \textsubscript{$\wedge$} #1}}}
\newcommand\ltiChk[1]{\ma{{\color{red} \textsuperscript{$\vee$} #1}}}
\newcommand\ltiSynChksymbol{\ma{\diamond}}
\newcommand\ltiSynChk[1]{\ma{{\color{black} \ltiSynChksymbol #1}}}

\newcommand\ltiFsub{\ma{F_{<:}}}

% SML listings
\newcommand\ltilstOption[1]{\ma{\text{Option[}#1{\text{]}}}}
\newcommand\ltiInferred[1]{{\color{blue} #1}}
\newcommand\ltiNotInferred[1]{{\color{black} #1}}

% internal language type/subtype rules
\newcommand\ltityperulefont[1]{\textsc{#1}}
\newcommand\ltiIVar{\ma{\ltityperulefont{I-Var}}}
\newcommand\ltiISel{\ma{\ltityperulefont{I-Sel}}}
\newcommand\ltiISelBot{\ma{\ltityperulefont{I-Sel\ltiBot}}}
\newcommand\ltiIAbs{\ma{\ltityperulefont{I-Abs}}}
\newcommand\ltiIAppInst{\ma{\ltityperulefont{I-App}}}
\newcommand\ltiIAppInstBot{\ma{\ltityperulefont{I-App\ltiBot}}}
\newcommand\ltiIRec{\ma{\ltityperulefont{I-Rec}}}
\newcommand\ltiSTVar{\ma{\ltityperulefont{S-TVar}}}
\newcommand\ltiSTop{\ma{\ltityperulefont{S-Top}}}
\newcommand\ltiSBot{\ma{\ltityperulefont{S-Bot}}}
\newcommand\ltiSRec{\ma{\ltityperulefont{S-Rec}}}
\newcommand\ltiSPoly{\ma{\ltityperulefont{S-Poly}}}
\newcommand\ltiSFn{\ma{\ltityperulefont{S-Fn}}}
\newcommand\ltiEAppInf{\ma{\ltityperulefont{E-UApp}}}
\newcommand\ltiEAppInfBot{\ma{\ltityperulefont{E-UApp\ltiBot}}}
\newcommand\ltiEUAbs{\ma{\ltityperulefont{E-UAbs}}}
\newcommand\ltiSCVar{\ma{\ltityperulefont{SC-Var}}}
\newcommand\ltiSCRec{\ma{\ltityperulefont{SC-Rec}}}
\newcommand\ltiSCSel{\ma{\ltityperulefont{SC-Sel}}}
\newcommand\ltiSCAbs{\ma{\ltityperulefont{SC-Abs}}}
\newcommand\ltiSCAppInst{\ma{\ltityperulefont{SC-App}}}
\newcommand\ltiSCAppInstBot{\ma{\ltityperulefont{SC-App\ltiBot}}}
\newcommand\ltiSCSelBot{\ma{\ltityperulefont{SC-Sel\ltiBot}}}
\newcommand\ltiSCAppInfPT{\ma{\ltityperulefont{SC-AppInfPT}}}
\newcommand\ltiSCAppInfBot{\ma{\ltityperulefont{SC-UApp\ltiBot}}}
\newcommand\ltiSCAppInfClosure{\ma{\ltityperulefont{SC-UAppClo}}}
\newcommand\ltiSimpAppInfClosure{\ma{\ltityperulefont{Simp-UAppClo}}}
\newcommand\ltiSCAppClosure{\ma{\ltityperulefont{SC-AppClo}}}
\newcommand\ltiSCUAbs{\ma{\ltityperulefont{SC-UAbs}}}
\newcommand\ltiSimpUAbs{\ma{\ltityperulefont{Simp-UAbs}}}
\newcommand\ltiSCSTVar{\ma{\ltityperulefont{SCS-TVar}}}
\newcommand\ltiSCSTop{\ma{\ltityperulefont{SCS-Top}}}
\newcommand\ltiSCSBot{\ma{\ltityperulefont{SCS-Bot}}}
\newcommand\ltiSCSRec{\ma{\ltityperulefont{SCS-Rec}}}
\newcommand\ltiSCSFn{\ma{\ltityperulefont{SCS-Fn}}}
\newcommand\ltiSCSClosure{\ma{\ltityperulefont{SCS-Clo}}}
\newcommand\ltiSimpSClosure{\ma{\ltityperulefont{SimpS-Clo}}}

% Mix regions
\newcommand\MixTregion[1]{\ma{{{\color{blue}{\{}_t}}\ #1 \ {\color{blue}{{}_t\}}}}}
\newcommand\MixSregion[1]{\ma{{{\color{red}{\{}_s}\ #1 \ {\color{red}{{}_s\}}}}}}
