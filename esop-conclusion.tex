\section{Conclusion}
\label{sec:conclusion}

Optional type systems must be designed with close attention to the
language that they are intended to work for.
We have therefore designed Typed Clojure, an optionally-typed version of
Clojure, with a type system that works with a wide variety of distinctive
Clojure idioms and features. Although based on the foundation of Typed
Racket's occurrence typing approach, Typed Clojure both extends the
fundamental control-flow based reasoning as well as applying it to
handle seemingly unrelated features such as multi-methods. In
addition, Typed Clojure supports crucial features such as
heterogeneous maps and Java interoperability while integrating these
features into the core type system. Not only are each of these
features important in isolation to Clojure and Typed Clojure
programmers, but they must fit together smoothly to ensure that
existing untyped programs are easy to convert to Typed Clojure.

The result is a sound, expressive, and useful type system which, as
implemented in \coretyped with appropriate extensions, is suitable for
typechecking a significant amount of existing Clojure programs.
%
As a result, Typed Clojure is already successful: it is used in
the Clojure community among both enthusiasts and professional
programmers.% and receives contributions from many developers.

Our empirical analysis of existing Typed Clojure programs bears out
our design choices. Multimethods, Java interoperation, and
heterogeneous maps are indeed common in both Clojure and Typed Clojure,
meaning that our type system must accommodate them. Furthermore, they
are commonly used together, and the features of each are mutually
reinforcing. Additionally, the choice to make Java's \clj{null}
explicit in the type system is validated by the many Typed Clojure
programs that  specify non-nullable types.

% Delete the following paragraphs if space is needed.

%However, there is much more that Typed Clojure can provide. Most
%significantly, Typed Clojure currently does not provide \emph{gradual
%  typing}---interaction between typed and untyped code is unchecked and
%thus unsound. We hope to explore the possibilities of using existing
%mechanisms for contracts and proxies in Java and
%Clojure to enable sound gradual typing for Clojure.
%
%Additionally, the Clojure compiler is unable to use Typed Clojure's
%wealth of static information to optimize programs. Addressing this
%requires not only  enabling sound gradual typing, but also
%integrating Typed Clojure into the Clojure tool so
%that its information can be communicated to the compiler. 

%Finally, our case study, evaluation, and broader experience indicate that Clojure
%programmers still find themselves unable to use Typed Clojure on some
%of their programs for lack of expressiveness. This requires continued
%effort to analyze and understand the features and idioms and
%develop new type checking approaches.
