\chapter{Background}

As is inevitable for an optional type system, there are many
Clojure programs that Typed Clojure was not designed to type check.
These programs contain Clojure idioms that are often either intentionally
not supported with Typed Clojure's initial design, or 
were introduced to Clojure at a later date.
Regardless, programmers will inevitably want to use these features 
in their Typed Clojure programs---but crucially without breaking
support for existing idioms.
In this part, we explore what kinds of idioms are missing
support in Typed Clojure, and propose solutions in the form of
backwards-compatible extensions.

As we discussed in \partref{part:types}, Typed Clojure's initial
design is strongly influenced by Typed Racket. In particular,
Typed Clojure's static semantics of
combinining local type inference and occurrence typing
to check fully-expanded code
comes directly from Typed Racket.
This shared base is appropriate, given the similarities between
the base Clojure and Racket languages.
It is also effective, seamlessly handling many control flow
idioms, capturing many polymorphic idioms, and often yielding
predictable type error messages.
However, there are important tradeoffs to consider in this design.

Concerning the limitations of local type inference,
Hosoya and Pierce~\cite{hosoya1999good}
isolate two drawbacks:
dealing with arguments that are ``hard-to-synthesize'',
and cases where there is no ``best'' type argument to infer.
They report unsatisfactory results in their attempts to
fix these issues, in both the effectiveness and complexity
in their solutions.
They speculate that these difficulties might be better 
addressed at the language-design level,
so that the local annotations necessary to mitigate these issues
(by keeping the bidirectional propagator in ``checking'' mode)
are more idiomatic.
We don't have the luxury nor desire to change Clojure,
and so we attempt to solve the same challenges, but
with a different approach.

%\begin{cljlisting}
%(for [i (range 100)]
%  (map (fn [j] (inc j))
%       (range i)))
%\end{cljlisting}

Hosoya and Pierce outline the two main challenges that must be
addressed to avoid hard-to-synthesize arguments.
First, we must provide a strategy for identifying which arguments 
should be avoided.
They provide a simple grammar for identifying hard-to-synthesize arguments,
which they note as ad-hoc but seeming reasonable in practice, in particular
for user comprehensibility.
Second, an alternative (probably more complicated) algorithm
for inferring type arguments is needed that both handles
avoided arguments and determines ``best'' type arguments.
Instead of proposing a particular approach, they demonstrate why the naive approach does not suffice.
We use these challenges as a presentational framework to present our own approach.

In our experience, the most common hard-to-synthesize expression in Clojure code
is the function.
Clojure's large standard library of higher-order functions and encouragement
of functional programming lead to many usages of anonymous functions, which almost
always require annotations to check with Typed Clojure.
So, to answer Hosoya and Pierce's first challenge, 
we avoid checking hard-to-synthesize function expressions by
introducing a new function type: a \emph{symbolic closure type}.
A symbolic closure does not immediately check the function body. Instead,
the function's code along with its local type context is saved
until enough information is available to check
the function body in bidirectional ``checking'' mode.
We present more details about symbolic closures in \chapref{chapter:symbolic:symbolic-closures}.

% TODO introduce directed lti here

% - "Avoiding hard-to-synthesize arguments"
%   1. need mechanism to decide which arguments to avoid
%   2. more complicated scheme for determining best type arguments

% - Problem
%   - many common idioms cannot be checked
%   - limitations of local type inference
%   - made harder by occurrence typing
%   - want general solutions available to all users
%   - preliminary investigation of several techniques
% - Possible solutions
%   - symbolic analysis
%     - symbolic closures
%       - deal with "obvious" local function annotations
%     - inlining
%   - directed local type inference
%     - derive data flow from polymorphic types for more aggressive local type variable inference
%   - custom typing rules
%     - interface for describing how to check an unexpanded macro call
%       - or complex functions
%     - custom errors
% - Constraints
%   - some speculation of how well they compose together
%   - small models without rigorous proofs
%   - case studies with real Clojure idioms

\chapter{Symbolic Closure Types}
\label{chapter:symbolic:symbolic-closures}

% - Solution
%   - "obvious" function annotations
%     - can be derived from usage context
%   - introduce "symbolic" closure types
%     - a function's type is its code + typed local scope
%   - don't need to check a function that isn't called
% - Constraints
%   - wildcard "?" type
%     - needed to provide argument types while inferring body
%     - from Colored LTI
%   - Infinite loops
%     - subtyping
%     - type generalization
%     - term reduction limits
%   - user-level story
%     - symbolic closures enabled by flag
%     - users cannot write a symbolic closure
%     - that way, global annotations cannot contain a symbolic closure
%       - helps with polymorphism story
%         - constraint solving
%           - hypothesis/goal: only one side of contraint solving can have a symbolic closure
%             - one side is from global annotation, other side from local inference
%   - reporting errors
%     - suggesting types
%     - avoid showing inlining to users
%   - 0-n checks to same function
%     - avoid double expansion
%       - many copies of symbolic closures are made, could be expanded at different times
%         - how to synchronize?
%     - skipping unreachable functions
%       - potential for latent bugs, if type checker turned off in future and fn is made reachable
%     - performance
%   - consistent evaluation results
%     - how to ensure correct inlining?
%     - relationship between inlined and evaluated code?
%       - do we want to "undo" the inlining when finally evaluating?
%   - when to use a closure type?
%     - partial annotations
%   - polymorphism
%     - postpone discussion to next chapter
%   - applying symbolic analysis to infer loop/recur annotations
%     - similar issues
%     - different type generalization story?
%   - comparison to let-polymorphism
%     - expressiveness
%     - performance
%   - help check macros?
%     - not directly applicable, since too much context would be lost
%       - would help check *more* of an expansion, but error messages
%         are still unrelated to original code
%   - is this a sound strategy?
%     - faithfully simulates beta reduction
%     - termination story?
%   - case studies
%     - criteria:
%       - good errors?
%       - predictable behavior?
%       - performance?
%     - simple eta expansions
%       - (+ 1 2)
%       - ((fn [x y] (+ x y)) 1 2)
%     - let-bound functions
%       - (+ 1 2)
%       - (let [plus (fn [x y] (+ x y))]
%           (plus 1 2))
%     - y-combinator
%       - stress test
%     - let-polymorphism worst case (exponential) comparison
%       - stress test
%     - completely inlined transducers
%       - case study: inlining map + comp
%         - why: non recursive polymorphic functions
%           - common idiom
%         - how to report errors?
%   - polymorphic function-intersection types
%     - how to handle, do we need backtracking?
%     - do we need to recheck arguments? 

\chapter{Directed Local Type Inference}

% - Solution
%   - extend colored LTI with directed inference
%   - introduce constrained types
%   - derive data flow from (variances of) polymorphic variable occurrences 
%   - simple example
%     - (identity 1)
%     - demonstrate how this is checked with colored LTI
%     - compare to directed LTI:
%       - 2/----v
%         [x -> x]  Int
%          ^--------/1
%
%         1. Int flows to contravariant position
%         2. contravariant position flows to covariant position (because it's on the other side of ->)
%       - no loop, because variables not under different numbers of function types
%         - (we don't know the precise rule yet)
%   - complex example
% - Constraints
%   - advantages over colored LTI
%     - aids symbolic analysis
%       - because we derive potential dataflows, we don't need to over-approximate,
%         and thus trigger unneeded symbolic analysis
%         - which might then fail because of not enough contextual information
%   - disadvantages over colored LTI
%     - significant deviation from LTI
%       - constrained types
%       - aggressive local inference based on data flows
%     - not obvious how to prove soundness
%   - infinite loops
%     - how to manage cycles in inferred data flow 
%   - constraint solving
%     - constrained types
%       - literature (see symb.tex)
%   - flow diagrams
%     - see symb.tex
%   - relationship to colored LTI model
%     - see symb.tex
%   - related work
%     - ML_sub
%     - see: symb.tex

\chapter{Custom Typing rules}

% - Solution
%   - allow users to provide custom typing rules
%   - 
% - Constraints
%   - wildcard type from colored LTI useful
%   - custom error messages
%     - propagation via expected types
%       - outer-most wins
%   - using clojure.spec to conform/unform
%     - to rip apart and put syntax back together
%     - more robust than manual parsing
%   - differences with Turnstile
%     - in Turnstile, the macro *is* the rule
%       - here, we separate the two
%       - we preserve the macro call until evaluation
%       - use the typing rule to expand "under" the macro as many times as we want
%         - can do this 0-n times, thus compatible with directed LTI & symbolic analysis
