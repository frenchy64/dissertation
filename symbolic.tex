\chapter{Background}

As is inevitable for an optional type system, there are many
Clojure programs that Typed Clojure was not designed to type check.
These programs contain Clojure idioms that are often either intentionally
not supported by Typed Clojure's initial design, or 
were introduced to Clojure at a later date.
Regardless, programmers will inevitably want to use these features 
in their Typed Clojure programs---but crucially without breaking
support for existing idioms.
In this part, we explore what kinds of idioms are missing
support in Typed Clojure, and propose solutions in the form of
backwards-compatible extensions.

As we discussed in \partref{part:types}, Typed Clojure's initial
design is strongly influenced by Typed Racket. In particular,
Typed Clojure's static semantics of
combinining local type inference and occurrence typing
to check fully-expanded code
comes directly from Typed Racket.
This shared base is appropriate, given the similarities between
the base Clojure and Racket languages.
It is also effective, seamlessly handling many control flow
idioms, capturing many polymorphic idioms, and often yielding
predictable type error messages.
However, there are important tradeoffs to consider in this design---in the following
sections we introduce them and propose extensions to attempt to nullify
their downsides.

\section{Enhancing Local Type Inference}

``Local Type Inference''~\cite{PierceLTI} refers to the combination of
bidirectional type propagation 
specific approach
to partial type inference for languages with subtyping and impredicative
polymorphism.
``Partial type inference'' here is
problem of inferring 
(Pfenning~\cite{Pfenning1988partial} describes the distinction more thoroughly).

Concerning the limitations of local type inference,
Hosoya and Pierce~\cite{hosoya1999good}
isolate two drawbacks.
The first is dealing with ``hard-to-synthesize arguments''.
To understand this, we must appreciate a key ingredient of local type inference
called \emph{bidirectional propagation}, which 
we use the example of type checking \clj{(inc 42)} to demonstrate.
If we have already checked \clj{inc} to have type \clj{[Int -> Int]}, we
now have a choice of how to check the argument \clj{42} is an \clj{Int}.
The first is to ascribe an expected type to \clj{42} of \clj{Int}
and rely on
bidirectional \emph{checking mode} to ensure \clj{42} has the correct type
once we check it.
The second is to infer the type of \clj{42} (without an expected type) using 
bidirectional \emph{synthesis mode}, and then ensure the inferred type
is compatible with \clj{Int} after the fact.
A useful analogy in terms of expressions is that checking mode propagates
information outside-in, and synthesis mode propagates inside-out.
A similar analogy in terms of a type derivation tree (that grows upwards)
relates checking and synthesis modes to information being passed
up and down the tree, respectively.

To best serve the purposes of local type inference, it is crucial to stay in
bidirectional \emph{checking} mode as much as possible.
The ``hard-to-synthesize arguments'' problem occurs when type argument
inference interferes with the ability to stay in checking mode, and
thus forces the bidirectional propagator into synthesis mode
for arguments that require checking mode.
For example, to type check

\clj{(map (fn [x] (inc x)) [1 2 3])},

where \clj{map} has type

\clj{(All [a b] [[a -> b] (Seqable a) -> (Seqable b)])},

we use type argument inference to determine how to instantiate type variables \clj{a}
and \clj{b} based on \clj{map}'s arguments.
Unfortunately, 
to answer this question,
the naive local type inference algorithm~\cite{PierceLTI}
uses synthesis mode to retrieve the argument types,
and so checks \clj{(fn [x] (inc x))} in synthesis mode.
No information is propagated about the type of \clj{x},
so this expression will fail to type check, demonstrating
why functions are hard-to-synthesize.

The second drawback noted by Hosoya and Pierce are
cases where there is no ``best'' type argument to infer.
This occurs when there is not enough information available
to determine how to instantiate a type such that the program
has the best chance of type checking, and so it must be guessed.
A representative case where this occurs is inferring the
type of a reference from just its instantiation, such
that optimal types are given to reads and writes.
For example, the following code creates a Clojure Atom
(a reference type) with initial value \clj{nil}, writes
\clj{0} to the Atom, and then increments the Atom's value.

{
\begin{cljlisting}
(let [r (atom nil)]
  (reset! r 0)
  (inc @r))
\end{cljlisting}
}

What type should \clj{r} be assigned? From its initial binding,
\clj{(Atom nil)} seems appropriate, but the subsequent write
would fail. Alternatively, assigning \clj{(Atom Any)} would
allow the write to succeed, but the the final read would fail
because it expects \clj{Int}.
This demonstrates difficulties of the ``no-best-type-argument'' problem.

Hosoya and Pierce report unsatisfactory results in their attempts to
fix these issues, in both the effectiveness and complexity
in their solutions.
They speculate that these difficulties might be better 
addressed at the language-design level---rather than algorithmically---in ways that
keep the bidirectional propagator in checking mode.
For the ``no-best-type-argument'' problem,
we agree with this assessment, since
addressing the problem mostly amounts to annotating 
all reference constructors.
To this end,
Typed Clojure offers several
wrappers for common functions where this problem
is common---the previous example might use the ``typed''
constructor
\clj{(t/atom :- (U nil Int), nil)}.
However, the ``hard-to-synthesize arguments'' problem
is a deeper and more pervasive issue when checking Clojure code.
We don't have the luxury, desire, nor do we think it would be particularly
successful to introduce new core idioms to Clojure,
and so we attempt to solve the this problem algorithmically.

%\begin{cljlisting}
%(for [i (range 100)]
%  (map (fn [j] (inc j))
%       (range i)))
%\end{cljlisting}

Hosoya and Pierce outline the two main challenges that must be
addressed to solve the ``hard-to-synthesize arguments'' problem.
First, we must provide a strategy for identifying which arguments 
should be avoided.
For instance,
they provide a simple grammar for identifying hard-to-synthesize arguments,
which includes (for Standard ML) unannotated functions and unqualified constructors.
Second, an alternative (probably more complicated) algorithm
for inferring type arguments is needed that also handles
avoided arguments.
Their experiments show that the naive approach does not suffice,
and hint at the delicate handling needed to effectively maximize or minimize
instantiated types to stay in checking mode.
We will now use these challenges as a presentational framework to outline our own approach.

In our experience, the most common hard-to-synthesize expression in Clojure code
is the function.
Clojure's large standard library of higher-order functions and encouragement
of functional programming result in many usages of anonymous functions, which almost
always require annotations to check with Typed Clojure.
So, to answer Hosoya and Pierce's first challenge, 
we avoid checking hard-to-synthesize function expressions by
introducing a new function type: a \emph{symbolic closure type}.
A symbolic closure does not immediately check the function body. Instead,
the function's code along with its local type context is saved
until enough information is available to check
the function body in checking mode.
We present more details about symbolic closures in \chapref{chapter:symbolic:symbolic-closures}.

Now that we have delayed the checking of hard-to-check arguments,
Hosoya and Pierce's second challenge calls for an enhanced
type argument reconstruction algorithm to soundly handle
them.
Our investigation led us to create \emph{directed local type inference}
(\chapref{chapter:symbolic:directed-lti}),
which determines the possible data flows through a polymorphic function
by noting the positions of type variable occurrences, and attempts to
use this information to check its arguments in an optimal order for remaining
in bidirectional checking mode.

%\section{Custom typing rules}
%
%Besides local type inference,
%another significant feature inherited from Typed Racket is that
%code is fully expanded before checking.
%This unfortunately means that macros with complex expansions
%are often uncheckable, and display cryptic error messages when attempting
%to do so.
%We investigate providing the user with \emph{custom typing rules} (\chapref{chapter:symbolic:custom-rules})
%as an extension point to customize how to type check a macro before
%it is expanded.
%As discussed in 
%\partref{part:implementations}, Typed Clojure's initial design does
%not support custom typing rules, so we exploit the infrastructure
%discussed there,
%and present our investigation into the user interface for the rules in
%\chapref{chapter:symbolic:custom-rules}.

% - "Avoiding hard-to-synthesize arguments"
%   1. need mechanism to decide which arguments to avoid
%   2. more complicated scheme for determining best type arguments

% - Problem
%   - many common idioms cannot be checked
%   - limitations of local type inference
%   - made harder by occurrence typing
%   - want general solutions available to all users
%   - preliminary investigation of several techniques
% - Possible solutions
%   - symbolic analysis
%     - symbolic closures
%       - deal with "obvious" local function annotations
%     - inlining
%   - directed local type inference
%     - derive data flow from polymorphic types for more aggressive local type variable inference
%   - custom typing rules
%     - interface for describing how to check an unexpanded macro call
%       - or complex functions
%     - custom errors
% - Constraints
%   - some speculation of how well they compose together
%   - small models without rigorous proofs
%   - case studies with real Clojure idioms

\chapter{Delayed checking for Unannotated Local Functions}
\label{chapter:symbolic:symbolic-closures}

Using bidirectional type checking, functions are hard-to-synthesize types for.
Put another way, to check a function body successfully using only locally available information,
types for its parameters are needed upfront.
For top-level function definitions, this is not a problem in many
optional type systems since top-level annotations would be provided
for each function.
However, for anonymous functions it's a different story.
The original local type inference algorithm~\cite{PierceLTI}
lacks a synthesis rule for unannotated functions, instead relying on bidirectional
propagation of types,
but due to the prevalence
of hard-to-synthesize anonymous functions in languages like JavaScript, Racket, and Clojure,
optional type systems for the languages add their own rules.

Typed Racket and Typed Clojure implement a simple but sound strategy
to check unannotated functions. The body of the function is checked
in a type context where its parameters are of type \clj{Any},
the \texttt{Top} type.
This helps check functions that don't use their arguments, or only
use them in positions that require type \clj{Any}.
For example, both \clj{(fn [x] "a")} and \clj{(fn [x] (str "x: " x))} 
synthesize to \clj{[Any -> String]} in Typed Clojure.
The downsides to this strategy are that unannotated functions are never
inferred as polymorphic, and functions that use their arguments
at types more specific than \clj{Any} are common.

TypeScript~\cite{typescript}, an optional type system for JavaScript,
takes a similar approach, but instead of annotating parameters with
TypeScript's least permissive type called \js{unknown},
by default it assigns parameters the unsound dynamic type \js{any}.
In TypeScript, \js{any} can be implicitly cast to any other type,
so the type checker will (unsoundly) allow any usage of unannotated arguments.
If this behavior is unsatisfactory,
the \js{noImplicitAny} flag removes special handling for unannotated
functions altogether, and TypeScript will demand explicit annotations for all arguments.

In this chapter, we present an alternative approach to checking unannotated functions
based on the insight that a function's body need only be type checked if and when it is called.
For example, the program \clj{(fn [x] (inc x))} cannot throw a runtime error because
the function is never called, and so a type system may soundly treat the function body as unreachable code.
On the other hand, wrapping the same program in the invocation
\clj{((fn [x] (inc x)) nil)}
makes the runtime error possible, and so a sound static type system must flag the error.

Exploiting this insight in the context of a bidirectional type checker using
local type inference requires many considerations.
First, we must decide in which situations is it desirable to delay checking a function.
Second, we must identify the information that must be saved in order to delay checking a function,
and then choose a suitable format for packaging that information.
Third, we must identify how a function is deemed ``reachable'',
and then which component of the type system is responsible for checking a function body.
Fourth, it is desirable to identify and handle the ways in which 
infinite loops are possible, such as the checking of a delayed function triggering
another delayed function to check, which triggers another delayed check, ad nauseam.
Fifth, we must determine how delayed functions interact with polymorphic types
during type argument reconstruction.

We address all these considerations in the following sections, except
for the final one, which we delegate to \chapref{chapter:symbolic:directed-lti}.

\section{Overview}
\label{symbolic:section:overview}

In this section, we explore some of the implications that come with delayed checks for local functions,
by example.
We avoid any use of polymorphic functions
(we isolate those issues in \chapref{chapter:symbolic:directed-lti})
and demonstrate the tradeoffs with just non-recursive monomorphic functions.

First, let \clj{inc} be of type \clj{[Int -> Int]}.
The following, then, is well typed because \clj{1} is an \clj{Int}.

\begin{cljlisting}
(inc 1)
\end{cljlisting}

Using the standard bidirectional application type rule, \clj{inc} is checked first,
followed by \clj{1}.
However, eta-expanding the operator does not behave as nicely.

\begin{cljlisting}
((fn [x] (inc x)) 1)
\end{cljlisting}

Like usual, the standard application rule checks the function first.
However, there is no annotation for \clj{x}, so the function body will fail
to check.
This is unfortunate, especially in a type system that claims to be ``bidirectional'',
since the information that \clj{x} is an \clj{Int} is adjacent to the function
in the form of an argument.
One strategy to alleviate this problem is to always check arguments first~\cite{xie2018let}.
However, that nullifies the ability for the operator to propagate information
to its arguments, whose advantages are exploited to good effect in Colored Local Type Inference~\cite{coloredlti01}

We combine both flavors by keeping the standard operator-first checking order
but delay the checking of unannotated functions.
Then, an additional application rule handles applications of
unannotated functions to force their checking.
So in this case, the checking of \clj{(inc x)}
is delayed until the argument \clj{1} is inferred as \clj{Int},
after which this information is used to check \clj{(inc x)}
in the extended type context where \clj{x : Int}.

We could imagine hard-coding a type rule that manually delays
direct applications of unannotated functions until after checking
its arguments.
However, that does not generalize to more complicated examples.
Take the following illustrative code, identical the previous
example, except the function is let-bound as \clj{f}.

{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (fn [x] (inc x))](*@\label{symbolic:example:let-bound:def-f}@*)
  (f 1))(*@\label{symbolic:example:let-bound:app-f}@*)
\end{cljlisting}
}

Instead of following the brittle strategy of creating yet-another special rule to delay checking
let-bound functions, we generalize the idea.
We make a delayed function check a first-class concept in our type-system by
creating a new type for it.
Roughly, \clj{f} would have a delayed function type---introduced by
a type rule for unannotated functions---and \clj{(f 1)}
would force a check for the delayed function---by an application
rule that handles delayed function \emph{types} (not syntax-driven).

Now we must decide what a delayed function type consists of.
Clearly, the \emph{code} of the function must be preserved until
it is checked, otherwise the application rule would have nothing
to work with.
We note that our static semantics of saving
the code of a function to check later
is analogous to the runtime strategy of
evaluating a function as \emph{closure},
and using beta-reduction to extract the original
function from the closure and apply it to its arguments.

The trick in maintaining lexical scope during beta-reduction for closures
is to apply the function under the \emph{function definition's}
environment, instead of the application site's.
For example,
\figref{symbolic:example:closure-red}
evaluates
to \clj{2}
because
the occurrence of
\clj{y} on line \ref{symbolic:example:closure-red:y-usage}
is bound to \clj{1} by line \ref{symbolic:example:closure-red:y-def-site}.
If we used the local environment at the application site (line \ref{symbolic:example:closure-red:f-app}),
\clj{y} would be bound on line \ref{symbolic:example:closure-red:y-app-site}
to \clj{nil},
and would throw a runtime error.

% must save type context
\begin{figure}
{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (let [y 1](*@\label{symbolic:example:closure-red:y-def-site}@*)
          (fn [x] (+ x y)))](*@\label{symbolic:example:closure-red:y-usage}@*)
  (let [y nil](*@\label{symbolic:example:closure-red:y-app-site}@*)
    (f 1)))(*@\label{symbolic:example:closure-red:f-app}@*)
\end{cljlisting}
}
  \caption{This example evaluates to \clj{2} with lexically scoped variables.}
  \label{symbolic:example:closure-red}
\end{figure}

The crucial insight is that
the same trick applies to \emph{checking} delayed function types,
except at the \emph{type}-level.
Specifically, the occurrence of \clj{y}
on line \ref{symbolic:example:closure-red:y-usage}
must be checked as type \clj{Int} (from line \ref{symbolic:example:closure-red:y-def-site}),
and not type \clj{nil} (from line \ref{symbolic:example:closure-red:y-app-site}).
So, a delayed function type pairs a function's code with the type environment
at the function definition site.
This strongly resembles a ``type-level'' closure that is reduced symbolically,
and so we call this new type a \emph{symbolic closure}.

We can use symbolic closures to inline higher-order-function definitions.
In the following example, \clj{app} would normally need a higher-order
or polymorphic
annotation to handle the application on the final line.
Instead, with symbolic closures, type checking reduces in a few steps to simply checking
\clj{(inc x)} where \clj{x : Int}.

% more beta reduction
\begin{cljlisting}
(let [f (fn [x] (inc x))
      app (fn [g y] (g y))]
  (app f 1))
\end{cljlisting}

As alluded to in the previous section, we must identify
all type system components who are responsible for checking symbolic closures,
and ensure they perform their obligations correctly.
The following example uses a higher-order function
\clj{app-int} to increment the value \clj{1}.
Since \clj{app-int} is annotated, it will be checked
by the standard application rule.
However, its first argument will be delayed as a symbolic
closure---now we must identify who is responsible for checking it.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-int [[Int -> Int] Int -> Int])
(defn app-int [f x] (f x))
...
(app-int (fn [x] (inc x)) 1)
\end{cljlisting}

The type signature of \clj{app-int},
clearly says that its first argument may be called with an \clj{Int}.
Therefore, to maintain soundness, applications of \clj{app-int}
must ensure its first argument accepts \clj{Int}.
The standard application type rule uses subtyping to ensure
provided arguments are compatible with the formal parameter types of
the operator.
To handle symbolic closures, we preserve the standard application rule
and instead add a subtyping case for symbolic closures.

In this case, the subtyping relation would be asked to verify if
``the symbolic closure type representing \clj{(fn [x] (inc x))}
is a subtype of \clj{[Int -> Int]}''.
This can be answered by checking the symbolic closure
returns \clj{Int} when 
\clj{x} is type \clj{Int}---and so this subtyping case
delegates to checking if the symbolic closures inhabits the given type.
The subtype relationship is true if the check succeeds without type error,
otherwise it is false.

The correct ``contravariant subtyping left-of-the-arrow''
is naturally preserved.
In this case, the left-of-the-arrow check is ``\clj{Int} is a subtype of \clj{x}'s type'', and
annotating \clj{x} as \clj{Int} turns this statement into the reflexively true ``\clj{Int} is a subtype of \clj{Int}''.
At a glance, it may seem that we are wasting the benefits
of this contravariant rule---after all, it enables \clj{x} to be \emph{any} supertype of
\clj{Int}, such as \clj{Num} or even \clj{Any}.
However, it is in our interest to propagate the most precise parameter types
so then function bodies have the best chance to check without error.
Since symbolic closures are designed to support rechecking their bodies at different argument types,
a symbolic function can simply be rechecked with the less-precise types
when it comes time to broaden its domain.

This scheme extends to subtyping with arbitrarily-nested function types.
To demonstrate nesting to the right of an arrow,
the following code sums 1 with itself via
\clj{curried-app-int}, which accepts a curried
function of two arguments \clj{f} and a number \clj{x}, and 
provides \clj{x} as both arguments to \clj{f}.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann curried-app-int [[Int -> [Int -> Int]] Int -> Int])
(defn curried-app-int [f x] ((f x) x))
...
(curried-app-int (fn [y] (fn [x] (+ x y))) 1)
\end{cljlisting}

The standard application rule will ensure 
``the symbolic closure of \clj{(fn [y] (fn [x] (+ x y)))}
is a subtype of
\clj{[Int -> [Int -> Int]]}'', which involves assuming
\clj{y : Int} and then checking the \emph{code} \clj{(fn [x] (+ x y))}
at type \clj{[Int -> Int]}---which just uses the standard
function rule.

To demonstrate nesting to the left of an arrow,
\clj{app-inc} again computes \clj{(inc 1)}
in an even more convoluted way with \clj{app-inc}---by accepting a function
\clj{f} that it passes both \clj{inc} and its second argument to.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-inc [[[Int -> Int] Int -> Int] Int -> Int])
(defn app-inc [f x] (f inc x))
...
(app-inc (fn [g y] (g y)) 1)
\end{cljlisting}

Importantly, \clj{app-inc}'s first argument has a function
type to the left on an arrow, in particular \clj{[Int -> Int]}.
Under these conditions, subtyping asserts that ``the symbolic
closure \clj{(fn [g y] (g y))} is a subtype of \clj{[[Int -> Int] Int -> Int]}''
by assuming \clj{g : [Int -> Int]} and \clj{y : Int} and
verifying that \clj{(g y)} checks as \clj{Int}---which is almost immediate by
the standard application rule.

We leverage some syntactic restrictions
to avoid the need for further subtyping cases for symbolic closures.
First, symbolic closures cannot be annotated by the programmer,
and can only be introduced by the ``unannotated function'' typing rule.
Second (as discussed in \secref{analyzer:extensibility:side-effects}),
top-level variables are not allowed to inherit the types of their initial
values, and must be explicitly annotated.
These restrictions ensure symbolic closures both cannot occur to the
left of an arrow type, and 
cannot propagate beyond the top-level form it was defined in.
%This stretches the metaphor of ``local'' type inference
%beyond just a single tree walk using
%bidirectional propagation,

\subsection{Performance and error messages}

% FIXME need to be more precise about "undecidable". What problem are
% we deciding? See Wells '94 for some details. I think so far I
% mean "type checking always terminates (conservatively)"

While useful, allowing the type system to perform beta-reduction
requires careful planning: type checking time is now proportional 
to the running time of the program!
Unsurprisingly, this makes type checking with a naive implementation of symbolic
closures undecidable.
Without intervention,
the next program (an infinite loop using the y-combinator that computes \clj{(inc (inc (inc ...)))})
would send the \emph{type system} into an infinite loop.

%TODO much simpler example: ((fn [x] (x x)) (fn [x] (x x)))

% infinite loops
\begin{cljlisting}
(let [Y (fn [f]
          ((fn [g] (fn [x] (f (g g) x)))
           (fn [g] (fn [x] (f (g g) x)))))]
  (let [compute (Y (fn [f x] (inc (f x))))]
    (compute 1)))
\end{cljlisting}

To prevent such loops, we limit the number of symbolic reductions
done at type-checking time.
As a conservative solution to the halting
problem, this limit will prematurely halt some programs that would
otherwise fully reduce in a finite number of steps.
For example, if we set the reduction limit to 5\ in
the following code,
during the 6th reduction of \clj{f} the type system will
throw an error.

% premature halting
\begin{cljlisting}
(let [f (fn [x] x)]
  (f (f (f (f (f (f 1)))))))
\end{cljlisting}

In simple cases like these, the error message 
can guide the user to fixing the error.
For example, the type system would suggest 
annotating \clj{f} as \clj{[Int -> Int]} (by collecting
argument and return types as the program is reduced),
which would cause the program to check successfully
under the same conditions.
For cases with more heterogeneous argument and return types---like the y-combinator---the 
error message would just note which function caused
the reduction quota to be depleted.

As Wells~\cite{wells1994typability} remarks,
stopgap measures such as this to circumvent undecidable
type inference algorithms negatively affect
program portability.
For example, a different reduction limit may cause
a program to fail to type check that otherwise type checked
in a previous version.
We hope to learn reasonable defaults for the reduction limit
by experience.

%Note that using the type checker to decide subtyping
%has unfortunate implications for 
%the aforementioned annotation suggestions
%for reduction-limit error messages.
%An ``obviously-failing'' subtyping check might trigger a
%check for irrelevant arguments, and then provide them to the user.
%A curious aside: if symbolic closures are identified just by their code and definition
%type environments, suggestions may also be merged for functions with
%identical code and scope.

% TODO performance
% - undecidable 
%   - heuristics needed to halt search
%   - type checking time proportional to running time of program
% - for finitely running programs:
%   - degenerate case checking time complexity becomes at least exponential time in the size of the program because we can recheck a function
%     body multiple times, and a symbolic closure can be duplicated
%
% eg. (let [pair (fn [f g] (f (g) (g)))] (pair (fn [x y] (+ x y)) (fn [] 1)))
% - (fn [] 1) is checked twice
%   - can "stack" these recheckings, worst case is infinite
% - Damas-Milner algorithm checks a function definition once to determine its principle type scheme
%   - exponential time & space
%     - because principle type schemes can become very large
%     - also exponential time to print a type
%     - symbolic closures are also exponential time to print a type (naively)
%       since they can be duplicated
%       - I think these are similar reasons to Milner's algorithm

% do we need a story for runtime casting from Any to [Int -> Int]?
%\begin{cljlisting}
%(ann dynapp-int [Any Int -> Int])
%...
%(dynapp-int (fn [x] (inc x)) 1)
%\end{cljlisting}

% no idea what to do with negation function types 
%\begin{cljlisting}
%(ann app-int [(U [Int -> Int] (I Any (Not [Int -> Int]))) Int -> Int])
%...
%(app-int (fn [x] (inc x)) 1)
%\end{cljlisting}


\section{Formal model}

We formalize a restriction of symbolic closure types by defining an explicitly typed internal language,
providing an external languages that can omit annotations,
and formulating a type inference algorithm based on symbolic closures to recover omitted annotations.
This approach is similar to Local Type Inference~\cite{PierceLTI}
and Colored Local Type Inference~\cite{coloredlti01},
except where they utilize bidirectional type propagation to locally determine function parameter types,
we instead use symbolic closures to propagate type information
(since we have a synthesis rule for functions).

\subsection{Internal Language}

\begin{figure}[h]
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifuntparamargtype{\ova{\ltitvar{}}}
                                             {\ltivar{}}
                                             {\ltiT{}}
                                             {\ltiE{}}
                         \alt
                         \ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ova{\ltivar{} = \ltiE{}}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltitvar{} 
                         \alt
                         \ltiTop
                         \alt
                         \ltiBot
                         \alt \ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiT{}}
                         \alt
                         \ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}
                      &\mbox{Types} \\
  \ltiEnv{} &::=& \ltiEmptyEnv \alt
                  \ltiEnvConcat{\ltiEnv{}}{\hastype{\ltivar{}}{\ltiT{}}} \alt
                  \ltiEnvConcat{\ltiEnv{}}{\ltitvar{}}
                      &\mbox{Type Environments} \\
\end{array}
$$
\caption{Internal Language Syntax}
\label{symbolic:figure:internal-language}
\end{figure}

Our internal language is based on System \ltiFsub extended with records, and is functionally identical
to that used to model Colored Local Type Inference~\cite{coloredlti01}, except
our lambda terms require full (return) type annotations.
\figref{symbolic:figure:internal-language} shows the syntax
for the internal language.
Terms \ltiE{} and \ltiF{} range over 
variables \ltivar{},
explicitly typed polymorphic functions
                         \ltifuntparaminterface{\ova{\ltitvar{}}}
                                               {\ltiFn{\ltiT{}}{\ltiS{}}}
                                               {\ltivar{}}
                                               {\ltiE{}},
(where the entire function is of type \ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}}, its \emph{interface}),
function application
with explicit type arguments
\ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}},
record selectors
\ltisel{\ltiE{}}{\ltivar{}},
and record constructors
\ltiRec{\ova{\ltivar{} = \ltiE{}}}.
Types \ltiT{}, \ltiS{}, and \ltiR{} are 
type variables \ltitvar{},
top type \ltiTop,
bottom type \ltiBot,
polymorphic types \ltiPoly{\ova{\ltitvar{}}}{\ltiT{}},
record types \ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}},
and function types
\ltiFn{\ltiT{}}{\ltiS{}}.
Type environments \ltiEnv{}
consist of 
the empty environment
\ltiEmptyEnv,
variable types
\hastype{\ltivar{}}{\ltiT{}},
type variables 
\ltitvar{},
and concatenation
\ltiEnvConcat{\ltiEnv{}}{\ltiEnvp{}}.

We assume different term and type variables are distinct,
and treat terms and types that are equal up to alpha-renaming as equivalent.
Record terms and types have unordered fields.
We treat primitive types (like \sml{String}) as free type variables.

\begin{figure}
  \begin{mathpar}

    \boxed{
    \infer[]
    {
      \ltitjudgementNoElab{\ltiEnv{}}{\ltiE{}}{\ltiT{}}
      \\\\
      \text{\ltiE{} is of type \ltiT{}
      }
      \\\\
      \text{ in context \ltiEnv{}.}
                 }
                 {}
                 }

    \infer [\ltiIVar]
    {}
    {
    \ltitjudgementNoElab
                    {\ltiEnv{}}
                    {\ltivar{}}
                    {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [\ltiISel]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{i}}{\ltiT{i}} , ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [\ltiISelBot]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiBot}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [\ltiIAbs]
    { 
    \ltitjudgementNoElab{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{}}}}}
                  {\ltiE{}}
                  {\ltiS{}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                   {\ltivar{}}
                                   {\ltiT{}}
                                   {\ltiE{}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}}}
                 }
                 \ \ \ \
%
    \infer [\ltiIAppInst]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    \\\\
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiTp{}}
                  \\
                  \ltiisubtype{\ltiEnv{}}{\ltiTp{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
    }
    {
      \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiappinst{\ltiF{}}
                                {\ova{\ltiR{}}}
                                {\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
    }
                 \ \ \ \
%
    \infer [\ltiIAppInstBot]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
                  \\\\
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}}}
                  {\ltiBot{}}
    }
                 \ \ \ \
%
    \infer [\ltiIRec]
    {
    \overrightarrow{
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiT{}}
                  }
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiRec{\ova{\ltivar{} = \ltiE{}}}}
                  {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
    }

  \end{mathpar}
  \caption{Internal language type system
  }
  \label{symbolic:figure:internal-language-type-system}
\end{figure}

\figref{symbolic:figure:internal-language-type-system}
presents the type system for the internal language
\ltitjudgementNoElab{\ltiEnv{}}{\ltiE{}}{\ltiT{}},
pronounced ``\ltiE{} is of type \ltiT{} in context \ltiEnv{}.''
\ltiIVar is the normal variable lookup rule.
\ltiISel selects a field already present in a record.
\ltiISelBot allows selecting fields from \ltiBot.
\ltiIAbs checks a function definition at its annotated type.
\ltiIAppInst checks a function application with explicit type arguments.
\ltiIAppInstBot allows applying operators of type \ltiBot.
\ltiIRec checks record constructors.

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
      \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
      \\\\
      \text{\ltiT{} is a subtype of \ltiS{}.
      }
                 }
                 }

    \infer [\ltiSTVar]
    {}
    {
    \ltiisubtype{\ltiEnv{}}{\ltitvar{}}{\ltitvar{}}
    }

    \infer [\ltiSTop]
    {}
    { \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiTop}}

    \infer [\ltiSBot]
    {}
    { \ltiisubtype{\ltiEnv{}}{\ltiBot}{\ltiT{}}}

    \infer [\ltiSRec]
    {
    \overrightarrow{\ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}}
    }
    {
    \ltiisubtype{\ltiEnv{}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}},
                             \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}}}
    }

    \infer [\ltiSFn]
    {
          \ltiisubtype{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}
          \\
          \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}
          }
    {\ltiisubtype {\ltiEnv{}}
                     {\ltiPolyFn{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiT{}}}
                     {\ltiPolyFn{\ltiS{}}{\ova{\ltitvar{}}}{\ltiTp{}}}
                     }

  \end{mathpar}
  \caption{Internal language subtyping
  }
  \label{symbolic:figure:internal-language-subtyping}
\end{figure}

\figref{symbolic:figure:internal-language-subtyping}
presents the subtyping for the internal language
\ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}, pronounced
``\ltiT{} is a subtype of \ltiS{}.''
\ltiSTVar says type variables are subtypes of themselves.
\ltiSTop and \ltiSBot establish \ltiTop and \ltiBot as maximal and
minimal types.
\ltiSRec says record types may forget or upcast their fields.
\ltiSFn relates types contravariantly to the left of an arrow
and covariantly to the right.

\subsection{External language}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt \ltiufun{\ltivar{}}{\ltiE{}}
                         \alt \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms}
\end{array}
$$
\caption{External Language Syntax
  (extends \figref{symbolic:figure:internal-language})
  }
\label{symbolic:figure:external-language-syntax}
\end{figure}

The syntax for the external language
\figref{symbolic:figure:external-language-syntax}
is a superset of the internal language, with unannotated functions 
\ltiufun{\ltivar{}}{\ltiE{}},
and ``lightweight'' applications with implicit type arguments
\ltiapp{\ltiF{}}{\ltiE{}}.

\begin{figure}
  \begin{mathpar}
    \infer [\ltiEAppInf]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    %{\ltiFp{}}
                    \\
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiSp{}}
                    %{\ltiEp{}}
                  \\
                       |\ova{\ltitvar{}}|>0
                  \\\\
                  \forall \ltiRp{}.
                    \left(
                    \begin{array}{lll}
                      \ltiisubtype{\ltiEnv{}}{\ltiSp{}}{\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                      \text{ implies }
                      %\arcr
                      \ltiisubtype{\ltiEnv{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}
                                   {\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}
                    \end{array}
                  \right)
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiapp{\ltiF{}}{\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    %{\ltiappinst{\ltiFp{}}
                    %            {\ova{\ltiR{}}}
                    %            {\ltiEp{}}}
    }

    \infer [\ltiEAppInfBot]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
                  \\\\
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiapp{\ltiF{}}{\ltiE{}}}
                  {\ltiT{}}
    }

    \infer [\ltiEUAbs]
    { 
    \ltitjudgementNoElab{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{}}}}}
                  {\ltiE{}}
                  {\ltiS{}}
                  \\\\
              \ova{\ltitvar{}} \cap \ltitv{\ltiE{}} = \varnothing
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                 }
  \end{mathpar}

  \caption{External Language Specification (extends 
  \figref{symbolic:figure:internal-language-type-system})
  }
  \label{symbolic:figure:external-language-declarative-type-system}
\end{figure}

The external language type system is (declaratively) specified in
\figref{symbolic:figure:external-language-declarative-type-system}
as a superset of the (algorithmic) internal language.
\ltiEAppInf says we must pick the most general type arguments when elaborating
an application without explicit type arguments.
This is identical to the corresponding rule in Local Type Inference.
\ltiEUAbs says that an untyped function must type check at the interface
chosen for its elaboration.
Since we also infer type parameters, the rule also requires the type variables chosen must
not capture type variables that occur free in the body of the function.
A similar rule is included in Colored Local Type Inference, except
colored types enforce that parameter types and type parameters only be inherited
from its surrounding context.
In constrast, our rule uses an oracle to synthesize both.
This is because our type inference algorithm based on symbolic closures
is not restricted to local reasoning.

\subsection{Type Inference Algorithm}

We now define a type inference algorithm based on symbolic closures
that recovers types from terms written in the external language.
First, we give the syntax for symbolic closures, then we describe
the organization of type inference, and finally fill in the missing details.

%In order to reliably elaborate to \ltiFsub, we model a restriction of symbolic closure types.
%
%First, the elaborated type of a symbolic closure is chosen greedily,
%when it is first symbolically executed, and each symbolic closure
%must be exercised at least once to elaborate its body.
%A polymorphic type may also be chosen, but the type arguments bound by
%the function must also be chosen at this time.
%This is for several reasons.
%Most obviously, we lack
%intersection types, and so have no natural way of enumerating more than one interface
%type for a function, with each interface
%corresponding to a symbolic execution.
%Adding intersection types would require further considerations, namely
%the machinery needed to annotate a function that is ascribed many interfaces is quite involved
%(e.g., branching types~\cite{wells2002branching},
%contextual subtyping~\cite{Dunfield2004Tridirectional},
%and ``lazy'' type substitutions~\cite{polyduce1})
%and obscures the (orthogonal) idea of symbolic closures, which we hope to present
%in its essense.
%We might also attempt to infer a single polymorphic function type that combines all interfaces,
%however that is a separate problem we have not attempted.
%
%Second, we restrict a symbolic closure to the type-variable scope in which it was defined.
%Relaxing this restriction raises questions about scoping also solved by
%contextual subtyping~\cite{Dunfield2004Tridirectional}.
%Alternatively, we could quantify over out-of-scope variables
%with a polymorphic type, but this would most likely require also
%inferring type arguments for arguments~\cite{polyduce1},
%which we do not cover here.
%
%Third, we disallow a symbolic closure type to be passed to themselves.
%We must fully erase symbolic closure types to elaborate to \ltiFsub,
%however we do not model the equi-recursive type binders that are the 
%natural encoding for such types. On the other hand, since it does not require
%recursive types to elaborate, symbolic closures
%be passed to \emph{other} symbolic closures, even if the former elaborates to a polymorphic
%type (since \ltiFsub is impredicative, i.e., does not restrict the places a polymorphic type
%may occur).
%
%Fourth, we add a global symbolic reduction limit, called ``fuel'', to make
%type inference decidable.
%Since a symbolic closure may be symbolically executed an unbounded
%number of times, this restriction is also useful for practical implementations
%using symbolic closures.
%
%As we will see, symbolic closures are useful even with these restrictions.

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
                                     {\ltivar{}}
                                     {\ltiE{}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& ... \alt \ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}
                      &\mbox{Types} \\
  \ltiClosureID{} &::=& \ltitvar{}
                      &\mbox{Symbolic Closure Identifiers} \\
  \ltiFuel{} &::=& \ltinat{}
                      &\mbox{Symbolic Reduction Fuel} \\
  \ltiClosureCache{} &::=& \ova{\ltiClosureCacheEntry
                                {\ltiClosureID{}}
                                {\ltiClosure{\ltiEnv{}}{\ltiE{}}}}
                      &\mbox{Elaboration Caches}
                      \\
  \ltiCombinedThreadedEnv{} &::=& \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
                      &\mbox{Threaded Environments}
\end{array}
$$
\caption{Symbolic Closure Language (SCL) Syntax (extends \figref{symbolic:figure:external-language-syntax})}
\label{symbolic:figure:SC-language-syntax}
\end{figure}

The syntax for the Symbolic Closure Language (SCL)
is given in 
\figref{symbolic:figure:SC-language-syntax}, which
is a superset of the external language syntax.
We introduce a new term and type, both which act as
a sort of placeholder for an explicitly typed function term or type (respectively)
which will be filled in after type checking.
The term
\ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
            {\ltivar{}}
            {\ltiE{}}
is a tagged function,
which says the unannotated function 
\ltiufun{\ltivar{}}{\ltiE{}}
was assigned the symbolic closure type identified by
\ltiClosureID{}.
A symbolic closure type
\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}},
then,
says the unannotated function term \ltiufun{\ltivar{}}{\ltiE{}}
is closed under definition type context \ltiEnv{}, with identifier \ltiClosureID{}.
We say \ltiufun{\ltivar{}}{\ltiE{}} is \emph{closed} because all free type and term variables in \ltiufun{\ltivar{}}{\ltiE{}}
are bound by \ltiEnv{}.
In terms of the internal language,
a loose first-intuition of a symbolic closure type's meaning
is a function type
\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}
where
\ltitjudgementNoElab{\ltiEnvConcat{\ltiEnv{}}
                    {\ltiEnvConcat{\ova{\ltitvar{}}}
                                  {\hastype{\ltivar{}}{\ltiT{}}}}}
                    {\ltiE{}}
                    {\ltiS{}}.
This analogy is inadequate because (in small part) \ltiEnv{}, \ltiT{}, \ltiE{}, and \ltiS{}
can contain SCL types and terms.

An important part of using SCL for type inference is making the meaning of
symbolic closure types explicit by replacing them with concrete internal types and terms.
To this end, the remaining syntax is in service to the bookkeeping necessary to decide
how to achieve this.
To prevent infinite loops when checking symbolic closures, we introduce
symbolic reduction fuel \ltiFuel{}, a natural number that represents
the remaining number of symbolic reductions allowed.
The elaboration of an unannotated function checked with symbolic closures could
be determined at any time, so an elaboration cache \ltiClosureCache{} is maintained 
that associates a symbolic closure \ltiClosureID{}
with its scoped elaboration \ltiClosure{\ltiEnv{}}{\ltiE{}}, which says
SCL term \ltiE{} is closed under SCL type environment \ltiEnv{}.
For convienience, we use threaded environments \ltiCombinedThreadedEnv{} to stand for
the pair \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}.

We now describe the organization of type inference.
The SCL typing judgment
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCachep{}}}
                      {\ltiEp{}}
says with initial fuel \ltiFuel{} and elaboration cache \ltiClosureCache{},
external term \ltiE{} is of SCL type \ltiT{}
in SCL context \ltiEnv{}, elaborating to SCL term \ltiEp{} with 
updated fuel \ltiFuelp{} and elaboration cache \ltiClosureCachep{}.
It performs a depth-first traversal of the syntax tree.

\begin{figure}[h]
  \begin{mathpar}
  \infer[Infer]
  {
    \exists \ltiFuel{}.
     \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                       {\ltiEnv{}}
                       {\ltiE{}}
                       {\ltiS{}}
                       {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
                       {\ltiEp{}}
                       \\
                  \ltielimClosT{\varnothing}{\ltiClosureCache{}}{\ltiS{}}{\ltiT{}}
                  \\
                  \ltielimClos{\ltiClosureCache{}}{\ltiEp{}}{\ltiF{}}
  }
  {
  \ltiEnv{} \vdash \hastype{\ltiE{}}{\ltiT{}} \hookrightarrow {\ltiF{}}
  }
  \end{mathpar}
\end{figure}

The top-level driver for type inference
$\ltiEnv{} \vdash \hastype{\ltiE{}}{\ltiT{}} \hookrightarrow {\ltiF{}}$, presented above,
says external term \ltiE{} has internal type \ltiT{}
in external environment \ltiEnv{}, with internal elaboration \ltiF{}.
It requires an initial fuel \ltiFuel{} to be provided to SCL, 
and then uses the output elaboration cache \ltiClosureCache{}
to erase SCL terms and types using the metafunctions \ltielimClossymbol
and \ltielimClosTsymbol.
Next, we present the SCL type system and subtyping
(except for the SCL implementation of \ltiEAppInf, described in \chapref{chapter:symbolic:directed-lti}),
then provide definitions for the elaboration metafunctions.

\begin{figure}
  \begin{mathpar}
    \boxed
    {
    \infer[]
    {}
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
                     \\\\
                     \text{Given symbolic closure environment \ltiCombinedThreadedEnv{}
                     and SCL context \ltiEnv{}, external term \ltiE{}
                     has SCL type \ltiT{}
                     }
                     \\\\
                     \text{in environment \ltiCombinedThreadedEnvp{},
                     with SCL elaboration \ltiEp{} (omitted when obvious from subderivations).
                     }
                     }
                     }

    \begin{array}{c}
    \infer [\ltiSCVar]
    {}
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltivar{}}
                      {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                      {\ltiCombinedThreadedEnv{}}
                      {\ltivar{}}
                 }
\ \ \ 
    \infer [\ltiSCRec]
    {
    \overrightarrowcaption{
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{i-1}}
                      {\ltiEnv{}}
                      {\ltiF{i}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnv{i}}
                      {\ltiFp{i}}
                      }^{ 1 \leq i \leq n}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{0}}
                      {\ltiEnv{}}
                      {\ltiRec{\ova{\ltivar{} = \ltiF{}}^n}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n}}
                      {\ltiCombinedThreadedEnv{n}}
                      {\ltiRec{\ova{\ltivar{} = \ltiFp{}}^n}}
    }

                 \\\\
    \infer [\ltiSCSel]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},..., \hastype{\ltivar{i}}{\ltiT{i}},..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiFp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{i}}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }
    \end{array}

    \begin{array}{ll}
    \infer [\ltiSCAbs]
    {
    \left(
    \begin{array}{llll}
      \text{$|\ova{\ltitvar{}}|>0$ implies \ltiEnv{} and \ltiS{}}
                     \arcr
                     \text{contain no symbolic closures}
    \end{array}
    \right)
                     \\\\
     \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                    {\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{}}}}}
                     {\ltiE{}}
                     {\ltiS{}}
                     {\ltiCombinedThreadedEnvp{}}
                     {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                           {\ltivar{}}
                                           {\ltiT{}}
                                           {\ltiE{}}}
                    {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    {\ltiCombinedThreadedEnvp{}}
                    {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                           {\ltiFn{\ltiT{}}{\ltiS{}}}
                                           {\ltivar{}}
                                           {\ltiEp{}}}
                 }
    \end{array}

    \infer [\ltiSCAppInst]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
    \\\\
                       \ltiSsubtype{\ltiCombinedThreadedEnv{3}}
                                   {\ltiEnv{}}
                                   {\ltiTp{}}
                                   {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                                   {\ltiCombinedThreadedEnv{4}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiE{}}}
                      {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiEp{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [\ltiSCAppInstBot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvpp{}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnvpp{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiE{}}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiEp{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [\ltiSCSelBot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiFp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{}}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltisel{\ltiFp{}}{\ltivar{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [\ltiSCAppInfBot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvpp{}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnvpp{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }


    \infer [\ltiSCUAbs]
    {
    \ltiCombinedThreadedEnv{} = \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
    \\
    \ltiClosureID{} \not\in dom(\ltiClosureCache{})
    \\\\
    \ltiCombinedThreadedEnvp{}
    =
    \ltimakeCombinedThreadedEnv{\ltiFuel{}}
    {\ltimapsto{\ltiClosureCache{}}
               {\ltiClosureID{}}
               {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiufun{\ltivar{}}{\ltiE{}}}
                      {\ltiClosureWithStkID{\ltiEnv{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiufunelab{\ltiClosureID{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
                 }
    \ \ \ \ 
%
    \infer [\ltiSCAppInfClosure]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiClosureWithStkID{\ltiEnvp{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiEp{}}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{3}}{\ltiClosureCache{3}}}
                      {\ltiEpp{}}
                  \\\\
    0 < \ltiFuel{3}
    \\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv
                       {\ltiFuel{3}-1}
                       {\ltiClosureCache{3}}}
                      {\ltiEnvConcat{\ltiEnvp{}}{\hastype{\ltivar{}}{\ltiT{}}}}
                      {\ltiEp{}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{4}}{\ltiClosureCache{4}}}
                      {\ltiFpp{}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{4}}
                          {\ltiupdateClosureCacheSingleLHS{\ltiClosureCache{4}}
                                {\ltiClosureID{}}
                                {\ltifuntparamargrettype
                                 {}
                                 {\ltivar{}}
                                 {\ltiT{}}
                                 {\ltiS{}}
                                 {\ltiFpp{}}}}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEpp{}}}
    }
  \end{mathpar}

  \caption{Type inference algorithm (\textsc{AppInf} omitted)
  }
  \label{symbolic:figure:SC-language-algorithmic-type-system}
\end{figure}

The SCL type system is given in \figref{symbolic:figure:SC-language-algorithmic-type-system}.
We abbreviate
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCachep{}}}
                      {\ltiEp{}}
                      as
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
                      where
${\ltiCombinedThreadedEnv{}} = {\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}}$
and 
                      ${\ltiCombinedThreadedEnvp{}} = {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCachep{}}}$.
Further, we sometimes omit the elaborated term as
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}},
                      but only when
                      {\ltiEp{}}
                      can be obviously derived from subderivations.
The first seven rules correspond to the internal language type system,
straightfowardly extended with threaded environments.
The extra condition in \ltiSCAbs
helps ensure a symbolic closure type only reasons about type variables
in its definition scope.
The first rule for lightweight applications \ltiSCAppInfBot implements \ltiEAppInfBot.

The remaining rules are more interesting.
The symbolic closure introduction rule
\ltiSCUAbs creates a symbolic closure type with a fresh identifier \ltiClosureID{}
for the unannotated function term \ltiufun{\ltivar{}}{\ltiE{}}.
The return type is symbolic closure type
                       \ltiClosureWithStkID{\ltiEnv{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiE{}}},
which holds enough information to both check its body at some later time
and link its elaboration to the originating term.
The elaboration cache entry for \ltiClosureID{} is initialized 
with an unannotated function term, signifying that the body has yet to be type checked,
and is passed on as part of \ltiCombinedThreadedEnvp{}.
Finally, the elaboration
                      {\ltiufunelab{\ltiClosureID{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
tags the original term with its symbolic closure identifier \ltiClosureID{}.
Intuitively, this rule is sound because, from the type checker's perspective,
there is no witness (yet) to \ltiufun{\ltivar{}}{\ltiE{}}
being called, and so there is no opportunity to ``get stuck'' or
``go wrong''. 
The next rule handles one kind of witness to its invocation: application.

The application rule for symbolic closures
\ltiSCAppInfClosure
checks term \ltiapp{\ltiF{}}{\ltiE{}}
where \ltiF{} has symbolic closure type
                      {\ltiClosureWithStkID{\ltiEnvp{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiEp{}}}}
                                           and 
\ltiE{} has type \ltiT{}.
As with the normal application rule,
we must ensure \ltiF{}'s domain is permissive enough to be
applied to terms of type \ltiT{}, which
we verify with a symbolic reduction.
After consuming fuel, the final premise checks \ltiClosureID{}'s
function body \ltiEp{} in its definition context \ltiEnvp{},
extended with \hastype{\ltivar{}}{\ltiT{}} (to account for
\ltiE{} of type \ltiT{} being passed as an argument), giving result type \ltiS{}
and elaboration \ltiFpp{}.
The type of the entire application is simply \ltiS{}, since
the condition in \ltiSCAbs (and in other rules, given later) ensure that
\ltiEnv{} and \ltiEnvp{} share the same type variable scope---there
is no opportunity for \ltiS{} to introduce an out-of-scope type variable.
We now pick the elaboration for \ltiClosureID{}
to be
{\ltifuntparamargrettype
                                 {}
                                 {\ltivar{}}
                                 {\ltiT{}}
                                 {\ltiS{}}
                                 {\ltiFpp{}}}
(an abbreviation for a function with return type \ltiS{}, defined in
\figref{symbolic:figure:external-language-syntax-abbreviations})
using the \ltiupdateClosureCacheSinglesymbol metafunction.
Since we choose \ltiClosureID{} to be monomorphic, it does
not require type arguments
and so
the entire application elaborates to
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEpp{}}}.
A symbolic closure's elaboration may be picked exactly once,
so it is an error for any past or future elaborations decide
on different numbers of type arguments.
We elide the almost-identical rule \ltiSCAppClosure for applying a symbolic closure
with explicit type arguments,
since it can only be of the form \ltiappinst{\ltiF{}}{}{\ltiE{}}.

\begin{mathpar}
  \inferrule*[]
  {
  \inferrule*
  {
  \inferrule*
  {
  \inferrule*[lab=\boxed{\ltiSCUAbs}]
   {}
   {
   \ltitSstkjudgementNoElabCombined{\varnothing}
                                   {\ltiEnv{}^{\tikz[overlay,remember picture] \node [] (c1) {};}}
                                   {{\tikz[overlay,remember picture] \node [] (c) {};}\boxed{\ltiufun{\ltivar{}}{\ltiF{}}}}
                                   {\boxed{
                                           {\ltiClosureWithStkID{{\tikz[overlay,remember picture] \node [] (d1) {};}\ltiEnv{}}{\ltiClosureID{}}
                                                                {{\tikz[overlay,remember picture] \node [] (d2) {};}\ltiufun{\ltivar{}}{\ltiF{}}}}}
                                                                {\tikz[overlay,remember picture] \node [] (d) {};}}
                                   {\ltiCombinedThreadedEnv{}}
                                   {\ltiufun{\ltivar{}}{\ltiF{}}}
   }
   }
   {...}
   }
   {
   \ltitSstkjudgementNoElabCombined{\varnothing}
                                   {...}
                                   {\ltiRec{\text{d}={{\tikz[overlay,remember picture] \node [] (b) {};}\boxed{\ltiufun{\ltivar{}}{\ltiF{}}}}}}
                                   {\ltiRec{\hastype{\text{d}}
                                           {\boxed
                                            {\ltiClosureWithStkID{\ltiEnv{}}
                                                                {\ltiClosureID{}}
                                                                {\ltiufun{\ltivar{}}
                                                                         {\ltiF{}}}}
                                                                         ^
                                                                         {\tikz[overlay,remember picture] \node [] (e) {};}
                                                                         _
                                                                         {\tikz[overlay,remember picture] \node [] (e1) {};}}}}
                                   {\ltiCombinedThreadedEnv{}}
                                   {\ltiufun{\ltivar{}}{\ltiF{}}}
                                   }
   \\
  \inferrule*[lab=\boxed{
  \ \ \ \ \ \ \ \ \ \ 
  \ \ \ \ \ \ \ \ \ \ 
                        \ltiSCAppInfClosure 
                        \ \ \ \ \ \ \ \ \ 
                        \ \ \ \ \ \ \ \ \ 
                        }
  ]
  {
  \inferrule*[]
   {...}
   {
   \ltitSstkjudgementNoElabCombined{\varnothing}
                      {{}_{\tikz[overlay,remember picture] \node [] (h) {};}
                       .}
                      {{\ltisel{\text{g}}{\text{d}}}}
                      {\text{}_{\tikz[overlay,remember picture] \node [] (i) {};}
                      \boxed{\ltiClosureWithStkID{{\ltiEnv{}}^{\tikz[overlay,remember picture] \node [] (j) {};}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}
                                                    {\ltiF{}^{\tikz[overlay,remember picture] \node [] (l) {};}}}}}
                      {\ltiClosureCache{}}
                      {\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}}
   }
   \\
   \inferrule*
   {...}
   { \ltitSstkjudgementNoElabCombined{\ltiClosureCache{}}
                      {.}
                      {\ltiE{}}
                      {{\ltiS{}}_{\tikz[overlay,remember picture] \node [] (n) {};}}
                      {\ltiClosureCache{}}
                      {\ltiEp{}}
   }
   \\
   \inferrule*[]
   { }
   {
    \ltitSstkjudgementNoElabCombined{\ltiClosureCache{}}
                      {\ltiEnvConcat{\ltiEnv{}^{\tikz[overlay,remember picture] \node [] (k) {};}
                                     }
                                    {\hastypesmall{\ltivar{}}{\text{}_{\tikz[overlay,remember picture] \node [] (o) {};}{\ltiS{}}}}}
                      {\text{}^{\tikz[overlay,remember picture] \node [] (m) {};}\ltiF{}}
                      {\ltiT{}}
                      {\ltiClosureCache{}}
                      {\ltisel{\text{g}}{\text{d}}}
                      }
  }
  {
    \ltitSstkjudgementNoElabCombined{\ltiCombinedThreadedEnv{}}
                      {\ltiEnvConcat{...}
                                    {\hastype{\text{g}}{\ltiRec{\hastype{\text{d}}
                                                                        {{}^{\tikz[overlay,remember picture] \node [] (g) {};}
                                                                                _{\tikz[overlay,remember picture] \node [] (f) {};}
                                                                        \boxed{\ltiClosureWithStkID{\ltiEnv{}}
                                                                                             {\ltiClosureID{}}
                                                                                             {\ltiufun{\ltivar{}}{\ltiF{}}}}}}}}}
                      {\ltiapp{
                               {\ltisel{\text{g}}{\text{d}}}}
                              {\ltiE{}}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiapp{\ltiFp{}}{\ltiEp{}}}
  }
  }
  {
    \ltitSstkjudgementNoElabCombined{\ltiCombinedThreadedEnv{}}
                      {...}
                      {\ltilet{\text{g}}{\ltiRec{\text{d}={{\tikz[overlay,remember picture] \node [] (a) {};}{\ltiufun{\ltivar{}}{\ltiF{}}}}}}
                              {\ltiapp{\ltisel{\text{g}}{\text{d}}}{\ltiE{}}}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiapp{\ltiFp{}}{\ltiEp{}}}
  }
\end{mathpar}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (b);
  \coordinate (End2) at (c);
  \coordinate (Start3) at (c);
  \coordinate (End3) at (d2);
  \coordinate (Start3p1) at (c1);
  \coordinate (End3p1) at (d1);
  \coordinate (Start4) at (d);
  \coordinate (End4) at (e);
  \coordinate (Start6) at (e1);
  \coordinate (End6) at (f);
  \coordinate (Start7) at (g);
  \coordinate (End7) at (h);
  \coordinate (Start5) at (h);
  \coordinate (End5) at (i);
  \coordinate (Start8) at (j);
  \coordinate (End8) at (k);
  \coordinate (Start9) at (l);
  \coordinate (End9) at (m);
  \coordinate (Start10) at (n);
  \coordinate (End10) at (o);
  \draw[red,dashed,->](Start1.north) to [bend left] (End1.south);
  \draw[red,dashed,->](Start2.north) to (End2.south);
  \draw[red,dashed,->](Start3.north) to [bend right] (End3.south);
  \draw[red,dashed,->](Start3p1.north) to [bend left] (End3p1.south);
  \draw[red,dashed,->](Start4.north) to (End4.south);
  \draw[red,dashed,->](Start5.north) to (End5.south);
  \draw[red,dashed,->](Start6.north) to (End6.south);
  \draw[red,dashed,->](Start7.north) to (End7.south);
  \draw[red,dashed,->](Start8.north) to [bend left] (End8.south);
  \draw[red,dashed,->](Start9.north) to [bend left] (End9.south);
  \draw[red,dashed,->](Start10.north) to [bend right] (End10.south);
\end{tikzpicture} 

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiSsubtype{\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltiS{}}
                 {\ltiT{}}
                 {\ltiCombinedThreadedEnvp{}}
                 \\\\
                 \text{
                 With symbolic closure environment \ltiCombinedThreadedEnv{},
                 \ltiS{} is a subtype of \ltiT{}
                 in updated environment \ltiCombinedThreadedEnvp{}.
                 }
    }
    }

    \infer [\ltiSCSTVar]
    {}
    {
     \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltitvar{}}
                 {\ltitvar{}}
                 {\ltiCombinedThreadedEnv{}}
    }

    \infer [\ltiSCSTop]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiT{}}{\ltiTop}{\ltiCombinedThreadedEnv{}}}

    \infer [\ltiSCSBot]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiBot}{\ltiT{}}{\ltiCombinedThreadedEnv{}}}

    \infer [\ltiSCSRec]
    {
    \overrightarrowcaption{\ltiSsubtype{\ltiCombinedThreadedEnv{i-1}}{\ltiEnv{}}
                                {\ltiT{}}
                                {\ltiS{}}
                                {\ltiCombinedThreadedEnv{i}}
                                }^{1 \leq i \leq n}
    }
    {
    \ltiSsubtype{\ltiCombinedThreadedEnv{0}}
                {\ltiEnv{}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n,
                         \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}^n}}
                {\ltiCombinedThreadedEnv{n}}
    }

    % eg (IFn [Int -> Int] [Number -> Number]) <: [Nothing -> Any]
    \infer [\ltiSCSFn]
    {
    \left(
    \begin{array}{lll}
      |\ova{\ltitvar{}}|>0 \text{ implies \ltiT{}, \ltiTp{}, \ltiS{}, \ltiSp{}}
    \arcr
      \text{contain no symbolic closures}
    \end{array}
    \right)
    \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}{\ltiCombinedThreadedEnvpp{}}
      \\\\
      \ltiSsubtype{\ltiCombinedThreadedEnvpp{}}{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}{\ltiCombinedThreadedEnvp{}}
    }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}
                  {\ltiPolyFn{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiT{}}}
                  {\ltiPolyFn{\ltiS{}}{\ova{\ltitvar{}}}{\ltiTp{}}}
                  {\ltiCombinedThreadedEnvp{}}
       }

    \infer [\ltiSCSClosure]
    {
    \ltiCombinedThreadedEnv{1} = {\ltimakeCombinedThreadedEnv{\ltiFuel{1}}{\ltiClosureCache{1}}}
    \\
    \ltitv{\ltiE{}} \cap \ova{\ltitvar{}} = \varnothing
    \\\\
    0 < \ltiFuel{1}
    \\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{1}-1}{\ltiClosureCache{1}}}
                      {\ltiEnvConcat{\ltiEnv{}}
                                    {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                  {\hastype{\ltivar{}}{\ltiT{}}}}}
                      {\ltiE{}}
                      {\ltiSp{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{2}}{\ltiClosureCache{2}}}
                      {\ltiEp{}}
                      \\\\
    \ltiSsubtype{\ltimakeCombinedThreadedEnv
                 {\ltiFuel{2}}
                 {\ltiupdateClosureCacheSingleLHS{\ltiClosureCache{2}}
                                                  {\ltiClosureID{}}
                                                  {\ltifuntparamargrettype
                                                   {\ova{\ltitvar{}}}
                                                   {\ltivar{}}
                                                   {\ltiT{}}
                                                   {\ltiSp{}}
                                                   {\ltiEp{}}}}}
                {\ltiEnv{}}{\ltiSp{}}{\ltiS{}}
                {\ltiCombinedThreadedEnv{3}}
    }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{1}}
                  {\ltiEnvp{}}
                  {\ltiClosureWithStkID{\ltiEnv{}}
                                       {\ltiClosureID{}}
                                       {\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                  {\ltiCombinedThreadedEnv{3}}
                  }
  \end{mathpar}

  \caption{Symbolic Closure Language Subtyping}
  \label{symbolic:figure:SC-language-subtype}
\end{figure}

Subtyping for SCL is given in
  \figref{symbolic:figure:SC-language-subtype}.
The judgment
\ltiSsubtype{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}}
            {\ltiEnv{}}
            {\ltiS{}}
            {\ltiT{}}
            {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCachep{}}}
            says with fuel \ltiFuel{} and elaboration cache \ltiClosureCache{},
            \ltiS{} is a subtype of 
            {\ltiT{}}
            with updated fuel \ltiFuelp{} and elaboration cache \ltiClosureCachep{}.
Similar to the typing judgment, we abbreviate subtyping
with threaded environments as
\ltiSsubtype{\ltiCombinedThreadedEnv{}}
            {\ltiEnv{}}
            {\ltiS{}}
            {\ltiT{}}
            {\ltiCombinedThreadedEnvp{}}.
The first five rules correspond to the internal language subtyping rules,
extended with threaded environments.
The extra condition in \ltiSCSFn helps contain symbolic closures
to the type-variable scope they were defined in.
The rule \ltiSCSClosure relates symbolic closures with polymorphic function types.
It follows the idea that \ltiClosureWithStkID{\ltiEnv{}}
                             {\ltiClosureID{}}
                             {\ltiufun{\ltivar{}}{\ltiE{}}}
                             is a subtype of
\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}
if \ltifuntparamargrettype{\ova{\ltitvar{}}}
                          {\ltivar{}}
                          {\ltiT{}}
                          {\ltiSp{}}
                          {\ltiE{}}
is well typed under \ltiEnv{} and 
\ltiSp{}
is a subtype of
\ltiS{}.
The rule proceeds similarly to \ltiSCAppInfClosure, except we may choose a polymorphic
type for \ltiClosureID{}, and we must check the return type is under \ltiS{}.
Adding a type binder to a term invites the possibility of unintentional 
variable capture, and so 
the condition on \ova{\ltitvar{}} avoids capturing free type variables in \ltiE{}.

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiupdateClosureCacheSingle{\ltiClosureCache{}}{\ltiClosureID{}}{\ltiE{}}{\ltiClosureCachep{}}
    \\\\
    \text{Pick SCL elaboration \ltiE{} for symbolic closure identifier \ltiClosureID{}.
    }
    }
    }

    \begin{array}{llll}
      \ltiupdateClosureCacheSinglealign{\ltiClosureCache{}}{\ltiClosureID{}}{\ltiE{}}
                           {\ltimapsto{\ltiClosureCache{}}
                                      {\ltiClosureID{}}
                                      {\ltiClosure{\ltiEnv{}}
                                                  {\ltiE{}}}}
                                                 , &
                                                 \text{where }
    (\ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = 
                       {\ltiClosure{\ltiEnv{}}
                                   {\ltiufun{\ltivar{}}{\ltiF{}}}})
                                   \text{ or }
    (\ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = 
              {\ltiClosure{\ltiEnv{}}{\ltiE{}}})
    \end{array}
  \end{mathpar}
  \caption{Metafunctions for Symbolic Closure language}
  \label{symbolic:figure:SC-language-metafunctions}
\end{figure}

The metafunction \ltiupdateClosureCacheSinglesymbol is defined in \figref{symbolic:figure:SC-language-metafunctions}.
It manages the elaboration cache so that a symbolic closure's SCL elaboration term is
only picked once.

\begin{figure}

%  \[
%    \boxed{\ltielabDriver{\ltiE{}}{\ltiEp{}}{\ltiT{}}
%    \text{ Elaborates external language term \ltiE{} to internal language term \ltiEp{} and type \ltiT{}.
%    }
%    }
%  \]
%
%  \[
%  \begin{array}{lll}
%    \ltielabDriver{\ltiE{1}}
%                  {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{2}}}
%                  {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}
%                  , &\text{where }
%    \exists \ltiFuel{}.
%     \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
%                       {\ltiEmptyEnv}
%                       {\ltiE{1}}
%                       {\ltiT{}}
%                       {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
%                       {\ltiE{2}}
%  \end{array}
%  \]

  \[
    \boxed{\ltielimClos{\ltiClosureCache{}}{\ltiE{}}{\ltiEp{}}
    \text{ Converts symbolic closures in \ltiE{} to explicit types in \ltiEp{}}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosalign{\ltiClosureCache{}}{\ltivar{}}
                     {\ltivar{}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltiappinst{\ltiF{}}
                                 {\ova{\ltiR{}}}
                                 {\ltiE{}}}
                     {\ltiappinst{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}
                                 {\ova{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiR{}}}}
                                 {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
                             \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltisel{\ltiF{}}{\ltivar{}}}
                     {\ltisel{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}{\ltivar{}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                     {\ltiRec{\ova{\ltivar{} = \ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                          {\ltivar{}}
                                          {\ltiT{}}
                                          {\ltiE{}}}
                     {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                          {\ltivar{}}
                                          {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}
                                          {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
                                  {\ltivar{}}
                                  {\ltiE{}}}
                     {\ltielimClosLHS{\ltiClosureCache{}}
                                     {\ltiF{}}},
                     &\text{where } \ltilookup{\ltiClosureCache{}}{\ltiClosureID{}}
                                      = \ltiClosure{\ltiEnv{}}{\ltiF{}}
  \end{array}
  \]


  \[
    \boxed{\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    \text{ Converts symbolic closures in \ltiT{} to explicit types in \ltiTp{},
    with seen symbolic closures \ova{\ltiClosureID{}}.}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiTop}{\ltiTop}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiBot}{\ltiBot}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltitvar{}}{\ltitvar{}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiPolyFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}{\ova{\ltitvar{}}}
                             {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiS{}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiE{}}}
                      {\ltiPolyFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}\ltiClosureIDp{}}
                                                  {\ltiClosureCache{}}
                                                  {\ltiT{}}}
                                 {\ova{\ltitvar{}}}
                                 {\ltielimClosTLHS{\ova{\ltiClosureID{}}\ltiClosureIDp{}}
                                                  {\ltiClosureCache{}}
                                                  {\ltiS{}}}}
                      , & 
                      \text{where }
                      \ltiClosureIDp{} \not\in \ova{\ltiClosureID{}},
                      \ltilookup{\ltiClosureCache{}}{\ltiClosureIDp{}}
                      = \ltiClosure{\ltiEnv{}}
                                   {\ltifuntparamargrettype{\ova{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiS{}}{\ltiE{}}}
                                   % this condition is checked in S-Closure and constraint system
                                   %, \ova{\ltitvar{}} \cap \ltitv{\ltiE{}} = \varnothing
  \end{array}
  \]
  \caption{Elaboration Metafunctions for SCL Terms and Types}
  \label{symbolic:figure:SC-language-elaboration}
\end{figure}

Elaboration metafunctions are given in \figref{symbolic:figure:SC-language-elaboration}.
For terms, \ltielimClos{\ltiClosureCache{}}{\ltiE{}}{\ltiEp{}}
elaborates \ltiE{} to \ltiEp{} using elaboration cache \ltiClosureCache{}.
The case for tagged unannotated functions 
{\ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
                                  {\ltivar{}}
                                  {\ltiE{}}}
simply uses the elaboration entry for \ltiClosureID{} to continue elaboration.
The metafunction is undefined for the external language's unannotated terms.
For unannotated functions, this means each symbolic closure must be symbolically executed at least once,
otherwise they would contain unannotated functions and applications.
Unannotated applications are already elaborated away with local type argument synthesis
(\chapref{chapter:symbolic:directed-lti}).
Otherwise, the other interesting feature of \ltielimClossymbol is that it
calls \ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}} on types, which
elaborates symbolic closures in \ltiT{} using \ltiClosureCache{}.
Some extra bookkeeping is needed to prevent infinitely generating
types. Since symbolic closures may be passed to other symbolic closures,
a seen-set \ova{\ltiClosureID{}} handles the case where it is passed to itself.
Since we do not model equi-recursive types, we simply disallow that situation here.


\section{Examples without Type Argument Synthesis}

\begin{mathpar}
  \inferrule*[left=\ltiSCAppInfClosure
  ]
  {\inferrule*[lab=\ltiSCUAbs]
   {
   \ltiClosureCache{} =
                       {\ltiClosureCacheEntry{\ltiInferred{\text{c1}}}
                                           {\ltiClosure{\ltiEmptyEnv}
                                                        {\ltiufun{\text{x}}{\text{x}}}}}
   }
   { \ltitSstkjudgement{\varnothing}
                      {\ltiEmptyEnv}
                      {\tikz[overlay,remember picture] \node [] (b) {};\ltiufun{\text{x}}{\text{x}}}
                      {\ltiClosureWithStkID{\ltiEmptyEnv}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\text{x}^{\tikz[overlay,remember picture] \node [] (e) {};}}
                                                    {\text{x}^{\tikz[overlay,remember picture] \node [] (g) {};}}}}
                      {\ltiClosureCache{}}
                      {\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}}
   }
   \\
   \inferrule*
   {...}
   { \ltitSstkjudgementNoElab{\ltiClosureCache{}}
                      {\ltiEmptyEnv}
                      {\tikz[overlay,remember picture] \node [] (d) {};\text{1}}
                      {\ltiInferred{\text{Int}\tikz[overlay,remember picture] \node [] (i) {};}}
                      {\ltiClosureCache{}}
                      {\text{1}}
   }
   \\
   \inferrule*[lab=\ltiSCVar]
   { }
   {
    \ltitSstkjudgementNoElab{\ltiClosureCache{}}
                      {\hastype{\text{}^{\tikz[overlay,remember picture] \node [] (f) {};}
                                \text{x}}
                               {\ltiInferred{\tikz[overlay,remember picture] \node [] (j) {};\text{Int}}}}
                      {\text{}^{\tikz[overlay,remember picture] \node [] (h) {};}
                       \text{x}}
                      {\ltiInferred{\tikz[overlay,remember picture] \node [] (k) {};
                                    \text{Int}}}
                      {\ltiClosureCache{}}
                      {\text{x}}
                      }
  }
  {
    \ltitSstkjudgement{\varnothing}
                      {\ltiEmptyEnv}
                      {\ltiappParens{\text{}^{\tikz[overlay,remember picture] \node [] (a) {};}
                                     \ltiufun{\text{x}}{\text{x}}}
                                    {\text{1}^{\tikz[overlay,remember picture] \node [] (c) {};}}}
                      {\ltiInferred{\text{Int}}}
                      {\ltiClosureCacheEntry{\ltiInferred{\text{c1}}}
                                            {\ltiClosure{\ltiEmptyEnv}
                                                              {\ltifunargrettype{\text{x}}
                                                                                {\ltiInferred{ \text{Int}^{
                                                                                          \tikz[overlay,remember picture] \node [] (j2) {};}}}
                                                                                {\ltiInferred{ \text{Int}^{
                                                                                 \tikz[overlay,remember picture] \node [] (l) {};}
                                                                                },}
                                                                                {\text{x}}}}}
                      {\ltiappParens{\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}}{\text{1}}}
  }
\end{mathpar}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \coordinate (Start4) at (g);
  \coordinate (End4) at (h);
  \coordinate (Start5) at (i);
  \coordinate (End5) at (j);
  \coordinate (Start6) at (i);
  \coordinate (End6) at (j2);
  \coordinate (Start7) at (k);
  \coordinate (End7) at (l);
  \draw[red,dashed,->](Start1.north) to (End1.south);
  \draw[red,dashed,->](Start2.north) to (End2.south);
  \draw[red,dashed,->](Start3.north) to [bend left] (End3.south);
  \draw[red,dashed,->](Start4.north) to [bend left] (End4.south);
  \draw[red,dashed,->](Start5.north) to [bend right] (End5.south);
  \draw[red,dashed,->](Start6.north) to (End6.south);
  \draw[red,dashed,->](Start7.north) to (End7.south);
\end{tikzpicture} 

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let x = 1 in x
(* Desugared *)
$\ltiappParens{\ltiufun{\text{x}}{\text{x}}}{\text{1}}$
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifunargrettype{\text{x}}%
                                                          {\ltiInferred{\text{Int}}}%
                                                          {\ltiInferred{\text{Int}},}%
                                                          {\text{x}}}}}}$ *)
$\ltiappParens{\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}}{\text{1}}$
(* fully annotated *)
$\ltiappParens{\ltifunargrettype{\text{x}}%
                                {\ltiInferred{\text{Int}}}%
                                {\ltiInferred{\text{Int}},}%
                                {\text{x}}}%
              {\text{1}}$
\end{lstlisting}
}


\begin{figure}
$$
\begin{array}{lrlll}
  \ltiFn{\ova{\ltiT{}}^n}{\ltiS{}} &\Leftrightarrow&
  \ltiFn{\ltiRec{\overrightarrowcaption{\hastype{\texttt{arg}i}{\ltiT{i}}}^{1 \leq i \leq n}}}{\ltiS{}}
  & \text{where } n \not= 1
                      &\mbox{Type abbreviations} \\
  \ltiufun{\ova{\ltivar{}}^n}{\ltiE{}} &\Leftrightarrow&
  \ltiufun{\ltivarp{}}{\ltireplaceoverrightarrowcaption{\ltisel{\ltivarp{}}{\texttt{arg}i}}{\ltivar{i}}{1 \leq i \leq n}{\ltiE{}}}
  & \text{where } n \not= 1, \ltivarp{} \not\in \ltifvLHS{\ltiE{}}
                      &\mbox{Term abbreviations}
  \\
  \ltifuntparamargtype{\ova{\ltitvar{}}}{\ova{\ltivar{}}^n}{\ova{\ltiT{}}^n}{\ltiE{}} &\Leftrightarrow&
  \ltifuntparamargtype{\ova{\ltitvar{}}}
                      {\ltivarp{}}
                      {\ltiRec{\overrightarrowcaption{\hastype{\texttt{arg}i}{\ltiT{i}}}^{1 \leq i \leq n}}}
                      {\\ && \ \ \ltireplaceoverrightarrowcaption{\ltisel{\ltivarp{}}{\texttt{arg}i}}{\ltivar{i}}{1 \leq i \leq n}{\ltiE{}}}
  & \text{where } n \not= 1, \ltivarp{} \not\in \ltifvLHS{\ltiE{}}
  \\
  \ltiapp{\ltiF{}}{\ova{\ltiE{}}^n} &\Leftrightarrow&
  \ltiapp{\ltiF{}}{\ltiRec{\overrightarrowcaption{\texttt{arg}i = \ltiE{i}}^{1 \leq i \leq n}}}
  & \text{where } n \not= 1
  \\
  \ltilet{\ova{\ltivar{}}}{\ova{\ltiE{}}}{\ltiF{}} &\Leftrightarrow& \ltiappParens{\ltiufun{\ova{\ltivar{}}}{\ltiF{}}}{\ova{\ltiE{}}}
  \\
  \ltifunargtype{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltiE{}} &\Leftrightarrow&
  \ltifuntparamargtype{}{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltiE{}}
  \\
  \ltifunargrettype{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltiS{}}{\ltiE{}} &\Leftrightarrow&
  \ltifuntparamargrettype{}{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltiS{}}{\ltiE{}}
  \\
  \ltifuntparamargrettype{\ova{\ltitvar{}}}{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltiS{}}{\ltiE{}} &\Leftrightarrow&
  \ltifuntparamargtype{\ova{\ltitvar{}}}{\ova{\ltivar{}}}{\ova{\ltiT{}}}{\ltianncolon{\ltiE{}}{\ltiS{}}}
  \\
  \ltianncolon{\ltiE{}}{\ltiS{}} &\Leftrightarrow&
  \ltiappParens{\ltifunargtype{\ltivar{}}{\ltiS{}}{\ltivar{}}}{\ltiE{}}
\end{array}
$$
\caption{External Language Syntax abbreviations
  }
\label{symbolic:figure:external-language-syntax-abbreviations}
\end{figure}


% - Solution
%   - "obvious" function annotations
%     - can be derived from usage context
%   - introduce "symbolic" closure types
%     - a function's type is its code + typed local scope
%   - don't need to check a function that isn't called
% - Constraints
%   - wildcard "?" type
%     - needed to provide argument types while inferring body
%     - from Colored LTI
%   - Infinite loops
%     - subtyping
%     - type generalization
%     - term reduction limits
%   - user-level story
%     - symbolic closures enabled by flag
%     - users cannot write a symbolic closure
%     - that way, global annotations cannot contain a symbolic closure
%       - helps with polymorphism story
%         - constraint solving
%           - hypothesis/goal: only one side of contraint solving can have a symbolic closure
%             - one side is from global annotation, other side from local inference
%     - compatible with occurrence typing
%   - reporting errors
%     - suggesting types
%     - avoid showing inlining to users
%   - checking fn with arguments at type Bot is equivalent (?) to not checking at all
%     - what about strange disjoint ordered intersection types like `into`
%     - do they break? do they need initial Bot arities?
%   - 0-n checks to same function
%     - avoid double expansion
%       - many copies of symbolic closures are made, could be expanded at different times
%         - how to synchronize?
%     - skipping unreachable functions
%       - potential for latent bugs, if type checker turned off in future and fn is made reachable
%     - performance
%   - consistent evaluation results
%     - how to ensure correct inlining?
%     - relationship between inlined and evaluated code?
%       - do we want to "undo" the inlining when finally evaluating?
%   - when to use a closure type?
%     - partial annotations
%   - polymorphism
%     - postpone discussion to next chapter
%   - applying symbolic analysis to infer loop/recur annotations
%     - similar issues
%     - different type generalization story?
%   - comparison to let-polymorphism
%     - expressiveness
%     - performance
%   - help check macros?
%     - not directly applicable, since too much context would be lost
%       - would help check *more* of an expansion, but error messages
%         are still unrelated to original code
%   - is this a sound strategy?
%     - faithfully simulates beta reduction
%     - termination story?
%   - case studies
%     - criteria:
%       - good errors?
%       - predictable behavior?
%       - performance?
%     - simple eta expansions
%       - (+ 1 2)
%       - ((fn [x y] (+ x y)) 1 2)
%     - let-bound functions
%       - (+ 1 2)
%       - (let [plus (fn [x y] (+ x y))]
%           (plus 1 2))
%     - y-combinator
%       - stress test
%     - let-polymorphism worst case (exponential) comparison
%       - stress test
%     - completely inlined transducers
%       - case study: inlining map + comp
%         - why: non recursive polymorphic functions
%           - common idiom
%         - how to report errors?
%   - polymorphic function-intersection types
%     - how to handle, do we need backtracking?
%     - do we need to recheck arguments? 

\chapter{Type Argument Synthesis with Symbolic Closures}
\label{chapter:symbolic:directed-lti}

\subsection{Type-argument synthesis for the Symbolic Closure Language}

\begin{figure}
  \begin{mathpar}
    \infer[AppInf]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiPoly{\ova{\ltitvar{}}}
                               {\ltiFn{\ltiT{}}{\ltiS{}}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
                  \\
                       |\ova{\ltitvar{}}|>0
           \\
           \ltigenconstraint{\varnothing}{\ova{\ltitvar{}}}{\ltiTp{}}{\ltiT{}}{\ltiCp{}}
           \\
           \ltiprocessDelays{\ltiCombinedThreadedEnv{3}}
                            %{\ltiEnvConcatParen{\ltiEnv{}}{\ova{\ltitvar{}}}}
                            {\ltiCp{}}
                            {\ltiC{}}
                            {\ltiCombinedThreadedEnv{4}}
           \\
           \ltiSubst{\ltiC{}}{\ltiFn{\ltiT{}}{\ltiS{}}}{\ltisubst{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiApplySubst{\ltisubst{}}
                                                      {\ltitvar{}}}}
                                  {\ltiEp{}}}
    }
  \end{mathpar}
  \caption{Type argument synthesis for the Symbolic Closure Language}
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiC{} &::=& \ltiCSet{\ova{\ltiCEntry{\ltiT{}}{\ltitvar{}}{\ltiT{}}}\ 
                         \ova{\ltiDEntryVX{\ltiV{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiT{}}}
                          }
                      &\mbox{Constraint sets}\\
                      % TODO talk about X/V constraint sets
   \ltiCEmpty &\Leftrightarrow& \ltiCSet{\ova{\ltiCEntry{\ltiBot}{\ltitvar{}}{\ltiTop}}}
                      &\mbox{Constraint abbreviations}
\end{array}
$$
  \caption{Syntax for Constraint generation}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [CG-Top]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty}
    }

    \infer [CG-Upper]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\\\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [CG-Lower]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\\\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [CG-Bot]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty}
    }
    \ \ \ 
    %
    \infer [CG-Refl]
    {
      \ltitvarp{}
      \not\in
      \overline{\ltitvar{}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [CG-Fun]
    {
    |\ova{\ltitvar{}}|>0 \text{ implies \ova{\ltiTp{}}, \ova{\ltiT{}} contain no symbolic closures}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\ova{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\ova{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\\\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiPolyFn{\ltiTp{1}}{\ova{\ltitvar{}}}{\ltiT{2}}}
                     {\ltiPolyFn{\ltiT{1}}{\ova{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }

    \infer [CG-Closure]
    {}
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                     {\ltiPolyFn{\ltiS{}}{\ova{\ltitvar{}}}{\ltiT{}}}
                     {\ltiCSet{\ltiDEntryVX{\ltiV{}}
                                         {\overline{\ltitvarp{}}}
                                         {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                         {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiS{}}{\ltiT{}}}}}}
    }
  \end{mathpar}
  \caption{Constraint generation system
                 \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}
                 where $\ltiV{} \cap {\overline{\ltitvar{}}} = \varnothing$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}

    \boxed{
    \infer[]
    {
      \ltiprocessDelays{\ltiCombinedThreadedEnv{}}
                       {\ltiC{}}
                       {\ltiCp{}}
                       {\ltiCombinedThreadedEnvp{}}
      \\\\
      \text{Process all delayed constraints in
                       \ltiC{}, yielding a new constraint set \ltiCp{}.
      }
    }
    {}
    }

    \infer[]
    {
      \ltiorderDelays{\ltiC{0}}
                     {\ova
                       {\ltiDEntryVX{\ltiV{}}
                                    {\ova{\ltitvarp{}}}
                                    {\ltiT{}}
                                    {\ltiS{}}}^n}
                                    \\
      \overrightarrowcaption{
      \ltiprocessDelay{\ltiCombinedThreadedEnv{i-1}}
                      {\ltiDEntryVX{\ltiV{i}}
                                   {\ova{\ltitvarp{}}_i}
                                   {\ltiT{i}}
                                   {\ltiS{i}}}
                      {\ltiC{i-1}}
                      {\ltiC{i}}
                      {\ltiCombinedThreadedEnv{i}}
                      }^{1 \leq i \leq n}
    }
    {
      \ltiprocessDelays{\ltiCombinedThreadedEnv{0}}
                       {\ltiC{0}}
                       {\ltiC{n}}
                       {\ltiCombinedThreadedEnv{n}}
    }

    \boxed{
    \infer[]
    {
      \ltiorderDelays{\ltiC{}}{\ova{\ltiDEntryVX{\ltiV{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}}}
      \\\\
      \text{Returns the delayed constraints in constraint set \ltiC{} topologically
      sorted by type variable dependency.
      }
      \\\\
      \text{eg. \ltiDEntryVX{}{}{...}{\ltiFn{\ltitvar{1}}{\ltitvar{2}}}
      goes before 
            \ltiDEntryVX{}{}{...}{\ltiFn{\ltitvar{2}}{\ltitvar{3}}}
      }
    }
    {}
    }

    \infer[]
    {
      \ova{\ltitvar{}}^m = \ova{\ltitvarp{}}_1 = \ova{\ltitvarp{}}_2 = ... = \ova{\ltitvarp{}}_{i-1} = \ova{\ltitvarp{}}_i
      \\
      \forall i \in 1...n, j \in 1...m.
          \{\ltivariance{\ltitvar{j}}{\ltiS{i}}, \ltivariance{\ltitvar{j}}{\ltiT{i}}\} \subseteq \{\ltivconstant, \ltivcovariant\}
      \\
      \text{let \ova{k} be a permutation of 1...n st. }
        \forall i,j \in 1...n.
        \text{ if }
        \ltitv{\ltiT{{k_i}}} \cap \ltitv{\ltiS{{k_j}}} \cap \ova{\ltitvarp{}} \not= \varnothing
        \text{ then }
        % not \leq, eg. [a -> a] depends on itself
        i < j 
    }
    {
      \ltiorderDelays{\ltiCSet{...,\ova{\ltiDEntryVX{\ltiV{}}
                                             {\ova{\ltitvarp{}}^m}
                                             {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                             {\ltiFn{\ltiS{}}{\ltiT{}}}}^n}}
                                             {
      [\ltiDEntryVX{\ltiV{}}
                   {\ova{\ltitvarp{}}}
                   {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                   {\ltiFn{\ltiS{}}{\ltiT{}}}_i
                   |
                   i \in \ova{k}]
                   }
    }

    \boxed{
    \infer[]
    {
      \ltiprocessDelay{\ltiCombinedThreadedEnv{}}
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiS{}}
                                   {\ltiT{}}}
                      {\ltiC{}}
                      {\ltiCp{}}
                      {\ltiCombinedThreadedEnvp{}}
      \\\\
      \text{Process delayed constraint 
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiS{}}
                                   {\ltiT{}}},
                                   with current constraint set \ltiC{},
      }
      \\\\
      \text{yielding a new constraint set \ltiCp{}.}
    }
    {}
    }

    \infer[]
    {
    \ltitv{\ltiE{}} \cap \ova{\ltitvarpp{}} = \varnothing
    \\
            0 < \ltiFuel{} \\
            \ltiSubst{\ltiC{}}{\ltiPolyFn{\ltiS{}}{}{\ltiT{}}}{\ltisubst{}}\\
            \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                          {\ltiClosureCache{1}}}
                              {\ltiEnvConcat{\ltiEnv{}}
                                            {\hastype{\ltivar{}}
                                                     {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}}}
                              {\ltiE{}}
                              {\ltiTp{}}
                              {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                          {\ltiClosureCache{2}}}
                              {\ltiFpp{}}
                              \\
          \ltiupdateClosureCacheSingle{\ltiClosureCache{2}}
                                {\ltiClosureID{}}
                                {\ltifuntparamargrettype
                                 {\ova{\ltitvarpp{}}}
                                 {\ltivar{}}
                                 {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}
                                 {\ltiTp{}}
                                 {\ltiFpp{}}}
                                {\ltiClosureCache{3}}
                                \\
          \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarpp{}}}
                           {\ova{\ltitvar{}}}
                           {\ltiTp{}}
                           {\ltiApplySubst{\ltisubst{}}{\ltiT{}}}
                           {\ltiCpp{}}
                           \\
                           \ltiCpp{} \text{ does not contain delayed constraints}
    }
    {
      \ltiprocessDelay{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{1}}}
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                   {\ltiPolyFn{\ltiS{}}{\ova{\ltitvarpp{}}}{\ltiT{}}}}
                      {\ltiC{}}
                      {\ltiCIntersect{\ltiC{}}{\ltiCpp{}}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{3}}}
    }

  \end{mathpar}
  \caption{Processing delayed constraints
  }
\end{figure}

%FIXME remove
\newpage

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
type Option[a] = {match : $\ltiPoly{\text{r}}%
                                   {\ltiFn{\text{OptionVisitor[a,r]}}%
                                          {\text{r}}}$}
type OptionVisitor[a,r] =
  {caseNone : $\ltiFn{}{\text{r}}$,
   caseSome : $\ltiFn{\text{a}}{\text{r}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}%
                                        {\text{Option[s]}}}%
                                 {}$
         {match = $\ltiufun{\text{v}}%
                           {\text{v.caseNone()}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
     \ltiClosureCacheEntry{\text{c1}}%
                          {\ltiClosure{\text{s}}%
                                      {\ltiNotInferred{\ltifuntparaminterface{\ltiInferred{\text{r}}}%
                                                                             {\ltiInferred{\ltiFn{\text{OptionVisitor[s,r]}}{\text{r}}}}%
                                                                             {\text{v}}%
                                                                             {\text{v.caseNone()}}}}}}$ *)
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}{\text{Option[s]}}}%
                                 {}$
         {match = $\ltiufunelab{\ltiInferred{\text{c1}}}%
                               {\text{v}}%
                               {\text{v.caseNone()}}$}
(* fully annotated *)
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}%
                                        {\text{Option[s]}}}%
                                 {}$
         {match = $\ltifuntparaminterface{\ltiInferred{\text{r}}}%
                                         {\ltiInferred{\ltiFn{\text{OptionVisitor[s,r]}}{\text{r}}}}%
                                         {\text{v}}%
                                         {\text{v.caseNone()}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltiufun{\text{v}}{\text{v.caseSome(y)}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} = \ltiClosureCacheEntry{\text{c1}}{\ltiClosure{\ltiEnvConcat{\text{t}}{\hastype{\text{y}}{\text{t}}}}{\ltiNotInferred{\ltifuntparaminterface{\ltiInferred{\text{r}}}{\ltiInferred{\ltiFn{\text{OptionVisitor[t,r]}}{\text{r}}}}{\text{v}}{\text{v.caseSome(y)}}}}}}$ *)
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltiufunelab{\ltiInferred{\text{c1}}}{\text{v}}{\text{v.caseSome(y)}}$}
(* fully annotated *)
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltifuntparaminterface{\ltiInferred{\text{r}}}{\ltiInferred{\ltiFn{\text{OptionVisitor[t,r]}}{\text{r}}}}{\text{v}}{\text{v.caseSome(y)}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match({caseNone = $\ltiufun{}{\text{None()}}$,
                 caseSome = $\ltiufun{\text{y}}{\text{Some(f(y))}}$})
(* SC annotated *)
(* $\ltiInferred{\ltiEnv{} = {\ltiEnvConcat{\text{c}}{\ltiEnvConcat{\text{d}}{\ltiEnvConcat{\hastype{\text{f}}{\ltiFn{\text{c}}{\text{d}}}}{\hastype{\text{x}}{\text{Option[c]}}}}}}}$ *)
(* $\ltiInferred{\ltiClosureCache{} =}$
     $\ltiInferred{\ltiClosureCacheEntry{\text{c1}}{\ltiClosure{\ltiEnv{}}{\ltiNotInferred{\ltifuninterface{\ltiInferred{\ltiFn{}{\ltilstOption{\ltiBot}}}}{}{\text{None[\ltiInferred{\ltiBot}]()}}}}}}$,
     $\ltiInferred{\ltiClosureCacheEntry{\text{c2}}{\ltiClosure{\ltiEnv{}}{\ltiNotInferred{\ltifuninterface{\ltiInferred{\ltiFn{\text{c}}{\ltilstOption{\text{d}}}}}{\text{y}}{\text{Some[\ltiInferred{\text{d}}](f(y))}}}}}}$
*)
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match[$\ltiInferred{\text{d}}$]({caseNone = $\ltiufunelab{\ltiInferred{\text{c1}}}{}{\text{None()}}$,
                    caseSome = $\ltiufunelab{\ltiInferred{\text{c2}}}{\text{y}}{\text{Some(f(y))}}$})
(* fully annotated *)
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match[$\ltiInferred{\text{d}}$]({caseNone = $\ltifuninterface{\ltiInferred{\ltiFn{}{\ltilstOption{\ltiBot}}}}{}{\text{None[\ltiInferred{\ltiBot}]()}}$,
                    caseSome = $\ltifuninterface{\ltiInferred{\ltiFn{\text{c}}{\ltilstOption{\text{d}}}}}{\text{y}}{\text{Some[\ltiInferred{\text{d}}](f(y))}}$})
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
map($\ltiufun{\text{y}}{\text{1+y}}$, Some(42))
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}%
                                                         {\text{y}}%
                                                         {\text{1+y}}}}}}$ *)
map[$\ltiInferred{\text{Int, Int}}$]($\ltiufunelab{\ltiInferred{\text{c1}}}{\text{y}}{\text{1+y}}$, Some[$\ltiInferred{\text{Int}}$](42))
(* fully annotated *)
map[$\ltiInferred{\text{Int, Int}}$]($\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}{\text{y}}{\text{1+y}}$, Some[$\ltiInferred{\text{Int}}$](42))
\end{lstlisting}
}



{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
id = $\ltifuntparaminterface{\text{a}}{\ltiFn{\text{a}}{\text{a}}}{\text{x}}{\text{x}}$

let app = $\ltiufun{\text{f},\text{x}}{\ltiapp{\text{f}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\ltiPoly{\text{a}}{\ltiFn{\text{a}}{\text{a}}},\text{Int}}%
                                                                             {\text{Int}}}}%
                                                         {\text{f,x}}%
                                                         {\ltiappinst{\text{f}}{\ltiInferred{\text{Int}}}{\text{x}}}}}}}$ *)
let app = $\ltiufunelab{\text{c1}}{\text{f},\text{x}}{\ltiapp{\text{f}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
(* Fully annotated *)
let app = $\ltifuninterface{\ltiInferred{\ltiFn{\ltiPoly{\text{a}}{\ltiFn{\text{a}}{\text{a}}},\text{Int}}%
                                               {\text{Int}}}}%
                           {\text{f},\text{x}}%
                           {\ltiappinst{\text{f}}{\ltiInferred{\text{Int}}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
\end{lstlisting}
}

%\subsection{Symbolic closure Metatheory}
%
%\begin{lemma}[Subtyping (External Language)]
%   \ltiSdsubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
%    iff
%   \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
%\end{lemma}
%
%\begin{lemma}[Soundness (External Language)]
%  If \ltitSdjudgement{\ltiEnv{}}
%                     {\ltiE{}}
%                     {\ltiT{}}
%                     {\ltiEp{}}
%                     and
%                     \ltiSdsubtypeseen{\varnothing}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
%                     then
%    \ltitjudgement{\ltiEnv{}}
%                  {\ltiEp{}}
%                  {\ltiS{}}
%                  {\ltiEpp{}}
%\end{lemma}
%
%\begin{lemma}[Completeness (External Language)]
%  If \ltitjudgement{\ltiEnv{}}
%                   {\ltiE{}}
%                   {\ltiT{}}
%                   {\ltiEp{}}
%                  then
%  \ltitSdjudgement{\ltiEnv{}}
%                     {\ltiE{}}
%                     {\ltiT{}}
%                     {\ltiEp{}}
%\end{lemma}
%
%\begin{lemma}[Soundness (Symbolic Closure Language)]
%  If there exists some fuel \ltiFuel{} such that
%    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
%                      {\ltiEnv{}}
%                      {\ltiE{1}}
%                      {\ltiT{}}
%                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
%                      {\ltiE{2}},
%                      then
%    \ltitSdjudgement{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}
%                    {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{2}}}
%                    {\ltiS{}}
%                    {\ltiEp{}}
%                    such that
%                      \ltiisubtype{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}{\ltiS{}}{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}.
%\end{lemma}
%
%\begin{lemma}[Completeness 1 (Symbolic Closure Language)]
%  If \ltitSdjudgement{\ltiEnv{}}
%                     {\ltiE{}}
%                     {\ltiT{}}
%                     {\ltiEp{}}
%                     then
%    either
%    and fuel \ltiFuel{}
%    such that
%    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
%                      {\ltiEnv{}}
%                      {\ltiF{}}
%                      {\ltiT{}}
%                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
%                      {\ltiFp{}}.
%\end{lemma}
%
%% TODO timeout rules for type system
%% TODO 
%\begin{lemma}[Completeness 2 (Symbolic Closure Language)]
%  If \ltitSdjudgement{\ltiEnv{}}
%                     {\ltiE{}}
%                     {\ltiT{}}
%                     {\ltiEp{}}
%                     then
%    there exists a term \ltiF{} such that \ltiE{} is a partial erasure of \ltiF{}
%    and fuel \ltiFuel{}
%    such that
%    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
%                      {\ltiEnv{}}
%                      {\ltiF{}}
%                      {\ltiT{}}
%                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
%                      {\ltiFp{}}.
%\end{lemma}

%\input{symbolic-extended}
%\input{colored}

% - Solution
%   - extend colored LTI with directed inference
%   - introduce constrained types
%   - derive data flow from (variances of) polymorphic variable occurrences 
%   - simple example
%     - (identity 1)
%     - demonstrate how this is checked with colored LTI
%     - compare to directed LTI:
%       - 2/----v
%         [x -> x]  Int
%          ^--------/1
%
%         1. Int flows to contravariant position
%         2. contravariant position flows to covariant position (because it's on the other side of ->)
%       - no loop, because variables not under different numbers of function types
%         - (we don't know the precise rule yet)
%   - complex example
% - Constraints
%   - advantages over colored LTI
%     - aids symbolic analysis
%       - because we derive potential dataflows, we don't need to over-approximate,
%         and thus trigger unneeded symbolic analysis
%         - which might then fail because of not enough contextual information
%   - disadvantages over colored LTI
%     - significant deviation from LTI
%       - constrained types
%       - aggressive local inference based on data flows
%     - not obvious how to prove soundness
%   - infinite loops
%     - how to manage cycles in inferred data flow 
%   - constraint solving
%     - constrained types
%       - literature (see symb.tex)
%   - flow diagrams
%     - see symb.tex
%   - relationship to colored LTI model
%     - see symb.tex
%   - related work
%     - ML_sub
%     - see: symb.tex
% - investigate implications 
%   - Remy ICFP '05
%     - (seems to) propagate information simultaneously in both directions like CLTI
%     - intro prose does a nice job explaining ML moving towards System F & challenges
%   - Joe B Wells 1994
%     - explains Church vs Curry style System F formulations
%     - some mentions of decidable fragments of System F
%   - Boxy types, ICFP '06
%     - explains higher-rank types
%       - types with forall quantifiers nested inside function types
%     - explains impredicativity
%       - being allowed to instantiate a type variable with a polytype (polymorphic type)
%     - explains "local type inference"
%       - a partial inference technique for a language with bounded, impredicative quantification,
%         and higher-rank types.
%     - explains "CLTI"
%       - reformulated bidirectional checking for F_sub so that the _type_ and not the _judgment form_
%         describes the direction in which type information flows
%     - CLTI's colors inspired their "boxy" types
%       - they outline differences in related work

%\chapter{Custom Typing rules}
%\label{chapter:symbolic:custom-rules}

% - Solution
%   - allow users to provide custom typing rules
%   - 
% - Constraints
%   - wildcard type from colored LTI useful
%   - custom error messages
%     - propagation via expected types
%       - outer-most wins
%   - using clojure.spec to conform/unform
%     - to rip apart and put syntax back together
%     - more robust than manual parsing
%   - differences with Turnstile
%     - in Turnstile, the macro *is* the rule
%       - here, we separate the two
%       - we preserve the macro call until evaluation
%       - use the typing rule to expand "under" the macro as many times as we want
%         - can do this 0-n times, thus compatible with directed LTI & symbolic analysis

%\include{hm-comparison}
