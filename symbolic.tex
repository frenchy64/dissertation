\chapter{Background}

As is inevitable for an optional type system, there are many
Clojure programs that Typed Clojure was not designed to type check.
These programs contain Clojure idioms that are often either intentionally
not supported by Typed Clojure's initial design, or 
were introduced to Clojure at a later date.
Regardless, programmers will inevitably want to use these features 
in their Typed Clojure programs---but crucially without breaking
support for existing idioms.
In this part, we explore what kinds of idioms are missing
support in Typed Clojure, and propose solutions in the form of
backwards-compatible extensions.

As we discussed in \partref{part:types}, Typed Clojure's initial
design is strongly influenced by Typed Racket. In particular,
Typed Clojure's static semantics of
combinining local type inference and occurrence typing
to check fully-expanded code
comes directly from Typed Racket.
This shared base is appropriate, given the similarities between
the base Clojure and Racket languages.
It is also effective, seamlessly handling many control flow
idioms, capturing many polymorphic idioms, and often yielding
predictable type error messages.
However, there are important tradeoffs to consider in this design---in the following
sections we introduce them and propose extensions to attempt to nullify
their downsides.

\section{Enhancing Local Type Inference}

``Local Type Inference''~\cite{PierceLTI} refers to the combination of
bidirectional type propagation 
specific approach
to partial type inference for languages with subtyping and impredicative
polymorphism.
``Partial type inference'' here is
problem of inferring 
(Pfenning~\cite{Pfenning1988partial} describes the distinction more thoroughly).

Concerning the limitations of local type inference,
Hosoya and Pierce~\cite{hosoya1999good}
isolate two drawbacks.
The first is dealing with ``hard-to-synthesize arguments''.
To understand this, we must appreciate a key ingredient of local type inference
called \emph{bidirectional propagation}, which 
we use the example of type checking \clj{(inc 42)} to demonstrate.
If we have already checked \clj{inc} to have type \clj{[Int -> Int]}, we
now have a choice of how to check the argument \clj{42} is an \clj{Int}.
The first is to ascribe an expected type to \clj{42} of \clj{Int}
and rely on
bidirectional \emph{checking mode} to ensure \clj{42} has the correct type
once we check it.
The second is to infer the type of \clj{42} (without an expected type) using 
bidirectional \emph{synthesis mode}, and then ensure the inferred type
is compatible with \clj{Int} after the fact.
A useful analogy in terms of expressions is that checking mode propagates
information outside-in, and synthesis mode propagates inside-out.
A similar analogy in terms of a type derivation tree (that grows upwards)
relates checking and synthesis modes to information being passed
up and down the tree, respectively.

To best serve the purposes of local type inference, it is crucial to stay in
bidirectional \emph{checking} mode as much as possible.
The ``hard-to-synthesize arguments'' problem occurs when type argument
inference interferes with the ability to stay in checking mode, and
thus forces the bidirectional propagator into synthesis mode
for arguments that require checking mode.
For example, to type check

\clj{(map (fn [x] (inc x)) [1 2 3])},

where \clj{map} has type

\clj{(All [a b] [[a -> b] (Seqable a) -> (Seqable b)])},

we use type argument inference to determine how to instantiate type variables \clj{a}
and \clj{b} based on \clj{map}'s arguments.
Unfortunately, 
to answer this question,
the naive local type inference algorithm~\cite{PierceLTI}
uses synthesis mode to retrieve the argument types,
and so checks \clj{(fn [x] (inc x))} in synthesis mode.
No information is propagated about the type of \clj{x},
so this expression will fail to type check, demonstrating
why functions are hard-to-synthesize.

The second drawback noted by Hosoya and Pierce are
cases where there is no ``best'' type argument to infer.
This occurs when there is not enough information available
to determine how to instantiate a type such that the program
has the best chance of type checking, and so it must be guessed.
A representative case where this occurs is inferring the
type of a reference from just its instantiation, such
that optimal types are given to reads and writes.
For example, the following code creates a Clojure Atom
(a reference type) with initial value \clj{nil}, writes
\clj{0} to the Atom, and then increments the Atom's value.

{
\begin{cljlisting}
(let [r (atom nil)]
  (reset! r 0)
  (inc @r))
\end{cljlisting}
}

What type should \clj{r} be assigned? From its initial binding,
\clj{(Atom nil)} seems appropriate, but the subsequent write
would fail. Alternatively, assigning \clj{(Atom Any)} would
allow the write to succeed, but the the final read would fail
because it expects \clj{Int}.
This demonstrates difficulties of the ``no-best-type-argument'' problem.

Hosoya and Pierce report unsatisfactory results in their attempts to
fix these issues, in both the effectiveness and complexity
in their solutions.
They speculate that these difficulties might be better 
addressed at the language-design level---rather than algorithmically---in ways that
keep the bidirectional propagator in checking mode.
For the ``no-best-type-argument'' problem,
we agree with this assessment, since
addressing the problem mostly amounts to annotating 
all reference constructors.
To this end,
Typed Clojure offers several
wrappers for common functions where this problem
is common---the previous example might use the ``typed''
constructor
\clj{(t/atom :- (U nil Int), nil)}.
However, the ``hard-to-synthesize arguments'' problem
is a deeper and more pervasive issue when checking Clojure code.
We don't have the luxury, desire, nor do we think it would be particularly
successful to introduce new core idioms to Clojure,
and so we attempt to solve the this problem algorithmically.

%\begin{cljlisting}
%(for [i (range 100)]
%  (map (fn [j] (inc j))
%       (range i)))
%\end{cljlisting}

Hosoya and Pierce outline the two main challenges that must be
addressed to solve the ``hard-to-synthesize arguments'' problem.
First, we must provide a strategy for identifying which arguments 
should be avoided.
For instance,
they provide a simple grammar for identifying hard-to-synthesize arguments,
which includes (for Standard ML) unannotated functions and unqualified constructors.
Second, an alternative (probably more complicated) algorithm
for inferring type arguments is needed that also handles
avoided arguments.
Their experiments show that the naive approach does not suffice,
and hint at the delicate handling needed to effectively maximize or minimize
instantiated types to stay in checking mode.
We will now use these challenges as a presentational framework to outline our own approach.

In our experience, the most common hard-to-synthesize expression in Clojure code
is the function.
Clojure's large standard library of higher-order functions and encouragement
of functional programming result in many usages of anonymous functions, which almost
always require annotations to check with Typed Clojure.
So, to answer Hosoya and Pierce's first challenge, 
we avoid checking hard-to-synthesize function expressions by
introducing a new function type: a \emph{symbolic closure type}.
A symbolic closure does not immediately check the function body. Instead,
the function's code along with its local type context is saved
until enough information is available to check
the function body in checking mode.
We present more details about symbolic closures in \chapref{chapter:symbolic:symbolic-closures}.

Now that we have delayed the checking of hard-to-check arguments,
Hosoya and Pierce's second challenge calls for an enhanced
type argument reconstruction algorithm to soundly handle
them.
Our investigation led us to create \emph{directed local type inference}
(\chapref{chapter:symbolic:directed-lti}),
which determines the possible data flows through a polymorphic function
by noting the positions of type variable occurrences, and attempts to
use this information to check its arguments in an optimal order for remaining
in bidirectional checking mode.

%\section{Custom typing rules}
%
%Besides local type inference,
%another significant feature inherited from Typed Racket is that
%code is fully expanded before checking.
%This unfortunately means that macros with complex expansions
%are often uncheckable, and display cryptic error messages when attempting
%to do so.
%We investigate providing the user with \emph{custom typing rules} (\chapref{chapter:symbolic:custom-rules})
%as an extension point to customize how to type check a macro before
%it is expanded.
%As discussed in 
%\partref{part:implementations}, Typed Clojure's initial design does
%not support custom typing rules, so we exploit the infrastructure
%discussed there,
%and present our investigation into the user interface for the rules in
%\chapref{chapter:symbolic:custom-rules}.

% - "Avoiding hard-to-synthesize arguments"
%   1. need mechanism to decide which arguments to avoid
%   2. more complicated scheme for determining best type arguments

% - Problem
%   - many common idioms cannot be checked
%   - limitations of local type inference
%   - made harder by occurrence typing
%   - want general solutions available to all users
%   - preliminary investigation of several techniques
% - Possible solutions
%   - symbolic analysis
%     - symbolic closures
%       - deal with "obvious" local function annotations
%     - inlining
%   - directed local type inference
%     - derive data flow from polymorphic types for more aggressive local type variable inference
%   - custom typing rules
%     - interface for describing how to check an unexpanded macro call
%       - or complex functions
%     - custom errors
% - Constraints
%   - some speculation of how well they compose together
%   - small models without rigorous proofs
%   - case studies with real Clojure idioms

\chapter{Delayed checking for Unannotated Local Functions}
\label{chapter:symbolic:symbolic-closures}

Using bidirectional type checking, functions are hard-to-synthesize types for.
Put another way, to check a function body successfully using only locally available information,
types for its parameters are needed upfront.
For top-level function definitions, this is not a problem in many
optional type systems since top-level annotations would be provided
for each function.
However, for anonymous functions it's a different story.
The original local type inference algorithm~\cite{PierceLTI}
lacks a synthesis rule for unannotated functions, instead relying on bidirectional
propagation of types,
but due to the prevalence
of hard-to-synthesize anonymous functions in languages like JavaScript, Racket, and Clojure,
optional type systems for the languages add their own rules.

Typed Racket and Typed Clojure implement a simple but sound strategy
to check unannotated functions. The body of the function is checked
in a type context where its parameters are of type \clj{Any},
the \texttt{Top} type.
This helps check functions that don't use their arguments, or only
use them in positions that require type \clj{Any}.
For example, both \clj{(fn [x] "a")} and \clj{(fn [x] (str "x: " x))} 
synthesize to \clj{[Any -> String]} in Typed Clojure.
The downsides to this strategy are that unannotated functions are never
inferred as polymorphic, and functions that use their arguments
at types more specific than \clj{Any} are common.

TypeScript~\cite{typescript}, an optional type system for JavaScript,
takes a similar approach, but instead of annotating parameters with
TypeScript's least permissive type called \js{unknown},
by default it assigns parameters the unsound dynamic type \js{any}.
In TypeScript, \js{any} can be implicitly cast to any other type,
so the type checker will (unsoundly) allow any usage of unannotated arguments.
If this behavior is unsatisfactory,
the \js{noImplicitAny} flag removes special handling for unannotated
functions altogether, and TypeScript will demand explicit annotations for all arguments.

In this chapter, we present an alternative approach to checking unannotated functions
based on the insight that a function's body need only be type checked if and when it is called.
For example, the program \clj{(fn [x] (inc x))} cannot throw a runtime error because
the function is never called, and so a type system may soundly treat the function body as unreachable code.
On the other hand, wrapping the same program in the invocation
\clj{((fn [x] (inc x)) nil)}
makes the runtime error possible, and so a sound static type system must flag the error.

Exploiting this insight in the context of a bidirectional type checker using
local type inference requires many considerations.
First, we must decide in which situations is it desirable to delay checking a function.
Second, we must identify the information that must be saved in order to delay checking a function,
and then choose a suitable format for packaging that information.
Third, we must identify how a function is deemed ``reachable'',
and then which component of the type system is responsible for checking a function body.
Fourth, it is desirable to identify and handle the ways in which 
infinite loops are possible, such as the checking of a delayed function triggering
another delayed function to check, which triggers another delayed check, ad nauseam.
Fifth, we must determine how delayed functions interact with polymorphic types
during type argument reconstruction.

We address all these considerations in the following sections, except
for the final one, which we delegate to \chapref{chapter:symbolic:directed-lti}.

\section{Overview}
\label{symbolic:section:overview}

In this section, we explore some of the implications that come with delayed checks for local functions,
by example.
We avoid any use of polymorphic functions
(we isolate those issues in \chapref{chapter:symbolic:directed-lti})
and demonstrate the tradeoffs with just non-recursive monomorphic functions.

First, let \clj{inc} be of type \clj{[Int -> Int]}.
The following, then, is well typed because \clj{1} is an \clj{Int}.

\begin{cljlisting}
(inc 1)
\end{cljlisting}

Using the standard bidirectional application type rule, \clj{inc} is checked first,
followed by \clj{1}.
However, eta-expanding the operator does not behave as nicely.

\begin{cljlisting}
((fn [x] (inc x)) 1)
\end{cljlisting}

Like usual, the standard application rule checks the function first.
However, there is no annotation for \clj{x}, so the function body will fail
to check.
This is unfortunate, especially in a type system that claims to be ``bidirectional'',
since the information that \clj{x} is an \clj{Int} is adjacent to the function
in the form of an argument.
One strategy to alleviate this problem is to always check arguments first~\cite{xie2018let}.
However, that nullifies the ability for the operator to propagate information
to its arguments, whose advantages are exploited to good effect in Colored Local Type Inference~\cite{coloredlti01}

We combine both flavors by keeping the standard operator-first checking order
but delay the checking of unannotated functions.
Then, an additional application rule handles applications of
unannotated functions to force their checking.
So in this case, the checking of \clj{(inc x)}
is delayed until the argument \clj{1} is inferred as \clj{Int},
after which this information is used to check \clj{(inc x)}
in the extended type context where \clj{x : Int}.

We could imagine hard-coding a type rule that manually delays
direct applications of unannotated functions until after checking
its arguments.
However, that does not generalize to more complicated examples.
Take the following illustrative code, identical the previous
example, except the function is let-bound as \clj{f}.

{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (fn [x] (inc x))](*@\label{symbolic:example:let-bound:def-f}@*)
  (f 1))(*@\label{symbolic:example:let-bound:app-f}@*)
\end{cljlisting}
}

Instead of following the brittle strategy of creating yet-another special rule to delay checking
let-bound functions, we generalize the idea.
We make a delayed function check a first-class concept in our type-system by
creating a new type for it.
Roughly, \clj{f} would have a delayed function type---introduced by
a type rule for unannotated functions---and \clj{(f 1)}
would force a check for the delayed function---by an application
rule that handles delayed function \emph{types} (not syntax-driven).

Now we must decide what a delayed function type consists of.
Clearly, the \emph{code} of the function must be preserved until
it is checked, otherwise the application rule would have nothing
to work with.
We note that our static semantics of saving
the code of a function to check later
is analogous to the runtime strategy of
evaluating a function as \emph{closure},
and using beta-reduction to extract the original
function from the closure and apply it to its arguments.

The trick in maintaining lexical scope during beta-reduction for closures
is to apply the function under the \emph{function definition's}
environment, instead of the application site's.
For example,
\figref{symbolic:example:closure-red}
evaluates
to \clj{2}
because
the occurrence of
\clj{y} on line \ref{symbolic:example:closure-red:y-usage}
is bound to \clj{1} by line \ref{symbolic:example:closure-red:y-def-site}.
If we used the local environment at the application site (line \ref{symbolic:example:closure-red:f-app}),
\clj{y} would be bound on line \ref{symbolic:example:closure-red:y-app-site}
to \clj{nil},
and would throw a runtime error.

% must save type context
\begin{figure}
{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (let [y 1](*@\label{symbolic:example:closure-red:y-def-site}@*)
          (fn [x] (+ x y)))](*@\label{symbolic:example:closure-red:y-usage}@*)
  (let [y nil](*@\label{symbolic:example:closure-red:y-app-site}@*)
    (f 1)))(*@\label{symbolic:example:closure-red:f-app}@*)
\end{cljlisting}
}
  \caption{This example evaluates to \clj{2} with lexically scoped variables.}
  \label{symbolic:example:closure-red}
\end{figure}

The crucial insight is that
the same trick applies to \emph{checking} delayed function types,
except at the \emph{type}-level.
Specifically, the occurrence of \clj{y}
on line \ref{symbolic:example:closure-red:y-usage}
must be checked as type \clj{Int} (from line \ref{symbolic:example:closure-red:y-def-site}),
and not type \clj{nil} (from line \ref{symbolic:example:closure-red:y-app-site}).
So, a delayed function type pairs a function's code with the type environment
at the function definition site.
This strongly resembles a ``type-level'' closure that is reduced symbolically,
and so we call this new type a \emph{symbolic closure}.

We can use symbolic closures to inline higher-order-function definitions.
In the following example, \clj{app} would normally need a higher-order
or polymorphic
annotation to handle the application on the final line.
Instead, with symbolic closures, type checking reduces in a few steps to simply checking
\clj{(inc x)} where \clj{x : Int}.

% more beta reduction
\begin{cljlisting}
(let [f (fn [x] (inc x))
      app (fn [g y] (g y))]
  (app f 1))
\end{cljlisting}

As alluded to in the previous section, we must identify
all type system components who are responsible for checking symbolic closures,
and ensure they perform their obligations correctly.
The following example uses a higher-order function
\clj{app-int} to increment the value \clj{1}.
Since \clj{app-int} is annotated, it will be checked
by the standard application rule.
However, its first argument will be delayed as a symbolic
closure---now we must identify who is responsible for checking it.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-int [[Int -> Int] Int -> Int])
(defn app-int [f x] (f x))
...
(app-int (fn [x] (inc x)) 1)
\end{cljlisting}

The type signature of \clj{app-int},
clearly says that its first argument may be called with an \clj{Int}.
Therefore, to maintain soundness, applications of \clj{app-int}
must ensure its first argument accepts \clj{Int}.
The standard application type rule uses subtyping to ensure
provided arguments are compatible with the formal parameter types of
the operator.
To handle symbolic closures, we preserve the standard application rule
and instead add a subtyping case for symbolic closures.

In this case, the subtyping relation would be asked to verify if
``the symbolic closure type representing \clj{(fn [x] (inc x))}
is a subtype of \clj{[Int -> Int]}''.
This can be answered by checking the symbolic closure
returns \clj{Int} when 
\clj{x} is type \clj{Int}---and so this subtyping case
delegates to checking if the symbolic closures inhabits the given type.
The subtype relationship is true if the check succeeds without type error,
otherwise it is false.

The correct ``contravariant subtyping left-of-the-arrow''
is naturally preserved.
In this case, the left-of-the-arrow check is ``\clj{Int} is a subtype of \clj{x}'s type'', and
annotating \clj{x} as \clj{Int} turns this statement into the reflexively true ``\clj{Int} is a subtype of \clj{Int}''.
At a glance, it may seem that we are wasting the benefits
of this contravariant rule---after all, it enables \clj{x} to be \emph{any} supertype of
\clj{Int}, such as \clj{Num} or even \clj{Any}.
However, it is in our interest to propagate the most precise parameter types
so then function bodies have the best chance to check without error.
Since symbolic closures are designed to support rechecking their bodies at different argument types,
a symbolic function can simply be rechecked with the less-precise types
when it comes time to broaden its domain.

This scheme extends to subtyping with arbitrarily-nested function types.
To demonstrate nesting to the right of an arrow,
the following code sums 1 with itself via
\clj{curried-app-int}, which accepts a curried
function of two arguments \clj{f} and a number \clj{x}, and 
provides \clj{x} as both arguments to \clj{f}.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann curried-app-int [[Int -> [Int -> Int]] Int -> Int])
(defn curried-app-int [f x] ((f x) x))
...
(curried-app-int (fn [y] (fn [x] (+ x y))) 1)
\end{cljlisting}

The standard application rule will ensure 
``the symbolic closure of \clj{(fn [y] (fn [x] (+ x y)))}
is a subtype of
\clj{[Int -> [Int -> Int]]}'', which involves assuming
\clj{y : Int} and then checking the \emph{code} \clj{(fn [x] (+ x y))}
at type \clj{[Int -> Int]}---which just uses the standard
function rule.

To demonstrate nesting to the left of an arrow,
\clj{app-inc} again computes \clj{(inc 1)}
in an even more convoluted way with \clj{app-inc}---by accepting a function
\clj{f} that it passes both \clj{inc} and its second argument to.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-inc [[[Int -> Int] Int -> Int] Int -> Int])
(defn app-inc [f x] (f inc x))
...
(app-inc (fn [g y] (g y)) 1)
\end{cljlisting}

Importantly, \clj{app-inc}'s first argument has a function
type to the left on an arrow, in particular \clj{[Int -> Int]}.
Under these conditions, subtyping asserts that ``the symbolic
closure \clj{(fn [g y] (g y))} is a subtype of \clj{[[Int -> Int] Int -> Int]}''
by assuming \clj{g : [Int -> Int]} and \clj{y : Int} and
verifying that \clj{(g y)} checks as \clj{Int}---which is almost immediate by
the standard application rule.

We leverage some syntactic restrictions
to avoid the need for further subtyping cases for symbolic closures.
First, symbolic closures cannot be annotated by the programmer,
and can only be introduced by the ``unannotated function'' typing rule.
Second (as discussed in \secref{analyzer:extensibility:side-effects}),
top-level variables are not allowed to inherit the types of their initial
values, and must be explicitly annotated.
These restrictions ensure symbolic closures both cannot occur to the
left of an arrow type, and 
cannot propagate beyond the top-level form it was defined in.
%This stretches the metaphor of ``local'' type inference
%beyond just a single tree walk using
%bidirectional propagation,

\subsection{Performance and error messages}

% FIXME need to be more precise about "undecidable". What problem are
% we deciding? See Wells '94 for some details. I think so far I
% mean "type checking always terminates (conservatively)"

While useful, allowing the type system to perform beta-reduction
requires careful planning: type checking time is now proportional 
to the running time of the program!
Unsurprisingly, this makes type checking with a naive implementation of symbolic
closures undecidable.
Without intervention,
the next program (an infinite loop using the y-combinator that computes \clj{(inc (inc (inc ...)))})
would send the \emph{type system} into an infinite loop.

%TODO much simpler example: ((fn [x] (x x)) (fn [x] (x x)))

% infinite loops
\begin{cljlisting}
(let [Y (fn [f]
          ((fn [g] (fn [x] (f (g g) x)))
           (fn [g] (fn [x] (f (g g) x)))))]
  (let [compute (Y (fn [f x] (inc (f x))))]
    (compute 1)))
\end{cljlisting}

To prevent such loops, we limit the number of symbolic reductions
done at type-checking time.
As a conservative solution to the halting
problem, this limit will prematurely halt some programs that would
otherwise fully reduce in a finite number of steps.
For example, if we set the reduction limit to 5\ in
the following code,
during the 6th reduction of \clj{f} the type system will
throw an error.

% premature halting
\begin{cljlisting}
(let [f (fn [x] x)]
  (f (f (f (f (f (f 1)))))))
\end{cljlisting}

In simple cases like these, the error message 
can guide the user to fixing the error.
For example, the type system would suggest 
annotating \clj{f} as \clj{[Int -> Int]} (by collecting
argument and return types as the program is reduced),
which would cause the program to check successfully
under the same conditions.
For cases with more heterogeneous argument and return types---like the y-combinator---the 
error message would just note which function caused
the reduction quota to be depleted.

As Wells~\cite{wells1994typability} remarks,
stopgap measures such as this to circumvent undecidable
type inference algorithms negatively affect
program portability.
For example, a different reduction limit may cause
a program to fail to type check that otherwise type checked
in a previous version.
We hope to learn reasonable defaults for the reduction limit
by experience.

%Note that using the type checker to decide subtyping
%has unfortunate implications for 
%the aforementioned annotation suggestions
%for reduction-limit error messages.
%An ``obviously-failing'' subtyping check might trigger a
%check for irrelevant arguments, and then provide them to the user.
%A curious aside: if symbolic closures are identified just by their code and definition
%type environments, suggestions may also be merged for functions with
%identical code and scope.

% TODO performance
% - undecidable 
%   - heuristics needed to halt search
%   - type checking time proportional to running time of program
% - for finitely running programs:
%   - degenerate case checking time complexity becomes at least exponential time in the size of the program because we can recheck a function
%     body multiple times, and a symbolic closure can be duplicated
%
% eg. (let [pair (fn [f g] (f (g) (g)))] (pair (fn [x y] (+ x y)) (fn [] 1)))
% - (fn [] 1) is checked twice
%   - can "stack" these recheckings, worst case is infinite
% - Damas-Milner algorithm checks a function definition once to determine its principle type scheme
%   - exponential time & space
%     - because principle type schemes can become very large
%     - also exponential time to print a type
%     - symbolic closures are also exponential time to print a type (naively)
%       since they can be duplicated
%       - I think these are similar reasons to Milner's algorithm

% do we need a story for runtime casting from Any to [Int -> Int]?
%\begin{cljlisting}
%(ann dynapp-int [Any Int -> Int])
%...
%(dynapp-int (fn [x] (inc x)) 1)
%\end{cljlisting}

% no idea what to do with negation function types 
%\begin{cljlisting}
%(ann app-int [(U [Int -> Int] (I Any (Not [Int -> Int]))) Int -> Int])
%...
%(app-int (fn [x] (inc x)) 1)
%\end{cljlisting}


\section{Formal model}

We formalize a restriction of symbolic closure types by defining an explicitly typed internal language,
providing an external languages that can omit annotations,
and formulating a type inference algorithm based on symbolic closures to recover omitted annotations.
This approach is similar to Local Type Inference~\cite{PierceLTI}
and Colored Local Type Inference~\cite{coloredlti01},
except where they utilize bidirectional type propagation to locally determine function parameter types,
we instead use symbolic closures to propagate type information
(since we have a synthesis rule for functions).

\subsection{Internal Language}

\begin{figure}[h]
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifuntparamargtype{\ova{\ltitvar{}}}
                                             {\ltivar{}}
                                             {\ltiT{}}
                                             {\ltiE{}}
                         \alt
                         \ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ova{\ltivar{} = \ltiE{}}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltitvar{} 
                         \alt
                         \ltiTop
                         \alt
                         \ltiBot
                         \alt \ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiT{}}
                         \alt
                         \ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}
                      &\mbox{Types} \\
  \ltiEnv{} &::=& \ltiEmptyEnv \alt
                  \ltiEnvConcat{\ltiEnv{}}{\hastype{\ltivar{}}{\ltiT{}}} \alt
                  \ltiEnvConcat{\ltiEnv{}}{\ltitvar{}}
                      &\mbox{Type Environments} \\
\end{array}
$$
\caption{Internal Language Syntax}
\label{symbolic:figure:internal-language}
\end{figure}

Our internal language is based on System \ltiFsub extended with records, and is functionally identical
to that used to model Colored Local Type Inference~\cite{coloredlti01}, except
our lambda terms require full (return) type annotations.
\figref{symbolic:figure:internal-language} shows the syntax
for the internal language.
Terms \ltiE{} and \ltiF{} range over 
variables \ltivar{},
explicitly typed polymorphic functions
                         \ltifuntparaminterface{\ova{\ltitvar{}}}
                                               {\ltiFn{\ltiT{}}{\ltiS{}}}
                                               {\ltivar{}}
                                               {\ltiE{}},
(where the entire function is of type \ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}}, its \emph{interface}),
function application
with explicit type arguments
\ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}},
record selectors
\ltisel{\ltiE{}}{\ltivar{}},
and record constructors
\ltiRec{\ova{\ltivar{} = \ltiE{}}}.
Types \ltiT{}, \ltiS{}, and \ltiR{} are 
type variables \ltitvar{},
top type \ltiTop,
bottom type \ltiBot,
polymorphic types \ltiPoly{\ova{\ltitvar{}}}{\ltiT{}},
record types \ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}},
and function types
\ltiFn{\ltiT{}}{\ltiS{}}.
Type environments \ltiEnv{}
consist of 
the empty environment
\ltiEmptyEnv,
variable types
\hastype{\ltivar{}}{\ltiT{}},
type variables 
\ltitvar{},
and concatenation
\ltiEnvConcat{\ltiEnv{}}{\ltiEnvp{}}.

We assume term and type variables bound in separate places in the same term are distinct,
and treat terms and types that are equal up to alpha-renaming as equivalent.
Record terms and types have unordered fields.

\begin{figure}
  \begin{mathpar}

    \boxed{
    \infer[]
    {
      \ltitjudgementNoElab{\ltiEnv{}}{\ltiE{}}{\ltiT{}}
      \\\\
      \text{\ltiE{} is of type \ltiT{}
      }
      \\\\
      \text{ in context \ltiEnv{}.}
                 }
                 {}
                 }

    \infer [\ltiIVar]
    {}
    {
    \ltitjudgementNoElab
                    {\ltiEnv{}}
                    {\ltivar{}}
                    {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [\ltiISel]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{i}}{\ltiT{i}} , ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [\ltiISelBot]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiBot}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [\ltiIAbs]
    { 
    \ltitjudgementNoElab{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{}}}}}
                  {\ltiE{}}
                  {\ltiS{}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                   {\ltiT{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}}}
                 }
                 \ \ \ \
%
    \infer [\ltiIAppInst]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    \\\\
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiTp{}}
                  \\
                  \ltiisubtype{\ltiEnv{}}{\ltiTp{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
    }
    {
      \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiappinst{\ltiF{}}
                                {\ova{\ltiR{}}}
                                {\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
    }
                 \ \ \ \
%
    \infer [\ltiIAppInstBot]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
                  \\\\
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}}}
                  {\ltiBot{}}
    }
                 \ \ \ \
%
    \infer [\ltiIRec]
    {
    \overrightarrow{
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiT{}}
                  }
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiRec{\ova{\ltivar{} = \ltiE{}}}}
                  {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
    }

  \end{mathpar}
  \caption{Internal language type system
  }
  \label{symbolic:figure:internal-language-type-system}
\end{figure}

\figref{symbolic:figure:internal-language-type-system}
presents the type system for the internal language
\ltitjudgementNoElab{\ltiEnv{}}{\ltiE{}}{\ltiT{}},
pronounced ``\ltiE{} is of type \ltiT{} in context \ltiEnv{}.''
\ltiIVar is the normal variable lookup rule.
\ltiISel selects a field already present in a record.
\ltiISelBot allows selecting fields from \ltiBot.
\ltiIAbs checks a function definition at its annotated type.
\ltiIAppInst checks a function application with explicit type arguments.
\ltiIAppInstBot allows applying operators of type \ltiBot.
\ltiIRec checks record constructors.

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
      \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
      \\\\
      \text{\ltiT{} is a subtype of \ltiS{}.
      }
                 }
                 }

    \infer [\ltiSTVar]
    {}
    {
    \ltiisubtype{\ltiEnv{}}{\ltitvar{}}{\ltitvar{}}
    }

    \infer [\ltiSTop]
    {}
    { \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\Top}}

    \infer [\ltiSBot]
    {}
    { \ltiisubtype{\ltiEnv{}}{\Bot}{\ltiT{}}}

    \infer [\ltiSRec]
    {
    \overrightarrow{\ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}}
    }
    {
    \ltiisubtype{\ltiEnv{}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}},
                             \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}}}
    }

    \infer [\ltiSFn]
    {
          \ltiisubtype{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}
          \\
          \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}
          }
    {\ltiisubtype {\ltiEnv{}}
                     {\ltiPolyFn{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiT{}}}
                     {\ltiPolyFn{\ltiS{}}{\ova{\ltitvar{}}}{\ltiTp{}}}
                     }

  \end{mathpar}
  \caption{Internal language subtyping
  }
  \label{symbolic:figure:internal-language-subtyping}
\end{figure}

\figref{symbolic:figure:internal-language-subtyping}
presents the subtyping for the internal language
\ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiS{}}, pronounced
``\ltiT{} is a subtype of \ltiS{}.''
\ltiSTVar says type variables are subtypes of themselves.
\ltiSTop and \ltiSBot establish \ltiTop and \ltiBot as the top and
bottom of the subtyping lattice.
\ltiSRec says record types may forget or upcast their fields.
\ltiSPoly says two polymorphic types are subtypes if their
bound type variables agree and their bodies are subtypes.
\ltiSFn relates types contravariantly to the left of an arrow
and covariantly to the right.

\subsection{External language}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt \ltiufun{\ltivar{}}{\ltiE{}}
                         \alt \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms}
\end{array}
$$
\caption{External Language Syntax
  (extends \figref{symbolic:figure:internal-language})
  }
\label{symbolic:figure:external-language-syntax}
\end{figure}

The syntax for the external language
\figref{symbolic:figure:external-language-syntax}
is a superset of the internal language, with unannotated functions 
\ltiufun{\ltivar{}}{\ltiE{}},
and applications with implicit type arguments
\ltiapp{\ltiF{}}{\ltiE{}}.

\begin{figure}
  \begin{mathpar}
    \infer [\ltiEAppInf]
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    %{\ltiFp{}}
                    \\
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiSp{}}
                    %{\ltiEp{}}
                  \\
                       |\ova{\ltitvar{}}|>0
                  \\\\
                  \forall \ltiRp{}.
                    \left(
                    \begin{array}{lll}
                      \ltiisubtype{\ltiEnv{}}{\ltiSp{}}{\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                      \text{ implies }
                      %\arcr
                      \ltiisubtype{\ltiEnv{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}
                                   {\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}
                    \end{array}
                  \right)
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                    {\ltiapp{\ltiF{}}{\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    %{\ltiappinst{\ltiFp{}}
                    %            {\ova{\ltiR{}}}
                    %            {\ltiEp{}}}
    }

    \infer [\ltiEUAbs]
    { 
    \ltitjudgementNoElab{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{}}}}}
                  {\ltiE{}}
                  {\ltiS{}}
                  \\\\
              \ova{\ltitvar{}} \cap \ltitv{\ltiE{}} = \varnothing
    }
    {
    \ltitjudgementNoElab{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                 }
  \end{mathpar}

  \caption{External Language Specification (extends 
  \figref{symbolic:figure:internal-language-type-system})
  }
  \label{symbolic:figure:external-language-declarative-type-system}
\end{figure}

The external language type system is (declaratively) specified in
\figref{symbolic:figure:external-language-declarative-type-system}
as a superset of the (algorithmic) internal language.
\ltiEAppInf says we must pick the most general type arguments when elaborating
an application without explicit type arguments.
This is identical to the corresponding rule in Local Type Inference.
\ltiEUAbs says that an untyped function must type check at the interface
chosen for its elaboration.
A similar rule is included in Colored Local Type Inference, except
colored types enforce that parameter types and type parameters only be inherited
from its surrounding context.
In constrast, our rule uses an oracle to synthesize both.
This is because our type inference algorithm based on symbolic closures
is not restricted to local reasoning.

\subsection{Type Inference Algorithm}

To recover types from terms written in the external language,
we define a type inference algorithm.
The algorithm proceeds in two stages.
First, the external language term is type checked with symbolic closures,
giving an intermediate elaborated term that contains symbolic
closure terms and types.
Then, we use information gathered during type checking
to finish elaborating the term to the internal language
by replacing symbolic closures with the types they were symbolically
executed with.

In order to reliably elaborate to \ltiFsub, we model a restriction of symbolic closure types.

First, the elaborated type of a symbolic closure is chosen greedily,
when it is first symbolically executed, and each symbolic closure
must be exercised at least once to elaborate its body.
A polymorphic type may also be chosen, but the type arguments bound by
the function must also be chosen at this time.
This is for several reasons.
Most obviously, we lack
intersection types, and so have no natural way of enumerating more than one interface
type for a function, with each interface
corresponding to a symbolic execution.
Adding intersection types would require further considerations, namely
the machinery needed to annotate a function that is ascribed many interfaces is quite involved
(e.g., branching types~\cite{wells2002branching},
contextual subtyping~\cite{Dunfield2004Tridirectional},
and ``lazy'' type substitutions~\cite{polyduce1})
and obscures the (orthogonal) idea of symbolic closures, which we hope to present
in its essense.
We might also attempt to infer a single polymorphic function type that combines all interfaces,
however that is a separate problem we have not attempted.

Second, we restrict a symbolic closure to the type-variable scope in which it was defined.
Relaxing this restriction raises questions about scoping also solved by
contextual subtyping~\cite{Dunfield2004Tridirectional}.
Alternatively, we could quantify over out-of-scope variables
with a polymorphic type, but this would most likely require also
inferring type arguments for arguments~\cite{polyduce1},
which we do not cover here.

Third, we disallow a symbolic closure type to be passed to themselves.
We must fully erase symbolic closure types to elaborate to \ltiFsub,
however we do not model the equi-recursive type binders that are the 
natural encoding for such types. On the other hand, since it does not require
recursive types to elaborate, symbolic closures
be passed to \emph{other} symbolic closures, even if the former elaborates to a polymorphic
type (since \ltiFsub is impredicative, i.e., does not restrict the places a polymorphic type
may occur).

Fourth, we add a global symbolic reduction limit, called ``fuel'', to make
type inference decidable.
Since a symbolic closure may be symbolically executed an unbounded
number of times, this restriction is also useful for practical implementations
using symbolic closures.

As we will see, symbolic closures are useful even with these restrictions.

\begin{figure}
$$
\begin{array}{lrll}
%  \ltiE{}, \ltiF{} &::=& ... \alt
%                         \ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
%                                     {\ltivar{}}
%                                     {\ltiE{}}
%                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& ... \alt \ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}
                      &\mbox{Types} \\
  \ltiClosureID{} &::=& \ltitvar{}
                      &\mbox{Symbolic Closure Identifiers} \\
%  \ltiClosureElab{} &::=& \ltiClosure{\ltiEnv{}}{\ltiTop}
%                          \alt
%                          \ltiClosure{\ltiEnv{}}{\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiT{}}}
%                      &\mbox{Symbolic Closure Elaborations}
%                      \\
  \ltiFuel{} &::=& \ltinat{}
                      &\mbox{Symbolic Closure Fuel} \\
  \ltiClosureCache{} &::=& \ova{\ltiClosureCacheEntry
                                {\ltiClosureID{}}
                                {\ltiT{}}}
                      &\mbox{Symbolic Closure Cache}
                      \\
  \ltiCombinedThreadedEnv{} &::=& \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
                      &\mbox{Symbolic Closure Environments}
\end{array}
$$
\caption{Symbolic Closure Language Syntax (extends \figref{symbolic:figure:external-language-syntax})}
\label{symbolic:figure:SC-language-syntax}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed
    {
    \infer[]
    {}
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
                     \\\\
                     \text{Given symbolic closure environment \ltiCombinedThreadedEnv{}
                     and context \ltiEnv{}, term \ltiE{}
                     has type \ltiT{}
                     in environment \ltiCombinedThreadedEnvp{}.
                     }
                     }
                     }

    \begin{array}{c}
    \infer [Var]
    {}
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltivar{}}
                      {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                      {\ltiCombinedThreadedEnv{}}
                      {\ltivar{}}
                 }
\ \ \ 
    \infer [Rec]
    {
    \overrightarrowcaption{
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{i-1}}
                      {\ltiEnv{}}
                      {\ltiF{i}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnv{i}}
                      {\ltiFp{i}}
                      }^{ 1 \leq i \leq n}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{0}}
                      {\ltiEnv{}}
                      {\ltiRec{\ova{\ltivar{} = \ltiF{}}^n}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n}}
                      {\ltiCombinedThreadedEnv{n}}
                      {\ltiRec{\ova{\ltivar{} = \ltiFp{}}^n}}
    }

                 \\\\
    \infer [Sel]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},..., \hastype{\ltivar{i}}{\ltiT{i}},..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiFp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{i}}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }
    \end{array}

    \begin{array}{ll}
    \infer [Abs]
    {
    \left(
    \begin{array}{llll}
                     \text{$|\ova{\ltitvar{}}|>0$ implies \ltiEnv{} contains}
                     \arcr
                     \text{no symbolic closures}
    \end{array}
    \right)
                     \\\\
     \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                    {\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{}}}}}
                     {\ltiE{}}
                     {\ltiS{}}
                     {\ltiCombinedThreadedEnvp{}}
                     {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltifuntparamargtype{\ova{\ltitvar{}}}
                                           {\ltivar{}}
                                           {\ltiT{}}
                                           {\ltiE{}}}
                    {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    {\ltiCombinedThreadedEnvp{}}
                    {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                           {\ltiFn{\ltiT{}}{\ltiS{}}}
                                           {\ltivar{}}
                                           {\ltiEp{}}}
                 }
    \end{array}

    \infer [AppInst]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
    \\\\
                       \ltiSsubtype{\ltiCombinedThreadedEnv{3}}
                                   {\ltiEnv{}}
                                   {\ltiTp{}}
                                   {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                                   {\ltiCombinedThreadedEnv{4}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiE{}}}
                      {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiEp{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [AppInst\Bot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvpp{}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnvpp{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiE{}}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiR{}}}
                                  {\ltiEp{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [Sel\Bot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiFp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{}}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltisel{\ltiFp{}}{\ltivar{}}}
    }
                 \ \ \ \ \ 
                 %
    \infer [AppInf\Bot]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiBot}
                      {\ltiCombinedThreadedEnvpp{}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnvpp{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiEp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }


    \infer [AppInf-Closure]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiClosureWithStkID{\ltiEnvp{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiEp{}}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{3}}{\ltiClosureCache{3}}}
                      {\ltiEpp{}}
                  \\\\
    0 < \ltiFuel{3}
    \\
    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv
                       {\ltiFuel{3}-1}
                       {\ltiClosureCache{3}}}
                      {\ltiEnvConcat{\ltiEnvp{}}{\hastype{\ltivar{}}{\ltiT{}}}}
                      {\ltiEp{}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{4}}{\ltiClosureCache{4}}}
                      {\ltiFpp{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{4}}
                          {\ltiupdateClosureCacheNoElabLHS{\ltiClosureCache{4}}
                                {\ltiClosureID{}}
                                {\varnothing}
                                {\ltiT{}}
                                {\ltiS{}}}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEpp{}}}
    }
    \ \ \ \ 
%
    \infer [UAbs]
    {
    \ltiCombinedThreadedEnv{} = \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
    \\
    \ltiClosureID{} \not\in dom(\ltiClosureCache{})
    \\\\
    \ltiCombinedThreadedEnvp{}
    =
    \ltimakeCombinedThreadedEnv{\ltiFuel{}}
    {\ltimapsto{\ltiClosureCache{}}
              {\ltiClosureID{}}
              {\ltiClosure{\ltiEnv{}}{\ltiTop}}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiufun{\ltivar{}}{\ltiE{}}}
                      {\ltiClosureWithStkID
                                           {\ltiEnv{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiufunelab{\ltiClosureID{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
                 }
  \end{mathpar}

  \caption{Type inference algorithm (\textsc{AppInf} omitted)
  }
  \label{symbolic:figure:SC-language-algorithmic-type-system}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiSsubtype{\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltiS{}}
                 {\ltiT{}}
                 {\ltiCombinedThreadedEnvp{}}
                 \\\\
                 \text{
                 With symbolic closure environment \ltiCombinedThreadedEnv{},
                 \ltiS{} is a subtype of \ltiT{}
                 in updated environment \ltiCombinedThreadedEnvp{}.
                 }
    }
    }

    \infer [S-TVar]
    {}
    {
     \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltitvar{}}
                 {\ltitvar{}}
                 {\ltiCombinedThreadedEnv{}}
    }

    \infer [S-Top]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiT{}}{\Top}{\ltiCombinedThreadedEnv{}}}

    \infer [S-Bot]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\Bot}{\ltiT{}}{\ltiCombinedThreadedEnv{}}}

    \infer [S-Rec]
    {
    \overrightarrow{\ltiSsubtype{\ltiCombinedThreadedEnv{i-1}}{\ltiEnv{}}
                                {\ltiT{}}
                                {\ltiS{}}
                                {\ltiCombinedThreadedEnv{i}}
                                }
    }
    {
    \ltiSsubtype{\ltiCombinedThreadedEnv{0}}
                {\ltiEnv{}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n,
                         \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}^n}}
                {\ltiCombinedThreadedEnv{n}}
    }

    % eg (IFn [Int -> Int] [Number -> Number]) <: [Nothing -> Any]
    \infer [S-Fn]
    {
    \left(
    \begin{array}{lll}
      |\ova{\ltitvar{}}|>0 \text{ implies \ltiT{}, \ltiTp{}, \ltiS{}, \ltiSp{}}
    \arcr
      \text{contain no symbolic closures}
    \end{array}
    \right)
    \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}{\ltiCombinedThreadedEnvpp{}}
      \\\\
      \ltiSsubtype{\ltiCombinedThreadedEnvpp{}}{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}{\ltiCombinedThreadedEnvp{}}
    }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}
                  {\ltiPolyFn{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiT{}}}
                  {\ltiPolyFn{\ltiS{}}{\ova{\ltitvar{}}}{\ltiTp{}}}
                  {\ltiCombinedThreadedEnvp{}}
       }

    \infer [S-Closure]
    {
    \ltitv{\ltiE{}} \cap \ova{\ltitvar{}} = \varnothing
    \\
    0 < \ltiFuel{1}
    \\
    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{1}-1}{\ltiClosureCache{1}}}
                      {\ltiEnvConcat{\ltiEnv{}}{\hastype{\ltivar{}}{\ltiT{}}}}
                      {\ltiE{}}
                      {\ltiSp{}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiEp{}}
                      \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{2}}{\ltiEnv{}}{\ltiSp{}}{\ltiS{}}
                {\ltimakeCombinedThreadedEnv{\ltiFuel{3}}{\ltiClosureCache{3}}}
                      \\
    \ltiupdateClosureCacheNoElab{\ltiClosureCache{3}}
                          {\ltiClosureID{}}
                          {\ova{\ltitvar{}}}
                          {\ltiT{}}
                          {\ltiS{}}
                          {\ltiClosureCache{4}}
    }
    { \ltiSsubtype{\ltimakeCombinedThreadedEnv{\ltiFuel{1}}{\ltiClosureCache{1}}}
                  {\ltiEnvp{}}
                  {\ltiClosureWithStkID{\ltiEnv{}}
                                       {\ltiClosureID{}}
                                       {\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                  {\ltimakeCombinedThreadedEnv{\ltiFuel{3}}{\ltiClosureCache{4}}}
                  }
  \end{mathpar}

  \caption{Symbolic Closure Language Subtyping}
  \label{symbolic:figure:SC-language-subtype}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiupdateClosureCacheNoElab{\ltiClosureCache{}}{\ltiClosureID{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiClosureCachep{}}
    \\\\
    \text{Record symbolic closure \ltiClosureID{} as \ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}.
    Assumes \ova{\ltitvar{}} does not occur free in \ltiClosureID{}'s body.}
    }}
    \\

    \begin{array}{llll}
    \ltiupdateClosureCacheNoElabalign{\ltiClosureCache{}}{\ltiClosureID{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}
                           {\ltimapsto{\ltiClosureCache{}}
                                      {\ltiClosureID{}}
                                      {\ltiClosure{\ltiEnv{}}
                                                  {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}}}
                                                 , &
                                                 \text{where }
    (\ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = 
                       {\ltiClosure{\ltiEnv{}}
                                   {\ltiTop}})
                                   \text{ or }
    (\ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = 
              {\ltiClosure{\ltiEnv{}}{\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}})
    \end{array}
  \end{mathpar}
  \caption{Metafunctions for Symbolic Closure language}
\end{figure}

\begin{figure}

  \[
    \boxed{\ltielabDriver{\ltiE{}}{\ltiEp{}}{\ltiT{}}
    \text{ Elaborates external language term \ltiE{} to internal language term \ltiEp{} and type \ltiT{}.
    }
    }
  \]

  \begin{mathpar}
    \infer[ElabDriver]
    {
    \exists \ltiFuel{}.
     \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                       {\ltiEmptyEnv}
                       {\ltiE{1}}
                       {\ltiT{}}
                       {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
                       {\ltiE{2}}
                       \\
     \ltielimClos{\ltiClosureCache{}}{\ltiE{2}}{\ltiE{3}}
     \\
     \ltielimClosT{\varnothing}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    }
    {
    \ltielabDriver{\ltiE{1}}{\ltiE{3}}{\ltiTp{}}
    }
  \end{mathpar}

%  \[
%    \boxed{\ltielimClos{\ltiClosureCache{}}{\ltiE{}}{\ltiEp{}}
%    \text{ Converts symbolic closures in \ltiE{} to explicit types in \ltiEp{}}
%    }
%  \]
%
%  \[
%  \begin{array}{llll}
%    \ltielimClosalign{\ltiClosureCache{}}{\ltivar{}}
%                     {\ltivar{}}
%                     \\
%    \ltielimClosalign{\ltiClosureCache{}}
%                     {\ltiappinst{\ltiF{}}
%                                 {\ova{\ltiR{}}}
%                                 {\ltiE{}}}
%                     {\ltiappinst{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}
%                                 {\ova{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiR{}}}}
%                                 {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
%                             \\
%    \ltielimClosalign{\ltiClosureCache{}}{\ltisel{\ltiF{}}{\ltivar{}}}
%                     {\ltisel{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}{\ltivar{}}}
%                     \\
%    \ltielimClosalign{\ltiClosureCache{}}{\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
%                     {\ltiRec{\ova{\ltivar{} = \ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}}}
%                     \\
%    \ltielimClosalign{\ltiClosureCache{}}
%                     {\ltifuntparaminterface{\ova{\ltitvar{}}}
%                                            {\ltiT{}}
%                                            {\ltivar{}}
%                                            {\ltiE{}}}
%                     {\ltifuntparaminterface{\ova{\ltitvar{}}}
%                                            {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}
%                                            {\ltivar{}}
%                                            {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
%                     \\
%    \ltielimClosalign{\ltiClosureCache{}}
%                     {\ltiufunelab{\ltiufunelabentry{\ltiClosureID{}}}
%                                  {\ltivar{}}
%                                  {\ltiE{}}}
%                     {\ltielimClosLHS{\ltiClosureCache{}}
%                                     {\ltifuntparaminterface{\ova{\ltitvar{}}}
%                                                                {\ltiT{}}
%                                                                {\ltivar{}}
%                                                                {\ltiE{}}}},
%                     &\text{where } \ltilookup{\ltiClosureCache{}}{\ltiClosureID{}}
%                                      = \ltiClosure{\ltiEnv{}}{\ltifuntparaminterface{\ova{\ltitvar{}}}
%                                                                {\ltiT{}}
%                                                                {\ltivar{}}
%                                                                {\ltiE{}}}
%  \end{array}
%  \]


  \[
    \boxed{\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    \text{ Converts symbolic closures in \ltiT{} to explicit types in \ltiTp{},
    with seen symbolic closures \ova{\ltiClosureID{}}.}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiPolyFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}{\ova{\ltitvar{}}}
                             {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiS{}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiE{}}}
                      {\ltiPolyFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}\ltiClosureIDp{}}
                                                  {\ltiClosureCache{}}
                                                  {\ltiT{}}}
                                 {\ova{\ltitvar{}}}
                                 {\ltielimClosTLHS{\ova{\ltiClosureID{}}\ltiClosureIDp{}}
                                                  {\ltiClosureCache{}}
                                                  {\ltiS{}}}}
                      , & 
                      \text{where }
                      \ltiClosureIDp{} \not\in \ova{\ltiClosureID{}},
                      \ltilookup{\ltiClosureCache{}}{\ltiClosureIDp{}}
                      = \ltiClosure{\ltiEnv{}}
                                   {\ltiPolyFn{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}}}
                                   % this condition is checked in S-Closure and constraint system
                                   %, \ova{\ltitvar{}} \cap \ltitv{\ltiE{}} = \varnothing
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiT{}}
                      , & \text{otherwise}
  \end{array}
  \]
  \caption{Elaboration Metafunctions for Symbolic Closure language}
\end{figure}

\subsection{Symbolic closure Metatheory}

\begin{lemma}[Subtyping (External Language)]
   \ltiSdsubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
    iff
   \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
\end{lemma}

\begin{lemma}[Soundness (External Language)]
  If \ltitSdjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiEp{}}
                     and
                     \ltiSdsubtypeseen{\varnothing}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
                     then
    \ltitjudgement{\ltiEnv{}}
                  {\ltiEp{}}
                  {\ltiS{}}
                  {\ltiEpp{}}
\end{lemma}

\begin{lemma}[Completeness (External Language)]
  If \ltitjudgement{\ltiEnv{}}
                   {\ltiE{}}
                   {\ltiT{}}
                   {\ltiEp{}}
                  then
  \ltitSdjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiEp{}}
\end{lemma}

\begin{lemma}[Soundness (Symbolic Closure Language)]
  If there exists some fuel \ltiFuel{} such that
    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                      {\ltiEnv{}}
                      {\ltiE{1}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
                      {\ltiE{2}},
                      then
    \ltitSdjudgement{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}
                    {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{2}}}
                    {\ltiS{}}
                    {\ltiEp{}}
                    such that
                      \ltiisubtype{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}{\ltiS{}}{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}.
\end{lemma}

\begin{lemma}[Completeness 1 (Symbolic Closure Language)]
  If \ltitSdjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiEp{}}
                     then
    either
    and fuel \ltiFuel{}
    such that
    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
                      {\ltiFp{}}.
\end{lemma}

% TODO timeout rules for type system
% TODO 
\begin{lemma}[Completeness 2 (Symbolic Closure Language)]
  If \ltitSdjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiEp{}}
                     then
    there exists a term \ltiF{} such that \ltiE{} is a partial erasure of \ltiF{}
    and fuel \ltiFuel{}
    such that
    \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{}}}
                      {\ltiFp{}}.
\end{lemma}

\section{Examples without Type Argument Synthesis}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiFn{\ova{\ltiT{}}^n}{\ltiS{}} &\Leftrightarrow&
  \ltiFn{\ltiRec{\overrightarrowcaption{\hastype{\texttt{arg}i}{\ltiT{i}}}^{1 \leq i \leq n}}}{\ltiS{}}
  \\
  && \text{where } n \not= 1
                      &\mbox{Type abbreviations} \\
  \ltiufun{\ova{\ltivar{}}^n}{\ltiE{}} &\Leftrightarrow&
  \ltiufun{\ltivarp{}}{\ltireplaceoverrightarrowcaption{\ltisel{\ltivarp{}}{\texttt{arg}i}}{\ltivar{i}}{1 \leq i \leq n}{\ltiE{}}}
  \\
  && \text{where } n \not= 1, \ltivarp{} \not\in \ltifvLHS{\ltiE{}}
  \\
  \ltiapp{\ltiF{}}{\ova{\ltiE{}}^n} &\Leftrightarrow&
  \ltiapp{\ltiF{}}{\ltiRec{\overrightarrowcaption{\texttt{arg}i = \ltiE{i}}^{1 \leq i \leq n}}}
  \\
  && \text{where } n \not= 1
  \\
  \ltilet{\ova{\ltivar{}}}{\ova{\ltiE{}}}{\ltiF{}} &\Leftrightarrow& \ltiappParens{\ltiufun{\ova{\ltivar{}}}{\ltiF{}}}{\ova{\ltiE{}}}
                      &\mbox{Term abbreviations}
\end{array}
$$
\caption{External Language Syntax abbreviations
  }
\label{symbolic:figure:external-language-syntax-abbreviations}
\end{figure}


% - Solution
%   - "obvious" function annotations
%     - can be derived from usage context
%   - introduce "symbolic" closure types
%     - a function's type is its code + typed local scope
%   - don't need to check a function that isn't called
% - Constraints
%   - wildcard "?" type
%     - needed to provide argument types while inferring body
%     - from Colored LTI
%   - Infinite loops
%     - subtyping
%     - type generalization
%     - term reduction limits
%   - user-level story
%     - symbolic closures enabled by flag
%     - users cannot write a symbolic closure
%     - that way, global annotations cannot contain a symbolic closure
%       - helps with polymorphism story
%         - constraint solving
%           - hypothesis/goal: only one side of contraint solving can have a symbolic closure
%             - one side is from global annotation, other side from local inference
%     - compatible with occurrence typing
%   - reporting errors
%     - suggesting types
%     - avoid showing inlining to users
%   - checking fn with arguments at type Bot is equivalent (?) to not checking at all
%     - what about strange disjoint ordered intersection types like `into`
%     - do they break? do they need initial Bot arities?
%   - 0-n checks to same function
%     - avoid double expansion
%       - many copies of symbolic closures are made, could be expanded at different times
%         - how to synchronize?
%     - skipping unreachable functions
%       - potential for latent bugs, if type checker turned off in future and fn is made reachable
%     - performance
%   - consistent evaluation results
%     - how to ensure correct inlining?
%     - relationship between inlined and evaluated code?
%       - do we want to "undo" the inlining when finally evaluating?
%   - when to use a closure type?
%     - partial annotations
%   - polymorphism
%     - postpone discussion to next chapter
%   - applying symbolic analysis to infer loop/recur annotations
%     - similar issues
%     - different type generalization story?
%   - comparison to let-polymorphism
%     - expressiveness
%     - performance
%   - help check macros?
%     - not directly applicable, since too much context would be lost
%       - would help check *more* of an expansion, but error messages
%         are still unrelated to original code
%   - is this a sound strategy?
%     - faithfully simulates beta reduction
%     - termination story?
%   - case studies
%     - criteria:
%       - good errors?
%       - predictable behavior?
%       - performance?
%     - simple eta expansions
%       - (+ 1 2)
%       - ((fn [x y] (+ x y)) 1 2)
%     - let-bound functions
%       - (+ 1 2)
%       - (let [plus (fn [x y] (+ x y))]
%           (plus 1 2))
%     - y-combinator
%       - stress test
%     - let-polymorphism worst case (exponential) comparison
%       - stress test
%     - completely inlined transducers
%       - case study: inlining map + comp
%         - why: non recursive polymorphic functions
%           - common idiom
%         - how to report errors?
%   - polymorphic function-intersection types
%     - how to handle, do we need backtracking?
%     - do we need to recheck arguments? 

\chapter{Type Argument Synthesis with Symbolic Closures}
\label{chapter:symbolic:directed-lti}

\subsection{Type-argument synthesis for the Symbolic Closure Language}

\begin{figure}
  \begin{mathpar}
    \infer[AppInf]
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiPoly{\ova{\ltitvar{}}}
                               {\ltiFn{\ltiT{}}{\ltiS{}}}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
                  \\
                       |\ova{\ltitvar{}}|>0
           \\
           \ltigenconstraint{\varnothing}{\ova{\ltitvar{}}}{\ltiTp{}}{\ltiT{}}{\ltiCp{}}
           \\
           \ltiprocessDelays{\ltiCombinedThreadedEnv{3}}
                            %{\ltiEnvConcatParen{\ltiEnv{}}{\ova{\ltitvar{}}}}
                            {\ltiCp{}}
                            {\ltiC{}}
                            {\ltiCombinedThreadedEnv{4}}
           \\
           \ltiSubst{\ltiC{}}{\ltiFn{\ltiT{}}{\ltiS{}}}{\ltisubst{}}
    }
    {
    \ltitSstkjudgementNoElab{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltiApplySubst{\ltisubst{}}
                                                      {\ltitvar{}}}}
                                  {\ltiEp{}}}
    }
  \end{mathpar}
  \caption{Type argument synthesis for the Symbolic Closure Language}
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiC{} &::=& \ltiCSet{\ova{\ltiCEntry{\ltiT{}}{\ltitvar{}}{\ltiT{}}}\ 
                         \ova{\ltiDEntryVX{\ltiV{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiT{}}}
                          }
                      &\mbox{Constraint sets}\\
                      % TODO talk about X/V constraint sets
   \ltiCEmpty &\Leftrightarrow& \ltiCSet{\ova{\ltiCEntry{\ltiBot}{\ltitvar{}}{\ltiTop}}}
                      &\mbox{Constraint abbreviations}
\end{array}
$$
  \caption{Syntax for Constraint generation}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [CG-Top]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty}
    }

    \infer [CG-Upper]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\\\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [CG-Lower]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\\\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [CG-Bot]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty}
    }
    \ \ \ 
    %
    \infer [CG-Refl]
    {
      \ltitvarp{}
      \not\in
      \overline{\ltitvar{}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [CG-Fun]
    {
    |\ova{\ltitvar{}}|>0 \text{ implies \ova{\ltiTp{}}, \ova{\ltiT{}} do not contain symbolic closures}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\ova{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\ova{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\\\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiTp{1}}{\ltiT{2}}}}
                     {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{1}}{\ltiTp{2}}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }

    \infer [CG-Closure]
    {}
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                     {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiS{}}{\ltiT{}}}}
                     {\ltiCSet{\ltiDEntryVX{\ltiV{}}
                                         {\overline{\ltitvarp{}}}
                                         {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                         {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiS{}}{\ltiT{}}}}}}
    }
  \end{mathpar}
  \caption{Constraint generation system
                 \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}
                 where $\ltiV{} \cap {\overline{\ltitvar{}}} = \varnothing$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}

    \boxed{
    \infer[]
    {
      \ltiprocessDelays{\ltiCombinedThreadedEnv{}}
                       {\ltiC{}}
                       {\ltiCp{}}
                       {\ltiCombinedThreadedEnvp{}}
      \\\\
      \text{Process all delayed constraints in
                       \ltiC{}, yielding a new constraint set \ltiCp{}.
      }
    }
    {}
    }

    \infer[]
    {
      \ltiorderDelays{\ltiC{0}}
                     {\ova
                       {\ltiDEntryVX{\ltiV{}}
                                    {\ova{\ltitvarp{}}}
                                    {\ltiT{}}
                                    {\ltiS{}}}^n}
                                    \\
      \overrightarrowcaption{
      \ltiprocessDelay{\ltiCombinedThreadedEnv{i-1}}
                      {\ltiDEntryVX{\ltiV{i}}
                                   {\ova{\ltitvarp{}}_i}
                                   {\ltiT{i}}
                                   {\ltiS{i}}}
                      {\ltiC{i-1}}
                      {\ltiC{i}}
                      {\ltiCombinedThreadedEnv{i}}
                      }^{1 \leq i \leq n}
    }
    {
      \ltiprocessDelays{\ltiCombinedThreadedEnv{0}}
                       {\ltiC{0}}
                       {\ltiC{n}}
                       {\ltiCombinedThreadedEnv{n}}
    }

    \boxed{
    \infer[]
    {
      \ltiorderDelays{\ltiC{}}{\ova{\ltiDEntryVX{\ltiV{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}}}
      \\\\
      \text{Returns the delayed constraints in constraint set \ltiC{} topologically
      sorted by type variable dependency.
      }
      \\\\
      \text{eg. \ltiDEntryVX{}{}{...}{\ltiFn{\ltitvar{1}}{\ltitvar{2}}}
      goes before 
            \ltiDEntryVX{}{}{...}{\ltiFn{\ltitvar{2}}{\ltitvar{3}}}
      }
    }
    {}
    }

    \infer[]
    {
      \ova{\ltitvar{}}^m = \ova{\ltitvarp{}}_1 = \ova{\ltitvarp{}}_2 = ... = \ova{\ltitvarp{}}_{i-1} = \ova{\ltitvarp{}}_i
      \\
      \forall i \in 1...n, j \in 1...m.
          \{\ltivariance{\ltitvar{j}}{\ltiS{i}}, \ltivariance{\ltitvar{j}}{\ltiT{i}}\} \subseteq \{\ltivconstant, \ltivcovariant\}
      \\
      \text{let \ova{k} be a permutation of 1...n st. }
        \forall i,j \in 1...n.
        \text{ if }
        \ltitv{\ltiT{{k_i}}} \cap \ltitv{\ltiS{{k_j}}} \cap \ova{\ltitvarp{}} \not= \varnothing
        \text{ then }
        % not \leq, eg. [a -> a] depends on itself
        i < j 
    }
    {
      \ltiorderDelays{\ltiCSet{...,\ova{\ltiDEntryVX{\ltiV{}}
                                             {\ova{\ltitvarp{}}^m}
                                             {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                             {\ltiFn{\ltiS{}}{\ltiT{}}}}^n}}
                                             {
      [\ltiDEntryVX{\ltiV{}}
                   {\ova{\ltitvarp{}}}
                   {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                   {\ltiFn{\ltiS{}}{\ltiT{}}}_i
                   |
                   i \in \ova{k}]
                   }
    }

    \boxed{
    \infer[]
    {
      \ltiprocessDelay{\ltiCombinedThreadedEnv{}}
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiS{}}
                                   {\ltiT{}}}
                      {\ltiC{}}
                      {\ltiCp{}}
                      {\ltiCombinedThreadedEnvp{}}
      \\\\
      \text{Process delayed constraint 
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiS{}}
                                   {\ltiT{}}},
                                   with current constraint set \ltiC{},
      }
      \\\\
      \text{yielding a new constraint set \ltiCp{}.}
    }
    {}
    }

    \infer[]
    {
            0 < \ltiFuel{} \\
            \ltiSubst{\ltiC{}}{\ltiFn{\ltiS{}}{\ltiT{}}}{\ltisubst{}}\\
            \ltitSstkjudgementNoElab{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                          {\ltiClosureCache{1}}}
                              {\ltiEnvConcat{\ltiEnv{}}
                                            {\hastype{\ltivar{}}
                                                     {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}}}
                              {\ltiEpp{}}
                              {\ltiTp{}}
                              {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                          {\ltiClosureCache{2}}}
                              {\ltiFpp{}}
                              \\
          \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarpp{}}}
                           {\ova{\ltitvar{}}}
                           {\ltiTp{}}
                           {\ltiApplySubst{\ltisubst{}}{\ltiT{}}}
                           {\ltiCpp{}}
                           \\
                           \ltiCpp{} \text{ does not contain delayed constraints}
                                \\
          \ltiupdateClosureCacheNoElab{\ltiClosureCache{2}}
                                {\ltiEnv{}}
                                {\ltiClosureID{}}
                                {\ova{\ltitvarpp{}}}
                                {\ltiApplySubst{\ltisubst{}}{\ltiS{}}}
                                {\ltiApplySubst{\ltisubst{}}{\ltiT{}}}
                                %{\ltiFpp{}}
                                {\ltiClosureCache{3}}
    }
    {
      \ltiprocessDelay{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{1}}}
                      {\ltiDEntryVX{\ltiV{}}
                                   {\ova{\ltitvarp{}}}
                                   {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                   {\ltiPoly{\ova{\ltitvarpp{}}}{\ltiFn{\ltiS{}}{\ltiT{}}}}}
                      {\ltiC{}}
                      {\ltiCIntersect{\ltiC{}}{\ltiCpp{}}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCache{3}}}
    }

  \end{mathpar}
  \caption{Processing delayed constraints
  }
\end{figure}

%FIXME remove
\newpage

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
type Option[a] = {match : $\ltiPoly{\text{r}}%
                                   {\ltiFn{\text{OptionVisitor[a,r]}}%
                                          {\text{r}}}$}
type OptionVisitor[a,r] =
  {caseNone : $\ltiFn{}{\text{r}}$,
   caseSome : $\ltiFn{\text{a}}{\text{r}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}%
                                        {\text{Option[s]}}}%
                                 {}$
         {match = $\ltiufun{\text{v}}%
                           {\text{v.caseNone()}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
     \ltiClosureCacheEntry{\text{c1}}%
                          {\ltiClosure{\text{s}}%
                                      {\ltiNotInferred{\ltifuntparaminterface{\ltiInferred{\text{r}}}%
                                                                             {\ltiInferred{\ltiFn{\text{OptionVisitor[s,r]}}{\text{r}}}}%
                                                                             {\text{v}}%
                                                                             {\text{v.caseNone()}}}}}}$ *)
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}{\text{Option[s]}}}%
                                 {}$
         {match = $\ltiufunelab{\ltiInferred{\text{c1}}}%
                               {\text{v}}%
                               {\text{v.caseNone()}}$}
(* fully annotated *)
None = $\ltifuntparaminterfaceLHS{\text{s}}%
                                 {\ltiFn{}%
                                        {\text{Option[s]}}}%
                                 {}$
         {match = $\ltifuntparaminterface{\ltiInferred{\text{r}}}%
                                         {\ltiInferred{\ltiFn{\text{OptionVisitor[s,r]}}{\text{r}}}}%
                                         {\text{v}}%
                                         {\text{v.caseNone()}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltiufun{\text{v}}{\text{v.caseSome(y)}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} = \ltiClosureCacheEntry{\text{c1}}{\ltiClosure{\ltiEnvConcat{\text{t}}{\hastype{\text{y}}{\text{t}}}}{\ltiNotInferred{\ltifuntparaminterface{\ltiInferred{\text{r}}}{\ltiInferred{\ltiFn{\text{OptionVisitor[t,r]}}{\text{r}}}}{\text{v}}{\text{v.caseSome(y)}}}}}}$ *)
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltiufunelab{\ltiInferred{\text{c1}}}{\text{v}}{\text{v.caseSome(y)}}$}
(* fully annotated *)
Some = $\ltifuntparaminterfaceLHS{\text{t}}{\ltiFn{\text{t}}{\text{Option[t]}}}{\text{y}}$
         {match = $\ltifuntparaminterface{\ltiInferred{\text{r}}}{\ltiInferred{\ltiFn{\text{OptionVisitor[t,r]}}{\text{r}}}}{\text{v}}{\text{v.caseSome(y)}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match({caseNone = $\ltiufun{}{\text{None()}}$,
                 caseSome = $\ltiufun{\text{y}}{\text{Some(f(y))}}$})
(* SC annotated *)
(* $\ltiInferred{\ltiEnv{} = {\ltiEnvConcat{\text{c}}{\ltiEnvConcat{\text{d}}{\ltiEnvConcat{\hastype{\text{f}}{\ltiFn{\text{c}}{\text{d}}}}{\hastype{\text{x}}{\text{Option[c]}}}}}}}$ *)
(* $\ltiInferred{\ltiClosureCache{} =}$
     $\ltiInferred{\ltiClosureCacheEntry{\text{c1}}{\ltiClosure{\ltiEnv{}}{\ltiNotInferred{\ltifuninterface{\ltiInferred{\ltiFn{}{\ltilstOption{\ltiBot}}}}{}{\text{None[\ltiInferred{\ltiBot}]()}}}}}}$,
     $\ltiInferred{\ltiClosureCacheEntry{\text{c2}}{\ltiClosure{\ltiEnv{}}{\ltiNotInferred{\ltifuninterface{\ltiInferred{\ltiFn{\text{c}}{\ltilstOption{\text{d}}}}}{\text{y}}{\text{Some[\ltiInferred{\text{d}}](f(y))}}}}}}$
*)
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match[$\ltiInferred{\text{d}}$]({caseNone = $\ltiufunelab{\ltiInferred{\text{c1}}}{}{\text{None()}}$,
                    caseSome = $\ltiufunelab{\ltiInferred{\text{c2}}}{\text{y}}{\text{Some(f(y))}}$})
(* fully annotated *)
map = $\ltifuntparaminterfaceLHS{\text{c,d}}{\ltiFn{\ltiFn{\text{c}}{\text{d}},\text{Option[c]}}{\text{Option[d]}}}{\text{f,x}}$
        x.match[$\ltiInferred{\text{d}}$]({caseNone = $\ltifuninterface{\ltiInferred{\ltiFn{}{\ltilstOption{\ltiBot}}}}{}{\text{None[\ltiInferred{\ltiBot}]()}}$,
                    caseSome = $\ltifuninterface{\ltiInferred{\ltiFn{\text{c}}{\ltilstOption{\text{d}}}}}{\text{y}}{\text{Some[\ltiInferred{\text{d}}](f(y))}}$})
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
map($\ltiufun{\text{y}}{\text{1+y}}$, Some(42))
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}%
                                                         {\text{y}}%
                                                         {\text{1+y}}}}}}$ *)
map[$\ltiInferred{\text{Int, Int}}$]($\ltiufunelab{\ltiInferred{\text{c1}}}{\text{y}}{\text{1+y}}$, Some[$\ltiInferred{\text{Int}}$](42))
(* fully annotated *)
map[$\ltiInferred{\text{Int, Int}}$]($\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}{\text{y}}{\text{1+y}}$, Some[$\ltiInferred{\text{Int}}$](42))
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let x = 1 in x+1
(* Desugared *)
$\ltiapp{(\ltiufun{\text{x}}{\text{x+1}})}{\text{1}}$
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}%
                                                         {\text{x}}%
                                                         {\text{x+1}}}}}}$ *)
$\ltiappParens{\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x+1}}}{\text{1}}$
(* fully annotated *)
$\ltiappParens{\ltifuninterface{\ltiFn{\text{Int}}{\text{Int}}}{\text{x}}{\text{x+1}}}{\text{1}}$
\end{lstlisting}
}



{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
id = $\ltifuntparaminterface{\text{a}}{\ltiFn{\text{a}}{\text{a}}}{\text{x}}{\text{x}}$

let app = $\ltiufun{\text{f},\text{x}}{\ltiapp{\text{f}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\ltiPoly{\text{a}}{\ltiFn{\text{a}}{\text{a}}},\text{Int}}%
                                                                             {\text{Int}}}}%
                                                         {\text{f,x}}%
                                                         {\ltiappinst{\text{f}}{\ltiInferred{\text{Int}}}{\text{x}}}}}}}$ *)
let app = $\ltiufunelab{\text{c1}}{\text{f},\text{x}}{\ltiapp{\text{f}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
(* Fully annotated *)
let app = $\ltifuninterface{\ltiInferred{\ltiFn{\ltiPoly{\text{a}}{\ltiFn{\text{a}}{\text{a}}},\text{Int}}%
                                               {\text{Int}}}}%
                           {\text{f},\text{x}}%
                           {\ltiappinst{\text{f}}{\ltiInferred{\text{Int}}}{\text{x}}}$ in
  $\ltiapp{\text{app}}%
          {\text{id}, \text{1}}$
\end{lstlisting}
}


%\input{symbolic-extended}
%\input{colored}

% - Solution
%   - extend colored LTI with directed inference
%   - introduce constrained types
%   - derive data flow from (variances of) polymorphic variable occurrences 
%   - simple example
%     - (identity 1)
%     - demonstrate how this is checked with colored LTI
%     - compare to directed LTI:
%       - 2/----v
%         [x -> x]  Int
%          ^--------/1
%
%         1. Int flows to contravariant position
%         2. contravariant position flows to covariant position (because it's on the other side of ->)
%       - no loop, because variables not under different numbers of function types
%         - (we don't know the precise rule yet)
%   - complex example
% - Constraints
%   - advantages over colored LTI
%     - aids symbolic analysis
%       - because we derive potential dataflows, we don't need to over-approximate,
%         and thus trigger unneeded symbolic analysis
%         - which might then fail because of not enough contextual information
%   - disadvantages over colored LTI
%     - significant deviation from LTI
%       - constrained types
%       - aggressive local inference based on data flows
%     - not obvious how to prove soundness
%   - infinite loops
%     - how to manage cycles in inferred data flow 
%   - constraint solving
%     - constrained types
%       - literature (see symb.tex)
%   - flow diagrams
%     - see symb.tex
%   - relationship to colored LTI model
%     - see symb.tex
%   - related work
%     - ML_sub
%     - see: symb.tex
% - investigate implications 
%   - Remy ICFP '05
%     - (seems to) propagate information simultaneously in both directions like CLTI
%     - intro prose does a nice job explaining ML moving towards System F & challenges
%   - Joe B Wells 1994
%     - explains Church vs Curry style System F formulations
%     - some mentions of decidable fragments of System F
%   - Boxy types, ICFP '06
%     - explains higher-rank types
%       - types with forall quantifiers nested inside function types
%     - explains impredicativity
%       - being allowed to instantiate a type variable with a polytype (polymorphic type)
%     - explains "local type inference"
%       - a partial inference technique for a language with bounded, impredicative quantification,
%         and higher-rank types.
%     - explains "CLTI"
%       - reformulated bidirectional checking for F_sub so that the _type_ and not the _judgment form_
%         describes the direction in which type information flows
%     - CLTI's colors inspired their "boxy" types
%       - they outline differences in related work

%\chapter{Custom Typing rules}
%\label{chapter:symbolic:custom-rules}

% - Solution
%   - allow users to provide custom typing rules
%   - 
% - Constraints
%   - wildcard type from colored LTI useful
%   - custom error messages
%     - propagation via expected types
%       - outer-most wins
%   - using clojure.spec to conform/unform
%     - to rip apart and put syntax back together
%     - more robust than manual parsing
%   - differences with Turnstile
%     - in Turnstile, the macro *is* the rule
%       - here, we separate the two
%       - we preserve the macro call until evaluation
%       - use the typing rule to expand "under" the macro as many times as we want
%         - can do this 0-n times, thus compatible with directed LTI & symbolic analysis

%\include{hm-comparison}
