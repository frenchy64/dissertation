\chapter{Background}

As is inevitable for an optional type system, there are many
Clojure programs that Typed Clojure was not designed to type check.
These programs contain Clojure idioms that are often either intentionally
not supported with Typed Clojure's initial design, or 
were introduced to Clojure at a later date.
Regardless, programmers will inevitably want to use these features 
in their Typed Clojure programs---but crucially without breaking
support for existing idioms.
In this part, we explore what kinds of idioms are missing
support in Typed Clojure, and propose solutions in the form of
backwards-compatible extensions.

As we discussed in \partref{part:types}, Typed Clojure's initial
design is strongly influenced by Typed Racket. In particular,
Typed Clojure's static semantics of
combinining local type inference and occurrence typing
to check fully-expanded code
comes directly from Typed Racket.
This shared base is appropriate, given the similarities between
the base Clojure and Racket languages.
It is also effective, seamlessly handling many control flow
idioms, capturing many polymorphic idioms, and often yielding
predictable type error messages.
However, there are important tradeoffs to consider in this design---in the following
sections we introduce them and propose extensions to attempt to nullify
their downsides.

\section{Enhancing local type inference}

Concerning the limitations of local type inference,
Hosoya and Pierce~\cite{hosoya1999good}
isolate two drawbacks.
The first is dealing with ``hard-to-synthesize arguments''.
To understand this, we must appreciate a key ingredient of local type inference
called \emph{bidirectional propagation}, which 
we use the example of type checking \clj{(inc 42)} to demonstrate.
If we have already checked \clj{inc} to have type \clj{[Int -> Int]}, we
now have a choice of how to check the argument \clj{42} is an \clj{Int}.
The first is to ascribe an expected type to \clj{42} of \clj{Int}
and rely on
bidirectional \emph{checking mode} to ensure \clj{42} has the correct type
once we check it.
The second is to infer the type of \clj{42} (without an expected type) using 
bidirectional \emph{synthesis mode}, and then ensure the inferred type
is compatible with \clj{Int} after the fact.
A useful analogy in terms of expressions is that checking mode propagates
information outside-in, and synthesis mode propagates inside-out.
A similar analogy in terms of a type derivation tree (that grows upwards)
relates checking and synthesis modes to information being passed
up and down the tree, respectively.

To best serve the purposes of local type inference, it is crucial to stay in
bidirectional \emph{checking} mode as much as possible.
The ``hard-to-synthesize arguments'' problem occurs when type argument
inference interferes with the ability to stay in checking mode, and
thus forces the bidirectional propagator into synthesis mode
for arguments that require checking mode.
For example, to type check

\clj{(map (fn [x] (inc x)) [1 2 3])},

where \clj{map} has type

\clj{(All [a b] [[a -> b] (Seqable a) -> (Seqable b)])},

we use type argument inference to determine how to instantiate type variables \clj{a}
and \clj{b} based on \clj{map}'s arguments.
Unfortunately, 
to answer this question,
the naive local type inference algorithm~\cite{PierceLTI}
uses synthesis mode to retrieve the argument types,
and so checks \clj{(fn [x] (inc x))} in synthesis mode.
No information is propagated about the type of \clj{x},
so this expression will fail to type check, demonstrating
why functions are hard-to-synthesize.

The second drawback noted by Hosoya and Pierce are
cases where there is no ``best'' type argument to infer.
This occurs when there is not enough information available
to determine how to instantiate a type such that the program
has the best chance of type checking, and so it must be guessed.
A representative case where this occurs is inferring the
type of a reference from just its instantiation, such
that optimal types are given to reads and writes.
For example, the following code creates a Clojure Atom
(a reference type) with initial value \clj{nil}, writes
\clj{0} to the Atom, and then increments the Atom's value.

{
\begin{cljlisting}
(let [r (atom nil)]
  (reset! r 0)
  (inc @r))
\end{cljlisting}
}

What type should \clj{r} be assigned? From its initial binding,
\clj{(Atom nil)} seems appropriate, but the subsequent write
would fail. Alternatively, assigning \clj{(Atom Any)} would
allow the write to succeed, but the the final read would fail
because it expects \clj{Int}.
This demonstrates difficulties of the ``no-best-type-argument'' problem.

Hosoya and Pierce report unsatisfactory results in their attempts to
fix these issues, in both the effectiveness and complexity
in their solutions.
They speculate that these difficulties might be better 
addressed at the language-design level---rather than algorithmically---in ways that
keep the bidirectional propagator in checking mode.
For the ``no-best-type-argument'' problem,
we agree with this assessment, since
addressing the problem mostly amounts to annotating 
all reference constructors.
To this end,
Typed Clojure offers several
wrappers for common functions where this problem
is common---the previous example might use the ``typed''
constructor
\clj{(t/atom :- (U nil Int), nil)}.
However, the ``hard-to-synthesize arguments'' problem
is a deeper and more pervasive issue when checking Clojure code.
We don't have the luxury, desire, nor do we think it would be particularly
successful to introduce new core idioms to Clojure,
and so we attempt to solve the this problem algorithmically.

%\begin{cljlisting}
%(for [i (range 100)]
%  (map (fn [j] (inc j))
%       (range i)))
%\end{cljlisting}

Hosoya and Pierce outline the two main challenges that must be
addressed to solve the ``hard-to-synthesize arguments'' problem.
First, we must provide a strategy for identifying which arguments 
should be avoided.
For instance,
they provide a simple grammar for identifying hard-to-synthesize arguments,
which includes (for Standard ML) unannotated functions and unqualified constructors.
Second, an alternative (probably more complicated) algorithm
for inferring type arguments is needed that also handles
avoided arguments.
Their experiments show that the naive approach does not suffice,
and hint at the delicate handling needed to effectively maximize or minimize
instantiated types to stay in checking mode.
We will now use these challenges as a presentational framework to outline our own approach.

In our experience, the most common hard-to-synthesize expression in Clojure code
is the function.
Clojure's large standard library of higher-order functions and encouragement
of functional programming result in many usages of anonymous functions, which almost
always require annotations to check with Typed Clojure.
So, to answer Hosoya and Pierce's first challenge, 
we avoid checking hard-to-synthesize function expressions by
introducing a new function type: a \emph{symbolic closure type}.
A symbolic closure does not immediately check the function body. Instead,
the function's code along with its local type context is saved
until enough information is available to check
the function body in checking mode.
We present more details about symbolic closures in \chapref{chapter:symbolic:symbolic-closures}.

Now that we have delayed the checking of hard-to-check arguments,
Hosoya and Pierce's second challenge calls for an enhanced
type argument reconstruction algorithm to soundly handle
them.
Our investigation led us to create \emph{directed local type inference}
(\chapref{chapter:symbolic:directed-lti}),
which determines the possible data flows through a polymorphic function
by noting the positions of type variable occurrences, and attempts to
use this information to check its arguments in an optimal order for remaining
in bidirectional checking mode.

\section{Custom typing rules}

Besides local type inference,
another significant feature inherited from Typed Racket is that
code is fully expanded before checking.
This unfortunately means that macros with complex expansions
are often uncheckable, and display cryptic error messages when attempting
to do so.
We investigate providing the user with \emph{custom typing rules} (\chapref{chapter:symbolic:custom-rules})
as an extension point to customize how to type check a macro before
it is expanded.
As discussed in 
\partref{part:implementations}, Typed Clojure's initial design does
not support custom typing rules, so we exploit the infrastructure
discussed there,
and present our investigation into the user interface for the rules in
\chapref{chapter:symbolic:custom-rules}.

% - "Avoiding hard-to-synthesize arguments"
%   1. need mechanism to decide which arguments to avoid
%   2. more complicated scheme for determining best type arguments

% - Problem
%   - many common idioms cannot be checked
%   - limitations of local type inference
%   - made harder by occurrence typing
%   - want general solutions available to all users
%   - preliminary investigation of several techniques
% - Possible solutions
%   - symbolic analysis
%     - symbolic closures
%       - deal with "obvious" local function annotations
%     - inlining
%   - directed local type inference
%     - derive data flow from polymorphic types for more aggressive local type variable inference
%   - custom typing rules
%     - interface for describing how to check an unexpanded macro call
%       - or complex functions
%     - custom errors
% - Constraints
%   - some speculation of how well they compose together
%   - small models without rigorous proofs
%   - case studies with real Clojure idioms

\chapter{Delayed checking for Unannotated Local Functions}
\label{chapter:symbolic:symbolic-closures}

In local type inference, functions are hard-to-synthesize types for.
Put another way, to check a function body successfully, types for
its parameters are needed upfront.
For top-level function definitions, this is not a problem in many
optional type systems since top-level annotations would be provided
for each function.
However, for anonymous functions it's a different story.
The original local type inference algorithm~\cite{PierceLTI}
lacks a synthesis rule for unannotated functions, but due to the prevalence
of anonymous functions in languages like JavaScript, Racket, and Clojure,
optional type systems for the languages add their own rules.

Typed Racket and Typed Clojure implement a simple but sound strategy
to check unannotated functions. The body of the function is checked
in a type context where its parameters are of type \clj{Any},
the \texttt{Top} type.
This helps check functions that don't use their arguments, or only
use them in positions that require type \clj{Any}.
For example, both \clj{(fn [x] "a")} and \clj{(fn [x] (str "x: " x))} 
synthesize to \clj{[Any -> String]} in Typed Clojure.
The downsides to this strategy are that unannotated functions are never
inferred as polymorphic, and functions that use their arguments
at types more specific than \clj{Any} are common.

TypeScript~\cite{typescript}, an optional type system for JavaScript,
takes a similar approach, but instead of annotating parameters with
TypeScript's least permissive type called \js{unknown},
by default it assigns parameters the unsound dynamic type \js{any}.
In TypeScript, \js{any} can be implicitly cast to any other type,
so the type checker will (unsoundly) allow any usage of unannotated arguments.
If this behavior is unsatisfactory,
the \js{noImplicitAny} flag removes special handling for unannotated
functions altogether, and TypeScript will demand explicit annotations for all arguments.

In this chapter, we present an alternative approach to checking unannotated functions
based on the insight that a function's body need only be type checked if and when it is called.
For example, the program \clj{(fn [x] (inc x))} cannot throw a runtime error because
the function is never called, and so a type system may soundly treat the function body as unreachable code.
On the other hand, wrapping the same program in the invocation
\clj{((fn [x] (inc x)) nil)}
makes the runtime error possible, and so a sound static type system must flag the error.

Exploiting this insight in the context of a bidirectional type checker using
local type inference requires many considerations.
First, we must decide in which situations is it desirable to delay checking a function.
Second, we must identify the information that must be saved in order to delay checking a function,
and then choose a suitable format for packaging that information.
Third, we must identify how a function is deemed ``reachable'',
and then which component of the type system is responsible for checking a function body.
Fourth, it is desirable to identify and handle the ways in which 
infinite loops are possible, such as the checking of a delayed function triggering
another delayed function to check, which triggers another delayed check, ad nauseam.
Fifth, we must determine how delayed functions interact with polymorphic types
during type argument reconstruction.

We address all these considerations in the following sections, except
for the final one, which we delegate to \chapref{chapter:symbolic:directed-lti}.

\section{Overview}
\label{symbolic:section:overview}

In this section, we explore some of the implications that come with delayed checks for local functions,
by example.
We avoid any use of polymorphic functions
(we isolate those issues in \chapref{chapter:symbolic:directed-lti})
and demonstrate the tradeoffs with just non-recursive monomorphic functions.

First, let \clj{inc} be of type \clj{[Int -> Int]}.
The following, then, is well typed because \clj{1} is an \clj{Int}.

\begin{cljlisting}
(inc 1)
\end{cljlisting}

Using the standard bidirectional application type rule, \clj{inc} is checked first,
followed by \clj{1}.
However, eta-expanding the operator does not behave as nicely.

\begin{cljlisting}
((fn [x] (inc x)) 1)
\end{cljlisting}

Like usual, the standard application rule checks the function first.
However, there is no annotation for \clj{x}, so the function body will fail
to check.
This is unfortunate, especially in a type system that claims to be ``bidirectional'',
since the information that \clj{x} is an \clj{Int} is adjacent to the function
in the form of an argument.
One strategy to alleviate this problem is to always check arguments first~\cite{xie2018let}.
However, that nullifies the ability for the operator to propagate information
to its arguments, whose advantages are exploited to good effect in Colored Local Type Inference~\cite{coloredlti01}

We combine both flavors by keeping the standard operator-first checking order
but delay the checking of unannotated functions.
Then, an additional application rule handles applications of
unannotated functions to force their checking.
So in this case, the checking of \clj{(inc x)}
is delayed until the argument \clj{1} is inferred as \clj{Int},
after which this information is used to check \clj{(inc x)}
in the extended type context where \clj{x : Int}.

We could imagine hard-coding a type rule that manually delays
direct applications of unannotated functions until after checking
its arguments.
However, that does not generalize to more complicated examples.
Take the following illustrative code, identical the previous
example, except the function is let-bound as \clj{f}.

{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (fn [x] (inc x))](*@\label{symbolic:example:let-bound:def-f}@*)
  (f 1))(*@\label{symbolic:example:let-bound:app-f}@*)
\end{cljlisting}
}

Instead of following the brittle strategy of creating yet-another special rule to delay checking
let-bound functions, we generalize the idea.
We make a delayed function check a first-class concept in our type-system by
creating a new type for it.
Roughly, \clj{f} would have a delayed function type---introduced by
a type rule for unannotated functions---and \clj{(f 1)}
would force a check for the delayed function---by an application
rule that handles delayed function \emph{types} (not syntax-driven).

Now we must decide what a delayed function type consists of.
Clearly, the \emph{code} of the function must be preserved until
it is checked, otherwise the application rule would have nothing
to work with.
We note that our static semantics of saving
the code of a function to check later
is analogous to the runtime strategy of
evaluating a function as \emph{closure},
and using beta-reduction to extract the original
function from the closure and apply it to its arguments.

The trick in maintaining lexical scope during beta-reduction for closures
is to apply the function under the \emph{function definition's}
environment, instead of the application site's.
For example,
\figref{symbolic:example:closure-red}
evaluates
to \clj{2}
because
the occurrence of
\clj{y} on line \ref{symbolic:example:closure-red:y-usage}
is bound to \clj{1} by line \ref{symbolic:example:closure-red:y-def-site}.
If we used the local environment at the application site (line \ref{symbolic:example:closure-red:f-app}),
\clj{y} would be bound on line \ref{symbolic:example:closure-red:y-app-site}
to \clj{nil},
and would throw a runtime error.

% must save type context
\begin{figure}
{
\lstset{numbers=left}
\begin{cljlisting}
(let [f (let [y 1](*@\label{symbolic:example:closure-red:y-def-site}@*)
          (fn [x] (+ x y)))](*@\label{symbolic:example:closure-red:y-usage}@*)
  (let [y nil](*@\label{symbolic:example:closure-red:y-app-site}@*)
    (f 1)))(*@\label{symbolic:example:closure-red:f-app}@*)
\end{cljlisting}
}
  \caption{This example evaluates to \clj{2} with lexically scoped variables.}
  \label{symbolic:example:closure-red}
\end{figure}

The crucial insight is that
the same trick applies to \emph{checking} delayed function types,
except at the \emph{type}-level.
Specifically, the occurrence of \clj{y}
on line \ref{symbolic:example:closure-red:y-usage}
must be checked as type \clj{Int} (from line \ref{symbolic:example:closure-red:y-def-site}),
and not type \clj{nil} (from line \ref{symbolic:example:closure-red:y-app-site}).
So, a delayed function type pairs a function's code with the type environment
at the function definition site.
This strongly resembles a ``type-level'' closure that is reduced symbolically,
and so we call this new type a \emph{symbolic closure}.

We can use symbolic closures to inline higher-order-function definitions.
In the following example, \clj{app} would normally need a higher-order
or polymorphic
annotation to handle the application on the final line.
Instead, with symbolic closures, the entire program simplifies in a few steps to
\clj{(inc 1)}.

% more beta reduction
\begin{cljlisting}
(let [f (fn [x] (inc x))
      app (fn [g x] (g x))]
  (app f 1))
\end{cljlisting}

As alluded to in the previous section, we must identify
all type system components who are responsible for checking symbolic closures,
and ensure they perform their obligations correctly.
The following example uses a higher-order function
\clj{app-int}---similar to the previous \clj{app}
function, except it is an annotated global
variable---to (elaborately) compute \clj{(inc 1)}.
Since \clj{app-int} is annotated, it will be checked
by the standard application rule.
However, its first argument will be delayed as a symbolic
closure---now we must identify who is responsible for checking it.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-int [[Int -> Int] Int -> Int])
...
(app-int (fn [x] (inc x)) 1)
\end{cljlisting}

Based on the type signature of \clj{app-int},
it is clearly allowed to invoke its first argument
(if the first parameter of \clj{app-int} was annotated as, say,
\clj{[Bot -> Int]}, this would not be the case).
Therefore, to maintain soundness, its potential invocations must
agree with the provided argument.
The standard application type rule uses subtyping to ensure
provided arguments are compatible with the formal parameter types of
the operator.
To handle symbolic closures, we preserve the standard application rule
and instead add a subtyping case for symbolic closures.

In this case, the subtyping relation would be asked to verify if
``the symbolic closure \clj{(fn [x] (inc x))}
is a subtype of \clj{[Int -> Int]}''.
This can be answered by checking the symbolic closure
returns \clj{Int} when 
\clj{x} is type \clj{Int}---and so this subtyping case
delegates to checking if the symbolic closures inhabits the given type.
The subtype relationship is true if the check succeeds without type error,
otherwise it is false.

The correct ``contravariant subtyping left-of-the-arrow''
is naturally preserved.
In this case, the left-of-the-arrow check is ``\clj{Int} is a subtype of \clj{x}'s type'', and
annotating \clj{x} as \clj{Int} turns this statement into the reflexively true ``\clj{Int} is a subtype of \clj{Int}''.
At a glance, it may seem that we are wasting the benefits
of this contravariant rule---after all, it enables \clj{x} to be \emph{any} supertype of
\clj{Int}, such as \clj{Num} or even \clj{Any}.
However, it is in our interest to propagate the most precise parameter types
so then function bodies have the best chance to check without error.
Since symbolic closures are designed to support rechecking their bodies at different argument types,
a symbolic function can simply be rechecked with the less-precise types
when it comes time to broaden its domain.

This scheme extends to subtyping with arbitrarily-nested function types.
To demonstrate nesting to the right of an arrow,
the following code (again, elaborately) computes \clj{(+ 1 1)},
but this time
via \clj{curried-app-int}, which accepts a curried
function of two arguments \clj{f} and a number \clj{x}, and 
provides \clj{x} as both arguments to \clj{f}.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann curried-app-int [[Int -> [Int -> Int]] Int -> Int])
(defn curried-app-int [f x] ((f x) x))
...
(curried-app-int (fn [y] (fn [x] (+ x y))) 1)
\end{cljlisting}

The standard application rule will ensure 
``the symbolic closure \clj{(fn [y] (fn [x] (+ x y)))}
is a subtype of
\clj{[Int -> [Int -> Int]]}'', which involves assuming
\clj{y : Int} and then checking the \emph{code} \clj{(fn [x] (+ x y))}
at type \clj{[Int -> Int]}---which just uses the standard
function rule.

To demonstrate nesting to the left of an arrow,
\clj{app-inc} again computes \clj{(inc 1)}
in an even more convoluted way with \clj{app-inc}---by accepting a function
\clj{f} that it passes both \clj{inc} and its second argument to.

% using subtyping to check symbolic closures.
\begin{cljlisting}
(ann app-inc [[[Int -> Int] Int -> Int] Int -> Int])
(defn app-inc [f x] (f inc x))
...
(app-inc (fn [g y] (g y)) 1)
\end{cljlisting}

Importantly, \clj{app-inc}'s first argument has a function
type to the left on an arrow, in particular \clj{[Int -> Int]}.
Under these conditions, subtyping asserts that ``the symbolic
closure \clj{(fn [g y] (g y))} is a subtype of \clj{[[Int -> Int] Int -> Int]}''
by assuming \clj{g : [Int -> Int]} and \clj{y : Int} and
verifying that \clj{(g y)} checks as \clj{Int}---which is almost immediate by
the standard application rule.

We leverage some syntactic restrictions
to avoid the need for further subtyping cases for symbolic closures.
First, symbolic closures cannot be annotated by the programmer,
and can only be introduced by the ``unannotated function'' typing rule.
Second (as discussed in \secref{analyzer:extensibility:side-effects}),
top-level variables are not allowed to inherit the types of their initial
values, and must be explicitly annotated.
These restrictions ensure symbolic closures both cannot occur to the
left of an arrow type, and 
cannot propagate beyond the top-level form it was defined in.
%This stretches the metaphor of ``local'' type inference
%beyond just a single tree walk using
%bidirectional propagation,

\subsection{Performance and error messages}

% FIXME need to be more precise about "undecidable". What problem are
% we deciding? See Wells '94 for some details. I think so far I
% mean "type checking always terminates (conservatively)"

While useful, allowing the type system to perform beta-reduction
requires careful planning: type checking time is now proportional 
to the running time of the program!
Unsurprisingly, this makes type checking with a naive implementation of symbolic
closures undecidable.
Without intervention,
the next program (an infinite loop using the y-combinator that computes \clj{(inc (inc (inc ...)))})
would send the \emph{type system} into an infinite loop.

%TODO much simpler example: ((fn [x] (x x)) (fn [x] (x x)))

% infinite loops
\begin{cljlisting}
(let [Y (fn [f]
          ((fn [g] (fn [x] (f (g g) x)))
           (fn [g] (fn [x] (f (g g) x)))))]
  (let [compute (Y (fn [f x] (inc (f x))))]
    (compute 1)))
\end{cljlisting}

To prevent such loops, we limit the number of symbolic reductions
done at type-checking time.
As a conservative solution to the halting
problem, this limit will prematurely halt some programs that would
otherwise fully reduce in a finite number of steps.
For example, if we set the reduction limit to 5\ in
the following code,
during the 6th reduction of \clj{f} the type system will
throw an error.

% premature halting
\begin{cljlisting}
(let [f (fn [x] x)]
  (f (f (f (f (f (f 1)))))))
\end{cljlisting}

In simple cases like these, the error message 
can guide the user to fixing the error.
For example, the type system would suggest 
annotating \clj{f} as \clj{[Int -> Int]} (by collecting
argument and return types as the program is reduced),
which would cause the program to check successfully
under the same conditions.
For cases with more heterogeneous argument and return types---like the y-combinator---the 
error message would just note which function caused
the reduction quota to be depleted.

As Wells~\cite{wells1994typability} remarks,
stopgap measures such as this to circumvent undecidable
type inference algorithms negatively affect
program portability.
For example, a different reduction limit may cause
a program to fail to type check that otherwise type checked
in a previous version.
We hope to learn reasonable defaults for the reduction limit
by experience.

Note that using the type checker to decide subtyping
has unfortunate implications for 
the aforementioned annotation suggestions
for reduction-limit error messages.
An ``obviously-failing'' subtyping check might trigger a
check for irrelevant arguments, and then provide them to the user.
A curious aside: if symbolic closures are identified just by their code and definition
type environments, suggestions may also be merged for functions with
identical code and scope.

% TODO performance
% - undecidable 
%   - heuristics needed to halt search
%   - type checking time proportional to running time of program
% - for finitely running programs:
%   - degenerate case checking time complexity becomes at least exponential time in the size of the program because we can recheck a function
%     body multiple times, and a symbolic closure can be duplicated
%
% eg. (let [pair (fn [f g] (f (g) (g)))] (pair (fn [x y] (+ x y)) (fn [] 1)))
% - (fn [] 1) is checked twice
%   - can "stack" these recheckings, worst case is infinite
% - Damas-Milner algorithm checks a function definition once to determine its principle type scheme
%   - exponential time & space
%     - because principle type schemes can become very large
%     - also exponential time to print a type
%     - symbolic closures are also exponential time to print a type (naively)
%       since they can be duplicated
%       - I think these are similar reasons to Milner's algorithm

% do we need a story for runtime casting from Any to [Int -> Int]?
%\begin{cljlisting}
%(ann dynapp-int [Any Int -> Int])
%...
%(dynapp-int (fn [x] (inc x)) 1)
%\end{cljlisting}

% no idea what to do with negation function types 
%\begin{cljlisting}
%(ann app-int [(U [Int -> Int] (I Any (Not [Int -> Int]))) Int -> Int])
%...
%(app-int (fn [x] (inc x)) 1)
%\end{cljlisting}


\section{Formal model}

We formalize symbolic closure types in the style of local type inference~\cite{PierceLTI}
enhanced with colored types~\cite{coloredlti01}.
Like those papers, we define separate internal and an external languages,
such that the external compiles to the internal by inferring 
and inserting local type arguments.

%Using fuel, we can ensure that type-checking in the external language always terminates.
%Then, if type-checking is successful, we know that a finite

% (let [f (fn [x] x)]
%   (f f))
% => 
% (let [f (ann (fn [x] x)
%              [Bot -> Top])]
%   (f f))
% => 
% (let [f (ann (fn [x] x)
%              [Bot -> Top])]
%   ((fn [x] x) (fn [x] x)))
% =>
% (let [f (ann (fn [x] x)
%              [Bot -> Top])]
%   (ann (fn [x] x)
%        [Bot -> Top])

\subsection{Compiling to \ltiFsub}

There are a least two ways to approach our external language
with symbolic closures compiling to \ltiFsub.
The main challenge and incentive is to remove all symbolic
closure types from our program and to replace them with
explicit annotations.
Our first approach is to copy function code and annotate
parameter types at each usage.
This approach seems promising, except there is a tension between
copying function code and creating runtime closures.
Our second approach is to extend \ltiFsub with intersection types
and ascribe each function an intersection type that 
describes all the ways it was used as a symbolic closure.

We now explore our first approach, to copy function code as they
are checked.
First, for those functions ascribed symbolic closure types, we
copy their code and insert them at their usage sites.
For example, \clj{f} in 

\begin{cljlisting}
(let [f (fn [x] x)]
  (f 1)
  (f "a"))
\end{cljlisting}

would be given a symbolic closure type, and
the program would be expanded like so:

\begin{cljlisting}
(let [f (fn [x] x)]
  ((fn [x] x) 1)
  ((fn [x] x) "a"))
\end{cljlisting}

First, we notice that all occurrences of \clj{f} have disappeared,
so it is safe to assume \clj{f} will never be called. It seems
reasonable to us to annotate its argument as \clj{Bot}.

\begin{cljlisting}
(let [f (fn [x :- Bot] x)]
  ((fn [x] x) 1)
  ((fn [x] x) "a"))
\end{cljlisting}

Next, the two unannotated functions would be checked as symbolic closures.
These checks would succeed, and then we could ascribe a parameter type on
each function.

\begin{cljlisting}
(let [f (fn [x :- Bot] x)]
  ((fn [x :- Int] x) 1)
  ((fn [x :- Str] x) "a"))
\end{cljlisting}

This program type checks with the rules of \ltiFsub.
However, subtle variations on this program are much
more puzzling to account for.

If \clj{f} closes over a variable, like \clj{v}
here

\begin{cljlisting}
(let [f (let [v 1] (fn [x] (print v) x))]
  (f 1)
  (f "a"))
\end{cljlisting}

then simply copying its function code will
not suffice.
If we do so, \clj{v} is no longer in scope:

\begin{cljlisting}
(let [f (let [v 1] (fn [x] (print v) x))]
  ((fn [x] (print v) x) 1)
  ((fn [x] (print v) x) "a"))
\end{cljlisting}

We could imagine inlining the value of 
\clj{v} to work around this issue, but this is not a
full solution.
If instead, \clj{v} was an annotated function parameter
as in the next example

\begin{cljlisting}
(let [f (fn [v :- Int]
          (fn [x] (print v) x))]
  ((f 42) 1)
  ((f 42) "a"))
\end{cljlisting}

it's even unclear how to inline the
unannotated function at all.
It seems the only choice is to inline \clj{f}
in its entirety, regardless if it was a symbolic closure.

\begin{cljlisting}
(let [f (fn [v :- Int]
          (fn [x] (print v) x))]
  (((fn [v :- Int]
      (fn [x] (print v) x))
    42)
   1)
  (((fn [v :- Int]
      (fn [x] (print v) x))
    42)
   "a"))
\end{cljlisting}

This way we can at least annotate the missing \clj{Int} and \clj{Str}
parameter types.
It is now tempting to inline \emph{all} local variables with their
definitions.
This doesn't work in a language with side effects.
For example, inlining \clj{f} to ``fix'' the issues
in one of our previous examples would repeat side
effects, like printing \clj{"I only print once"} in the following
program (it, instead, prints thrice if \clj{f} is inlined).

\begin{cljlisting}
(let [f (let [v 1]
          (print "I only print once.")
          (fn [x] (print v) x))]
  (f 1)
  (f "a"))
\end{cljlisting}

Symbolic closures can also get their types by being passed
to annotated functions.
For example, \clj{id}
gets the type \clj{[Int -> Int]}
by being passed to \clj{f}, whose definition we will treat
as opaque, emulating a top-level function.

\begin{cljlisting}
(let [f (fn [g :- [Int -> Int]] ...)
      id (fn [x] x)]
  (f id))
\end{cljlisting}

By inlining \clj{id} and annotating its parameter \clj{Int},
this program does not pose any particular challenge.

\subsubsection{Intersection types}

If we allow ordered function intersection types,
featured in several optional type systems,
we arrive at an impasse.
Here, we assert that \clj{g} must \emph{both}
be
\clj{[Int -> Int]}
and
\clj{[Num -> Num]}.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (fn [x] x)]
  (f id))
\end{cljlisting}

Clearly \clj{id} inhabits both these types,
however attempting to inline its definition
gets us nowhere.
Introducing intersection types gives us
one more trick up our sleeve: ascribing
\clj{id} as an \emph{intersection} of function types.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (fn [x :- Bot] x)]
  (f (ann (fn [x] x)
          (IFn [Int -> Int]
               [Num -> Num]))))
\end{cljlisting}

This seems to help immensely, but now it seems a waste
to inline \clj{id} at all.
Instead, we could simplify this program by only annotating \clj{id}'s
right-hand-side.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (ann (fn [x] x)
              (IFn [Int -> Int]
                   [Num -> Num]))]
  (f id))
\end{cljlisting}

We can use this technique to help check our previous examples
without having to work around closed-over variables.
For example, our thrice-printing example requires
a single intersection type annotation, based on
the two symbolic reductions of \clj{f}.

\begin{cljlisting}
(let [f (let [v 1]
          (print "I only print once.")
          (ann (fn [x] (print v) x)
               (IFn [Int -> Int]
                    [Str -> Str])))]
  (f 1)
  (f "a"))
\end{cljlisting}

Unfortunately, inferring ordered intersection types for unannotated
functions introduce other issues,
most prominently determining the ``best'' ordering of
arities.

Compared to unordered intersections, ordered intersections
have a simple application rule: first arity wins.
A ``best'' ordering would yield the same or more accurate return type
for every possible application, compared to every other ordering.
For now, we assume that a best ordering
exists for every ordered function intersection type, although
we are not sure.

There are several interesting cases we sketch to give an idea
of the character of this algorithm.
First, if arity 1's domain is a subtype of arity 2's
domain, then arity 1 should come first,
using subtyping of the range to break ties in a similar fashion.
For example, \clj{[Int -> Int]}
goes before  \clj{[Num -> Int]},
but
\clj{[Int -> Int]}
precedes
\clj{[Int -> Num]}.
Second, if the domains of two arities
are incomparable via subtyping, their ordering does not matter.
For example,
\clj{[(Pair Int Num) -> Int]},
\clj{[(Pair Num Int) -> Num]},
and
\clj{[Int -> Num]}
may occur in any order in relation to each other.
This also accounts for multiple arguments,
by considering them as a list passed to a single argument.

Going back to checking programs, we now explore some
other ways in which inferring ordered function intersections has
interesting interactions with \ltiFsub.
The next example is similar to the one that helped motivate
intersection types earlier, except we omit the annotation
on \clj{f}.

\begin{cljlisting}
(let [f (fn [g]
          (g 1)
          (g "a"))
      id (fn [x] x)]
  (f id))
\end{cljlisting}

Here, the annotation on \clj{g} is the interesting part.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Str -> Str])]
          (g 1)
          (g "a"))
      id (ann (fn [x] x)
              (IFn [Int -> Int] [Str -> Str]))]
  (f id))
\end{cljlisting}

Unfortunately, we can't retroactively annotate all programs in this way.
Take the following program.

\begin{cljlisting}
(let [f (fn [g]
          (fn [x]
            (g x)))]
  ((f (fn [y] y)) 1)
  ((f (fn [z] z)) "a"))
\end{cljlisting}

Ideally, we would give \clj{f} the polymorphic type
\clj{(All [a] [[a -> a] -> [a -> a]])}.
Then, we would use the type variable to annotate its return
as \clj{[a -> a]}.
Instead, we infer \clj{f} as type

\begin{cljlisting}
(IFn [[Int -> Int] -> [Int -> Int]]
     [[Str -> Str] -> [Str -> Str]])
\end{cljlisting}

This means that \clj{f}'s body will be checked twice.
The first time, \clj{g} will be assumed \clj{[Int -> Int]},
and then return checked as \clj{[Int -> Int]}.
The second, \clj{g} will be assumed \clj{[Str -> Str]},
and then return checked as \clj{[Str -> Str]}.

The problem now is annotating the function in \clj{f}'s body once-and-for-all.
It inhabits the type \clj{(U [Int -> Int] [Str -> Str])},
but that is too broad to be compatible with \clj{f}'s return---on the other hand,
it does not inhabit \clj{(IFn [Int -> Int] [Str -> Str])},
because \clj{g} cannot accept both \clj{Int} and \clj{Str}.
To handle these cases, we borrow \emph{conditional types} from TypeScript.

A conditional type is type-level dependency between types.
It is of the form \clj{(if (subtype? S T) U V)},
and returns type \clj{U} if \clj{S} is a subtype of \clj{T},
and \clj{V} otherwise.
This construct is particularly useful in combination with
the ability to reference the types of \emph{variables}.
In TypeScript, the type \clj{typeof f} resolves to the type of \clj{f}
in the current type environment. Here, we equivalently write \clj{(TypeOf f)}.

Applying these new type constructs to our example, we get the following annotation:

\begin{cljlisting}
(let [f (ann (fn [g]
               (fn [x :- (if (subtype? (TypeOf g) [Int -> Int]) Int Str)]
                 (g x)))
             (IFn [[Int -> Int] -> [Int -> Int]]
                  [[Str -> Str] -> [Str -> Str]]))]
  ((f (fn [y :- Int] y)) 1)
  ((f (fn [z :- Str] z)) "a"))
\end{cljlisting}

Now when \clj{f}'s first function type is checked,
\clj{g} will be of type \clj{[Int -> Int]}, which annotates
\clj{x} as \clj{Int}.
Correspondingly for the second function type,
\clj{g} will be of type \clj{[Str -> Str]}, which annotates
\clj{x} as \clj{Str} via the conditional type's else-branch.
We note that special consideration of variable shadowing is required when using \clj{TypeOf}---for
example, if \clj{g} was shadowed above, we would be branching on the wrong type.

\subsubsection{Polymorphism}

We have not addressed how symbolic closures interact with polymorphic types.
For now, we consider a restricted subset of polymorphic functions, but which happens to be
common in Clojure code.
Anecdotally, they are higher-order functions that take in functions cannot be iterated.

For example, the \clj{map} function is roughly of type:

\begin{cljlisting}
(All [a b]
  [[a -> b] (Seqable a) -> (Seqable b)])
\end{cljlisting}

We can immediately see the data flow by the occurrences of type variables.
The function argument takes an \clj{a} from the collection argument,
and then returns a \clj{b} to the return collection.
The function argument cannot be called on its own output in the body
of \clj{map} because \clj{b} is not compatible with \clj{a}.
We can draw these dependencies as arrows---notice that there is no arrow
from \clj{b} to \clj{a}. There are implicit dependencies from
\clj{a} to \clj{b} because everything to the right of an arrow type depends
on everything to the left of the arrow (or, output values depend
on input values).


\begin{lstlisting}
(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
\end{tikzpicture} 

Inferring the data flow is crucial to checking symbolic closures.
Take the following example, where the function argument is inferred
as a symbolic closure.

\begin{cljlisting}
(map (fn [x] x) [1 2 3])
\end{cljlisting}

We now have two jobs: to infer the type arguments to \clj{map}
and to infer the type of \clj{x}.
Both can be found simultaneously by solving constraints
to find optimal instantiations for \clj{a} and \clj{b}.
First, we collect the constraints that make
\clj{(Closure \{\} (fn [x] x))}
a subtype of
\clj{[a -> b]}.
By checking the function with annotations
\clj{(fn [x :- a] x)},
we know that \clj{a} flows into \clj{b}, so
we get the constraint
\clj{Bot <: a <: b}.
For the second argument to \clj{map}
we infer
\clj{Int <: a <: Top}.
Since both type variables occur invariantly, we use their smallest instantiations,
so the optimal solution to these constraints
is \clj{a = Int, b = Int}.
We use this substitution to both
both provide the type arguments to \clj{map} (via \clj{inst})
and function argument (by substituting away the \clj{a} that
exercised the symbolic closure).


\begin{cljlisting}
((inst map Int Int) (fn [x :- Int] x) [1 2 3])
\end{cljlisting}

We can combine this inference technique with the same approach
we used to check our previous let-bound function examples,
like in the following code.

\begin{cljlisting}
(let [f (fn [x] x)]
  (map f [1 2 3])
  (map f ["a" "b" "c"]))
\end{cljlisting}

Here, we infer type arguments for each usage of \clj{map},
and combine the information collected for \clj{f} from both
inferences into an intersection type, yielding:

\begin{cljlisting}
(let [f (ann (fn [x] x)
             (IFn [Int -> Int]
                  [Str -> Str]))]
  ((inst map Int Int) f [1 2 3])
  ((inst map Str Str) f ["a" "b" "c"]))
\end{cljlisting}

Furthermore, this approach plays nicely with inferring conditional types,
like in the next example:

\begin{cljlisting}
(let [f (fn [g]
          (fn [x]
            (map g x)))]
  ((f (fn [y] y)) [1 2 3])
  ((f (fn [z] z)) ["a" "b" "c"]))
\end{cljlisting}

Now we must both infer an annotation for \clj{x} and
the type arguments to \clj{map}, but, as
in example motivating conditional types,
this is aggravated by \clj{f} being given a
intersection type, and thus forcing its body to be checked twice.
The solution is to to use more conditional types, particularly
as in the instantiation of \clj{map}:

\begin{cljlisting}
(let [f (ann (fn [g]
               (fn [x :- (Seqable (if (subtype? (TypeOf g) [Int -> Int]) Int Str))]
                 ((inst map
                        (if (subtype? (TypeOf x) (Seqable Int)) Int Str)
                        (if (subtype? (TypeOf x) (Seqable Int)) Int Str))
                  g x)))
             (IFn [[Int -> Int] -> [(Seqable Int) -> (Seqable Int)]]
                  [[Str -> Str] -> [(Seqable Str) -> (Seqable Str)]]))]
  ((f (fn [y :- Int] y)) [1 2 3])
  ((f (fn [z :- Str] z)) ["a" "b" "c"]))
\end{cljlisting}

\subsubsection{Inferring Conditional types}

The most attractive use of conditional types is to check the
same piece of code at different types.

% Complications with functions nested in other data structures

\subsection{Internal Language}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifuninterface{\ltiT{}}{\ltivar{}}{\ltiE{}}
                         \alt
                         \ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiT{}}}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ova{\ltivar{} = \ltiE{}}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltitvar{} 
                         \alt
                         \ltiTop
                         \alt
                         \ltiBot
                         \alt \ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}
                         \alt
                         \ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}
                         \alt
                         \ltiMu{\ltitvar{}}{\ltiT{}}
                         \alt \ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiT{}}}}
                                          {\ova{\ltiContextualFn{\ltiEnv{}}{\ltiT{}}{\ltiT{}}}}
                      &\mbox{Types} \\
  \ltiEnv{} &::=& \ltiEmptyEnv \alt
                  \hastype{\ltivar{}}{\ltiT{}} \alt
                  \ltitvar{} \alt
                  \ltiEnvConcat{\ltiEnv{}}{\ltiEnvp{}}
                      &\mbox{Type Context Stacks} \\
  \ltiSubtypeSeen{} &::=& \ova{\ltiSeenEntry{\ltiT{}}{\ltiT{}}}
                      &\mbox{Subtype Seen List} \\

\end{array}
$$
\caption{Internal Language Syntax}
\label{symbolic:figure:internal-language}
\end{figure}

\figref{symbolic:figure:internal-language} shows the syntax
the internal language, which is based on \ltiFsub
extended with records.
Terms \ltiE{} and \ltiF{} range over 
variables \ltivar{},
explicitly typed polymorphic functions
\ltifunmono{\ltivar{}}{\ltiT{}}{\ltiE{}},
function application
with explicit type arguments
\ltiappinst{\ltiF{}}{\ova{\ltiT{}}}{\ltiE{}},
record selectors
\ltisel{\ltiE{}}{\ltivar{}},
and record constructors
\ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}.
Types \ltiT{}, \ltiS{}, and \ltiR{} are 
type variables \ltitvar{},
top type \ltiTop,
bottom type \ltiBot,
polymorphic function types \ltiArrow{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}},
and record types \ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}.
Type environments \ltiEnv{}
consist of 
entries for local bindings
\hastype{\ltivar{}}{\ltiT{}},
the empty environment
\ltiEmptyEnv,
in-scope type variables 
\ltitvar{},
and concatenation
\ltiEnvConcat{\ltiEnv{}}{\ltiEnvp{}}.


\begin{figure}
  \begin{mathpar}
    \infer [I-Abs]
    { 
    \ltiunfoldLHS{\ltiT{}} =
      \ltiPoly{\ova{\ltitvar{}}}{\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{1...n}}
                                             {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiT{}}{\ltiS{}}}^{n+1...m}}}
    \\\\
    \overrightarrowcaption{
    \ltitjudgement{\ltiEnvConcat{\ltiEnvConcat{\ltiEnv{}}{\ova{\ltitvar{}}}}{\hastype{\ltivar{}}{\ltiT{i}}}}
                  {\ltiE{}}
                  {\ltiSp{i}}
                  }^{1\leq i \leq n}
    \\\\
    \overrightarrowcaption{
    \ltitjudgement{\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnv{}}{\ltiEnvp{i}}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{i}}}}}
                  {\ltiE{}}
                  {\ltiSp{i}}
                  }^{n < i \leq m}
    \\\\
    \overrightarrowcaption{\ltiisubtype{\ltiEnv{}}{\ltiSp{i}}{\ltiS{i}}}^{1 \leq i \leq m}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifuninterface{\ltiT{}}
                                   {\ltivar{}}{\ltiE{}}}
                  {\ltiT{}}
                 }

    \infer [I-AppInst]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiT{}^f}
                    \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiT{}^a}
                  \\\\
         \ltiresolve{\ltiinternallabel}
                    {\ltiEnv{}}
                    {\ltiT{}^f}
                    {\ltiPoly{\ova{\ltitvar{}}}{\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}
                                                            {\ova{\ltiContextualFn{\ltiEnvpp{}}{\ltiTpp{}}{\ltiSpp{}}}}}}
                  \\\\
                  \ltiLfindTA{\ltiinternallabel}{\ltiEnv{}}{\ova{\ltitvar{}}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}{\ova{\ltiR{}}}
                  \\
                  m > 0
                  \\\\
                  \ova{\ltiSp{}}^m
                  =
                  \{ \ltiS{i}\ |\ i \in 1 ... n, \ltiisubtype{\ltiEnv{}}{\ltiT{}^a}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{i}}}
                  \}
    }
    {
      \ltitjudgement{\ltiEnv{}}
                    {\ltiappinst{\ltiF{}}
                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                                {\ltiE{}}}
                    {\ltiMeetMany{\ova{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}}}
    }

    \infer [I-Var]
    {}
    {
    \ltitjudgement
                    {\ltiEnv{}}
                    {\ltivar{}}
                    {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }


    \infer [I-App\Bot]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiT{}}
                  \\\\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
                  \\\\
    \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiR{}}}}}{\ltiE{}}}
                  {\ltiBot{}}
    }


    \infer [I-Sel]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiS{}}
                     \\\\
    \ltiunfold{\ltiS{}}
              {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{i}}{\ltiT{i}} , ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [I-Sel\ltiBot]
    {
    \ltitjudgement{\ltiEnv{}}
                     {\ltiF{}}
                     {\ltiT{}}
                     \\\\
                     \ltiisubtype{\ltiEnv{}}{\ltiT{}}{\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{}}}
                  {\ltiBot}
    }

    \infer [I-Rec]
    {
    \overrightarrow{
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiT{}}
                  }
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                  {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
    }

    %\\\\

    \infer [S-TVar]
    {}
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltitvar{}}{\ltitvar{}}
    }

    \infer [S-Top]
    {}
    { \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\Top}}

    \infer [S-Bot]
    {}
    { \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\Bot}{\ltiT{}}}

    \infer [S-Rec]
    {
    \overrightarrow{\ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}}
    }
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}},
                             \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}}}
    }

    \infer [S-MuL]
    {
     \ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltiS{}} \in \ltiSubtypeSeen{}
     \\\\
    \text{ or }
     \\\\
    \ltiisubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}
                                                 {\ltiS{}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiEnv{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}{\ltiS{}}
    }
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
                    {\ltiS{}}
    }

    \infer [S-MuR]
    {
     \ltiSeenEntry{\ltiS{}}{\ltiMu{\ltitvar{}}{\ltiT{}}} \in \ltiSubtypeSeen{}
     \\\\
    \text{ or }
     \\\\
    \ltiisubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiS{}}
                                                 {{\ltiMu{\ltitvar{}}{\ltiT{}}}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}
    }
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
    }

    \infer [S-Poly]
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiEnvConcat{\ltiEnv{}}{\ova{\ltitvar{}}}}
                    {\ltiS{}}
                    {\ltiT{}}
    }
    { \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltiS{}}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                   }


    \infer [S-IFn]
    { 
      \forall i \in 1...n.\ 
        \exists j \in 1...q.\ 
          \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiS{j}}{\ltiT{i}}
    }
    { \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                      {\ltiSplitIFn{\ltiS{1}...\ltiS{p}}{\ltiS{p+1}...\ltiS{q}}}
                      {\ltiSplitIFn{\ltiT{1}...\ltiT{m}}{\ltiT{m+1}...\ltiT{n}}}
                   }

    \infer [SF-Fn]
    {
          \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}
          \\\\
          \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}
          }
    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {\ltiFn{\ltiSp{}}{\ltiT{}}}
                     {\ltiFn{\ltiS{}}{\ltiTp{}}}
                     }

    \infer [SF-ContextBoth]
    {
     \ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnvpp{}}
                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvpp{}}{\ltiS{}}}{\ltiEnvp{}}}
                     {\ltiT{}}
    }
    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
                     {(\ltistackmapping{\ltiEnvpp{}}{\ltiT{}})}
    }

    \infer [SF-ContextL]
    {
     \ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvp{}}{\ltiS{}}}{\ltiEnv{}}}
                     {\ltiT{}}
    }
    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
                     {\ltiT{}}
    }

    \infer [SF-ContextR]
    {
     \ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {\ltiS{}}
                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvp{}}{\ltiT{}}}{\ltiEnv{}}}
    }
    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
                     {\ltiEnv{}}
                     {\ltiS{}}
                     {(\ltistackmapping{\ltiEnvp{}}{\ltiT{}})}
    }


  \end{mathpar}
  \caption{Algorithmic Type system for internal language:
   \ltitjudgement{\ltiEnv{}}{\ltiE{}}{\ltiT{}}
                 and 
                 \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}.
  }
  \label{symbolic:figure:internal-language-type-system}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{\ltiunfold{\ltiT{}}{\ltiS{}}
    \text{ Unfold top-level recursion in \ltiT{} to \ltiS{}.
    }
    }

    \begin{array}{lcl}
      \ltiunfoldalign{\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                     {\ltiPoly{\ova{\ltitvar{}}}{\ltiunfoldLHS{\ltiT{}}}}\\
      \ltiunfoldalign{\ltiMu{\ltitvar{}}{\ltiT{}}}
                     {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}
                                 {\ltitvar{}}
                                 {\ltiunfoldLHS{\ltiT{}}}}
                                                                \\
      \ltiunfoldalign{\ltiT{}}{\ltiT{}} \text{, otherwise}\\
    \end{array}

    \boxed{\ltiEnvTVars{\ltiEnv{}}{\ova{\ltitvar{}}}
    \text{ Returns the type variables brought into scope by \ltiEnv{} in the order they were declared.
    }
    }

    \begin{array}{lllll}
      \ltiEnvTVarsalign{\ltiEmptyEnv}{\varnothing}
      \\
      \ltiEnvTVarsalign{\ltiEnvConcat{\hastype{\ltivar{}}{\ltiT{}}}{\ltiEnv{}}}
                       {\ltiEnvTVarsLHS{\ltiEnv{}}}
      \\
      \ltiEnvTVarsalign{\ltiEnvConcat{\ltitvar{}}{\ltiEnv{}}}
                       {\ltitvar{},\ltiEnvTVarsLHS{\ltiEnv{}}}
    \end{array}

    \boxed{
    \infer[]
    {}
    {
    \ltiEnvMissingTVars{\ltiEnv{d}}{\ltiEnv{a}}{\ltiEnv{}}
    \\\\
    \text{ Given definition and application contexts \ltiEnv{d} and \ltiEnv{a}, add 
    type variables to \ltiEnv{d} only present in \ltiEnv{a}.
    }
    }
    }

    % assumes differently bound type variables are distinct
    \infer[]
    {
    \ova{\ltitvar{}} = [\ltitvar{} | \ltitvar{} \in \ltiEnvTVarsLHS{\ltiEnv{a}}, \ltitvar{} \not\in \ltiEnvTVarsLHS{\ltiEnv{d}}]
    }
    {
      \ltiEnvMissingTVars{\ltiEnv{d}}{\ltiEnv{a}}{\ltiEnvConcat{\ltiEnv{d}}{\ova{\ltitvar{}}}}
    }


  \end{mathpar}
  \caption{Language-agnostic Metafunctions}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{\ltiresolve{\ltiInternalOrExternalLang{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
    \text{ Resolve top-level contextual types in \ltiT{} using \ltiEnv{} (in language \ltiInternalOrExternalLang{}).
    }
    }

    \begin{array}{lcl}
      \ltiresolvealign{\ltiInternalOrExternalLang{}}
                      {\ltiEnvp{}}
                      {\ltiSplitIFn{\ova{\ltiTpp{}}}
                                   {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}^n}}
                      {\ltiSplitIFn{\ova{\ltiTpp{}}\ 
                                    \ova{\ltiTp{}}}
                                   {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}}},
                                   \text{ where }
                                     \ova{\ltiTp{}} = 
                                     \{ \ltiTp{i} | i \in 1...n, 
                                        \ltiunifyContexts{\ltiInternalOrExternalLang{}}
                                                         {\ltistackmapping{\ltiEnv{i}}{\ltiT{i}}}
                                                         {\ltiEnvp{}}
                                                         {\ltiTp{i}}
                                                                          \}
                                   \\
      \ltiresolvealign{\ltiInternalOrExternalLang{}}
                      {\ltiEnv{}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                      {\ltiPoly{\ova{\ltitvar{}}}
                               {\ltiresolveLHS{\ltiInternalOrExternalLang{}}
                                              % FIXME is extending the environment correct here?
                                              {\ltiEnvConcat{\ltiEnv{}}{\ova{\ltitvar{}}}}
                                              {\ltiT{}}}}\\
      \ltiresolvealign{\ltiInternalOrExternalLang{}}
                      {\ltiEnv{}}
                      {\ltiMu{\ltitvar{}}{\ltiT{}}}
                      {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiresolveLHS{\ltiInternalOrExternalLang{}}{\ltiEnv{}}{\ltiT{}}}}\\
      \ltiresolvealign{\ltiInternalOrExternalLang{}}{\ltiEnv{}}{\ltiT{}}{\ltiT{}} \text{, otherwise}\\
    \end{array}

    \boxed{
    \infer[]
    {}
    {
    \ltiunifyContexts{\ltiInternalOrExternalLang{}}{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}{\ltiEnv{}}{\ova{\ltiS{}}}
    \text{ Use \ova{\ltiT{}}'s context \ltiEnvp{} to prepare \ova{\ltiT{}} for use in current context \ltiEnv{}
    (in language \ltiInternalOrExternalLang{}).
    }
    \\\\
    \text{Helper function also takes the already-processed prefix of the current context as second argument.
    }
    }
    }

    \infer[]
    {}
    {
      \ltiunifyContexts{\ltiInternalOrExternalLang{}}
                       {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                       {\ltiEnv{}}
                       {\ltiunifyContextsHLHS{\ltiInternalOrExternalLang{}}
                                             {\ltiEmptyEnv}
                                             {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                             {\ltiEnv{}}}
                                             }

    \begin{array}{lllll}
      \ltiunifyContextsHalign{\ltiInternalOrExternalLang{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEmptyEnv{}}{\ova{\ltiT{}}}}
                             {\ltiEnv{}}
                             {\ova{\ltiT{}}} \\
      \ltiunifyContextsHalign{\ltiInternalOrExternalLang{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEnvConcat{\ltitvarp{}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                             {\ltiEnvConcat{\ltitvar{}}{\ltiEnv{}}}
                             {\ltiunifyContextsHLHS{\ltiInternalOrExternalLang{}}
                                                   {\ltiEnvConcat{\ltiEnvpp{}}{\ltitvar{}}}
                                                   {\ltireplace{\ltitvar{}}{\ltitvarp{}}
                                                               {(\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}})}}
                                                   {\ltiEnv{}}}\\
      \ltiunifyContextsHalign{\ltiInternalOrExternalLang{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEnvConcat{\hastype{\ltivarp{}}{\ltiSp{}}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                            {\ltiEnvConcat{\hastype{\ltivar{}}{\ltiS{}}}{\ltiEnv{}}}
                            {\ltiunifyContextsHLHS{\ltiInternalOrExternalLang{}}
                                                  {\ltiEnvConcat{\ltiEnvpp{}}{\hastype{\ltivar{}}{\ltiS{}}}}
                                                  {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                                  {\ltiEnv{}}},
                                                 &\text{ if } \ltiLsubtypeEnv{\ltiInternalOrExternalLang{}}{\ltiEnvpp{}}{\ltiS{}}{\ltiSp{}}
    \end{array}

    \boxed{
    \infer[]
    {}
    {
    \ltiLfindTA{\ltiInternalOrExternalLang{}}{\ltiEnv{}}{\ova{\ltitvar{}}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}{\ova{\ltiRpp{}}}
    \text{ In context \ltiEnv{}, return the type arguments to substitute for \ova{\ltitvar{}} (in language \ltiInternalOrExternalLang{}).
    }
    }
    }

    \infer[]
    {
                  \ova{\ova{{\ltiR{k}^j}}^p}^m = \{ \ova{\ltiR{}} | i \in 1 ... n,
                        \ltiunifyContexts{\ltiInternalOrExternalLang{}}{\ltistackmapping{\ltiEnvp{i}}{\ova{\ltiRp{}}_i}}{\ltiEnv{}}{\ova{\ltiR{}}} \}
                  \\\\
                  1 \leq j \leq m 
                  \\ m > 0 
                  \\ p = |\ova{\ltitvar{}}|
                  \\ 1 \leq k \leq p
                  \\
                  \ova{\ltiRpp{}} = [\ltiMeetMany{{\ltiR{k}^1} ... {\ltiR{k}^m}} | k \in 1...p]
    }
    {
     \ltiLfindTA{\ltiInternalOrExternalLang{}}{\ltiEnv{}}{\ova{\ltitvar{}}}{\ova{\ltistackmapping{\ltiEnvp{i}}{\ova{\ltiRp{}}_i}}^n}{\ova{\ltiRpp{}}}
    }

  \end{mathpar}
  \caption{Metafunctions for internal and external language, where \ltiInternalOrExternalLang{} ranges over \ltiinternallabel{} and 
           \ltiexternallanglabel{}}
\end{figure}

\figref{symbolic:figure:internal-language-type-system}
presents the type system for this internal language.
The main judgment
\ltitjudgement{\ltiEnv{}}{\ltiE{}}{\ltiT{}} 
says that expression \ltiE{} is of type \ltiT{}
in environment \ltiEnv{}.

\subsection{External language}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt \ltiufun{\ltivar{}}{\ltiE{}}
                         \alt \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltilet{\ltivar{}}{\ltiE{}}{\ltiF{}} &\Leftrightarrow& \ltiapp{(\ltiufun{\ltivar{}}{\ltiF{}})}{\ltiE{}}
                      &\mbox{Term abbreviations} \\
\end{array}
$$
\caption{External Language Syntax}
\label{symbolic:figure:external-language-syntax}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed
    {
    \infer[]
    {}
    {
     \ltitSdjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiEp{}}
                     \\\\
     \text{External term \ltiE{} elaborates to internal term \ltiEp{}
           with type \ltiT{} under context \ltiEnv{}.
    }
    }
    }
    \\\\

    \infer [Var]
    {}
    {
       \ltitSdjudgement{\ltiEnv{}}
                       {\ltivar{}}
                       {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                       {\ltivar{}}
                 }

    \infer [Sel]
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiS{}}
                    {\ltiFp{}}
                     \\\\
    \ltiSdsubtype{\ltiEnv{}}{\ltiS{}}{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},...,\hastype{\ltivar{i}}{\ltiT{i}},...,\hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
                  {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }

    \infer [Rec]
    {
    \overrightarrow{
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiF{i}}
                    {\ltiT{i}}
                    {\ltiFp{i}}
                    }
                    ^{1 \leq i \leq n}
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiRec{\ova{\ltivar{} = \ltiF{}}^n}}
                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n}}
                    {\ltiRec{\ova{\ltivar{} = \ltiFp{}}^n}}
    }

    \infer [AppInf]
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiS{}^f}
                    {\ltiFp{}}
                    \\
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiS{}^a}
                    {\ltiEp{}}
                    \\\\
         \ltiunfold{\ltiS{}^f}
                    {\ltiPoly{\ova{\ltitvar{}}}
                             {\ltiSplitIFn{\ltiFn{\ltiT{}}{\ltiS{}}}
                                          }}
                  \\
                       |\ova{\ltitvar{}}|>0
                  \\\\
                  \forall \ltiRp{}.
                    (
                  \ltiSdsubtype{\ltiEnv{}}{\ltiS{}^a}{\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                  \text{ implies }
                  \ltiSdsubtype{\ltiEnv{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                               {\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                  )
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiapp{\ltiF{}}{\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    {\ltiappinst{\ltiFp{}}
                                {\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}
                                %\ \ova{\ltistackmapping{\ltiEnvpp{}}{\ova{\ltiRpp{}}}}
                                }
                                {\ltiEp{}}}
    }

    \infer [AppInst]
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiT{}^f}
                    {\ltiFp{}}
                    \\
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiTp{}}
                    {\ltiEp{}}
                  \\\\
                  \ltiSdsubtype{\ltiEnv{}}{
         \ltiresolveLHS{\ltiexternallanglabel}
                    {\ltiEnv{}}
                    {\ltiT{}^f}}
                    {
                    {\ltiPoly{\ova{\ltitvar{}}}{\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}
                                                            {\ova{\ltiContextualFn{\ltiEnvpp{}}{\ltiTpp{}}{\ltiSpp{}}}}}}
                                                            }
                  \\\\
                  m > 0
                  \\
                  \ltiLfindTA{\ltiexternallanglabel}{\ltiEnv{}}{\ova{\ltitvar{}}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}{\ova{\ltiR{}}}
                  \\\\
                  \ova{\ltiSp{}}^m
                  =
                  \{ \ltiS{i}\ |\ i \in 1 ... n, \ltiisubtype{\ltiEnv{}}{\ltiT{}^a}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{i}}}
                  \}
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiappinst{\ltiF{}}
                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                                {\ltiE{}}}
                    {\ltiMeetMany{\ova{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}}}
                    {\ltiappinst{\ltiFp{}}
                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                                {\ltiEp{}}}
    }


    \infer [Abs]
    {
    \ltiunfold{\ltiTp{}}{\ltiPoly{\ova{\ltitvar{}}}
                                    {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{1...n}}
                                                 {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiT{}}{\ltiS{}}}^{n+1...m}}}}
    \\\\
                     m>0
                     \\
    \overrightarrowcaption{
     \ltitSdjudgement{\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}{\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     }^{1 \leq i \leq n}
                     \\\\
    \overrightarrowcaption{
     \ltitSdjudgement{\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnv{}}{\ltiEnvp{i}}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     }^{n < i \leq m}
                     \\\\
                     \overrightarrowcaption{\ltiSdsubtype{\ltiEnv{}}{\ltiSp{i}}
                                                  {\ltiS{i}}
                                                  ,
                                                  \ 
                                                  \ltimergeTaggedTerms{\ltiEp{i-1}}{\ltiE{i}}{\ltiEp{i}}
                                                  }^{1 \leq i \leq m}
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{0}}}
                    {\ltiTp{}}
                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{m}}}
                 }

    \infer [UAbs]
    {
    \ltiunfold{\ltiTp{}}{\ltiPoly{\ova{\ltitvar{}}}
                                    {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{1...n}}
                                                 {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiT{}}{\ltiS{}}}^{n+1...m}}}}
    \\\\
                     m>0
                     \\
    \overrightarrowcaption{
     \ltitSdjudgement{\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}{\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     }^{1 \leq i \leq n}
                     \\\\
    \overrightarrowcaption{
     \ltitSdjudgement{\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnv{}}{\ltiEnvp{i}}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     }^{n < i \leq m}
                     \\\\
                     \overrightarrowcaption{\ltiSdsubtype{\ltiEnv{}}{\ltiSp{i}}
                                                  {\ltiS{i}}
                                                  ,
                                                  \ \ltimergeTaggedTerms{\ltiEp{i-1}}{\ltiE{i}}{\ltiEp{i}}
                                                  }^{1 \leq i \leq m}
    }
    {
    \ltitSdjudgement{\ltiEnv{}}
                    {\ltiufun{\ltivar{}}{\ltiEp{0}}}
                    {\ltiTp{}}
                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{m}}}
                 }

  \end{mathpar}

  \caption{Declarative Type system for External Language
  }
  \label{symbolic:figure:external-language-declarative-type-system}
\end{figure}

\begin{figure}
  \begin{mathpar}
                 \infer[S-Refl]
                 {}
                 {
                 \ltiSdsubtype{\ltiEnv{}}{\ltiT{}}{\ltiT{}}
                 }

                 \infer[S-Trans]
                 {
                 \ltiSdsubtype{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}
                 \\
                 \ltiSdsubtype{\ltiEnv{}}{\ltiSp{}}{\ltiT{}}
                 }
                 {
                 \ltiSdsubtype{\ltiEnv{}}{\ltiS{}}{\ltiT{}}
                 }

    \infer [S-Top]
    {}
    { \ltiSdsubtype{\ltiEnv{}}{\ltiT{}}{\Top}}

    \infer [S-Bot]
    {}
    { \ltiSdsubtype{\ltiEnv{}}{\Bot}{\ltiT{}}}

    \infer [S-Rec]
    {
      \ltiSdsubtype{\ltiEnv{}}{\ltiT{i}}{\ltiS{i}}
    }
    {
    \ltiSdsubtype{\ltiEnv{}}
                {\ltiRec{\ova{\hastype{\ltivar{i}}{\ltiT{i}}},
                         \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                {\ltiRec{\ova{\hastype{\ltivar{i}}{\ltiS{i}}}}}
    }

    \infer [S-IFn]
    {
      \ltiSdsubtype{\ltiEnv{}}{\ltiS{i}}{\ltiSp{i}}
      \\
      \ltiSdsubtype{\ltiEnv{}}{\ltiT{i}}{\ltiTp{i}}
    }
    { \ltiSdsubtype{\ltiEnv{}}{\ltiIFn{\ova{\ltiFn{\ltiSp{i}}{\ltiT{i}}}\ \ova{\ltiFn{\ltiSpp{}}{\ltiTpp{}}}}}
                   {\ltiIFn{\ova{\ltiFn{\ltiS{i}}{\ltiTp{i}}}}}
       }

    \infer [S-Poly]
    {\ltiSdsubtype{\ltiEnv{}}{\ltiT{}}
                  {\ltiS{}}
    }
    {\ltiSdsubtype{\ltiEnv{}}{\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiS{}}}
                  }

    \infer [S-Mu]
    {}
    {\ltiSdsubtype{\ltiEnv{}}{\ltiMu{\ltitvar{}}{\ltiT{}}}
                  {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}
                  }
  \end{mathpar}

  \caption{External Language Declarative Subtyping:
      \ltiSdsubtype{\ltiEnv{}}{\ltiS{}}{\ltiT{}}
  }
  \label{symbolic:figure:external-language-declarative-subtyping}
\end{figure}

\subsection{Symbolic Closure language}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufunelab{\ova{\ltiufunelabentry{\ltiClosureID{}}}}
                                     {\ltivar{}}
                                     {\ltiE{}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& ... \alt \ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureID{}}{\ltiufun{\ltivar{}}{\ltiE{}}}
                      &\mbox{Types} \\
  \ltiClosureID{} &::=& \ltitvar{}
                      &\mbox{Closure Identifiers} \\
  \ltiFuel{} &::=& \ltinat{}
                      &\mbox{Closure Fuel} \\
  \ltiClosureCache{} &::=& \ova{\ltiClosureID{} \Rightarrow {\ltiClosureCacheVal{\ltiSplitIFn{}
                                                                                 {\ova{\ltiContextualFn{\ltiEnv{}}{\ltiT{}}{\ltiT{}}}}}
                                                                                {\ltiE{}}}}
                      &\mbox{Closure Cache} \\
  \ltiCombinedThreadedEnv{} &::=& \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
                      &\mbox{Combined Threaded Environments} \\
\end{array}
$$
\caption{Symbolic Closure Language Syntax}
\label{symbolic:figure:SC-language-syntax}
\end{figure}


\begin{figure}
  \begin{mathpar}
    \boxed
    {
    \infer[]
    {}
    {
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}{\ltiClosureCachep{}}}
                      {\ltiEp{}}
                     \\\\
                     \text{Given fuel \ltiFuel{}, closure cache \ltiClosureCache{},
                     and context \ltiEnv{}, external term \ltiE{} 
                     is of symbolic-closure-language type \ltiT{}
                     }
                     \\\\
                     \text{
                     with updated fuel \ltiFuelp{} and closure cache \ltiClosureCachep{},
                     and elaborated symbolic-closure-language term \ltiEp{}.
                     }
                     }
                     }

    \infer [AppInst]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}^f}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}^a}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiresolveSC{\ltiCombinedThreadedEnv{3}}
               {\ltiEnv{}}
               {\ltiT{}^f}
               {\ltiPoly{\ova{\ltitvar{}}}
                        {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{n}}
                                     {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiTpp{}}{\ltiSpp{}}}}}}
               {\ltiCombinedThreadedEnv{4}}
                  \\\\
                  \ltiSfindTA{\ltiCombinedThreadedEnv{4}}
                             {\ltiEnv{}}
                             {\ova{\ltitvar{}}}
                             {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                             {\ova{\ltiR{}}}
                             {\ltiCombinedThreadedEnvp{0}}
    \\\\
     c_0 = 0 \\ c_n > 1
    \\\\
    \overrightarrowcaption{
      (\ltiSp{i}, \ltiCombinedThreadedEnvp{i}, c_i)
        = \left\{
                     \begin{array}{llll}
                       (\ltiS{i}, \ltiCombinedThreadedEnvp{i}, 1+c_{i-1})
                       , &\text{if } \ltiSsubtype{\ltiCombinedThreadedEnvp{i-1}}
                                                 {\ltiEnv{}}
                                                 {\ltiT{}^a}
                                                 {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{i}}}
                                                 {\ltiCombinedThreadedEnvp{i}}
                                                  \arcr
                       (\ltiTop, \ltiCombinedThreadedEnvp{i-1}, c_{i-1}),  &\text{otherwise}
                     \end{array}
                   \right.
                   }^{1 \leq i \leq n}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                                  {\ltiE{}}}
                      {\ltiMeetMany{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ova{\ltiSp{}}}}}
                      {\ltiCombinedThreadedEnvp{n}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                                  {\ltiEp{}}}
    }

    \infer [Var]
    {}
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltivar{}}
                      {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                      {\ltiCombinedThreadedEnv{}}
                      {\ltivar{}}
                 }

    \infer [AppInf-Closure]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiTpp{}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuel{}}
                                                  {\ltiClosureCache{}}}
                      {\ltiEp{}}
                  \\\\
    \ltiunfold{\ltiTpp{}}{\ltiClosureWithStkID{\ltiEnvp{}}
                                              {\ltiClosureID{}}
                                              {\ltiufun{\ltivar{}}{\ltiEpp{}}}}
                                              \\\\
    0 < \ltiFuel{}
    \\\\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                  {\ltiClosureCache{}}}
                      {\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnvp{}}{\ltiEnv{}}}{\hastype{\ltivar{}}{\ltiTp{}}}}
                      {\ltiEpp{}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                  {\ltiClosureCachep{}}}
                      {\ltiFpp{}}
                      \\\\
    \ltiupdateClosureCache{\ltiClosureCachep{}}{\ltiEnv{}}{\ltiClosureID{}}{\ltiTp{}}{\ltiS{}}{\ltiFpp{}}{\ltiClosureCachepp{}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                  {\ltiClosureCachepp{}}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }

    \infer [AppInf\Bot]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{3}}{\ltiEnv{}}{\ltiT{}}{\ltiBot}{\ltiCombinedThreadedEnv{4}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiTpp{}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }

    \infer [AppInst\Bot]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltiCombinedThreadedEnv{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnv{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{3}}{\ltiEnv{}}{\ltiT{}}{\ltiBot}{\ltiCombinedThreadedEnv{4}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{1}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltistackmapping{\ltiEnv{j}}{\ova{\ltiR{}}_j}}}
                                  {\ltiE{}}}
                      {\ltiTpp{}}
                      {\ltiCombinedThreadedEnv{4}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltistackmapping{\ltiEnv{j}}{\ova{\ltiR{}}_j}}}
                                  {\ltiEp{}}}
    }

    \infer [Sel]
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiS{}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltiFp{}}
                      \\\\
    \ltiunfold{\ltiS{}}
              {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},..., \hastype{\ltivar{i}}{\ltiT{i}},..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{i}}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnvp{}}
                      {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }

    \infer [Rec]
    {
    \overrightarrowcaption{
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{i-1}}
                      {\ltiEnv{}}
                      {\ltiF{i}}
                      {\ltiT{i}}
                      {\ltiCombinedThreadedEnv{i}}
                      {\ltiFp{i}}
                      }^{ 1 \leq i \leq n}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{0}}
                      {\ltiEnv{}}
                      {\ltiRec{\ova{\ltivar{} = \ltiF{}}^n}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n}}
                      {\ltiCombinedThreadedEnv{n}}
                      {\ltiRec{\ova{\ltivar{} = \ltiFp{}}^n}}
    }

    \infer [Abs]
    {
    \ltiunfold{\ltiTp{}}{\ltiPoly{\ova{\ltitvar{}}}
                                    {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{1...n}}
                                                 {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiT{}}{\ltiS{}}}^{n+1...m}}}}
    \\\\
                     m>0
                     \\
    \overrightarrowcaption{
     \ltitSstkjudgement{\ltiCombinedThreadedEnv{i-1}}
                     {\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}{\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     {\ltiCombinedThreadedEnv{i}}
                     }^{1 \leq i \leq n}
                     \\\\
    \overrightarrowcaption{
     \ltitSstkjudgement{\ltiCombinedThreadedEnv{i-1}}
                    {\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnv{}}{\ltiEnvp{i}}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{i}}}}}
                     {\ltiEp{0}}
                     {\ltiSp{i}}
                     {\ltiE{i}}
                     {\ltiCombinedThreadedEnv{i}}
                     }^{n < i \leq m}
                     \\\\
                     \ltiCombinedThreadedEnvp{0} = \ltiCombinedThreadedEnv{m}
                     \\\\
                     \overrightarrowcaption{
                        \ltiSsubtype{\ltiCombinedThreadedEnvp{i-1}}
                                                  {\ltiEnv{}}
                                                  {\ltiSp{i}}
                                                  {\ltiS{i}}
                                                  {\ltiCombinedThreadedEnvp{i}}
                                                  ,
                                                  \ 
                                                  \ltimergeTaggedTerms{\ltiEp{i-1}}{\ltiE{i}}{\ltiEp{i}}
                                                  }^{1 \leq i \leq m}
    }
    {
    \ltitSstkjudgement{\ltiCombinedThreadedEnv{0}}
                    {\ltiEnv{}}
                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{0}}}
                    {\ltiTp{}}
                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{m}}}
                    {\ltiCombinedThreadedEnvp{m}}
                 }

    \infer [UAbs]
    {
    \ltiClosureID{} \not\in dom(\ltiClosureCache{1})
    \\\\
    \ltiClosureCache{2}
    =
    \ltimapsto{\ltiClosureCache{1}}
              {\ltiClosureID{}}
              {\ltiClosureCacheVal{\ltiEmptyIFn}{\ltiE{}}}
              \\\\
    0 < \ltiFuel{}
    \\\\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                  {\ltiClosureCache{2}}}
                      {\ltiEnvConcat{\ltiEnv{}}{\hastype{\ltivar{}}{\ltiBot}}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                  {\ltiClosureCache{3}}}
                      {\ltiEp{}}
                      \\\\
    \ltiupdateClosureCache{\ltiClosureCache{3}}{\ltiEnv{}}{\ltiClosureID{}}{\ltiBot}{\ltiS{}}{\ltiEp{}}{\ltiClosureCache{4}}
    }
    {
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}
                                                  {\ltiClosureCache{1}}}
                      {\ltiEnv{}}
                      {\ltiufun{\ltivar{}}{\ltiE{}}}
                      {\ltiClosureWithStkID
                                           {\ltiEnv{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                  {\ltiClosureCache{4}}}
                      {\ltiufunelab{\ltiClosureID{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
                 }
  \end{mathpar}

  \caption{Algorithmic Type system for Symbolic Closure Language (\textsc{AppInf} omitted)
  }
  \label{symbolic:figure:SC-language-algorithmic-type-system}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [S-Refl]
    {}
    {
     \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltiT{}}
                 {\ltiT{}}
                 {\ltiCombinedThreadedEnv{}}
    }

    \infer [S-Top]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiT{}}{\Top}{\ltiCombinedThreadedEnv{}}}

    \infer [S-Bot]
    {}
    { \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\Bot}{\ltiT{}}{\ltiCombinedThreadedEnv{}}}

    \infer [S-Rec]
    {
    \overrightarrow{\ltiSsubtype{\ltiCombinedThreadedEnv{i-1}}{\ltiEnv{}}
                                {\ltiT{}}
                                {\ltiS{}}
                                {\ltiCombinedThreadedEnv{i}}
                                }
    }
    {
    \ltiSsubtype{\ltiCombinedThreadedEnv{0}}
                {\ltiEnv{}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n,
                         \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}^n}}
                {\ltiCombinedThreadedEnv{n}}
    }

    \infer [S-Poly]
    {
    \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                {\ltiEnvConcat{\ltiEnv{}}{\ova{\ltitvar{}}}}
                {\ltiT{}}
                {\ltiS{}}
                {\ltiCombinedThreadedEnvp{}}
    }
    {
    \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                {\ltiEnv{}}
                {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                {\ltiPoly{\ova{\ltitvar{}}}{\ltiS{}}}
                {\ltiCombinedThreadedEnvp{}}
    }

    % eg (IFn [Int -> Int] [Number -> Number]) <: [Nothing -> Any]
    \infer [S-Fn]
    { \ltiSsubtype{\ltiCombinedThreadedEnv{1}}{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}{\ltiCombinedThreadedEnv{2}}
      \\
      \ltiSsubtype{\ltiCombinedThreadedEnv{2}}{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}{\ltiCombinedThreadedEnv{3}}
    }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{1}}{\ltiEnv{}}
                  {\ltiFn{\ltiSp{}}{\ltiT{}}}
                  {\ltiFn{\ltiS{}}{\ltiTp{}}}
                  {\ltiCombinedThreadedEnv{3}}
       }

    \infer [S-IFnL]
    { \ltiCombinedThreadedEnvp{}
    \in
    \{ \ltiCombinedThreadedEnv{i} |
    \ltiSsubtype{\ltiCombinedThreadedEnv{0}}{\ltiEnv{}}
                  {\ltiT{i}}
                  {\ltiS{}}
                  {\ltiCombinedThreadedEnv{i}}
                  \}
    }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{0}}{\ltiEnv{}}
                  {\ltiIFn{\ova{\ltiT{}}}}
                  {\ltiS{}}
                  {\ltiCombinedThreadedEnvp{}}
    }

    \infer [S-IFnR]
    { \ltiSsubtype{\ltiCombinedThreadedEnv{i-1}}{\ltiEnv{}}
                  {\ltiT{}}
                  {\ltiS{i}}
                  {\ltiCombinedThreadedEnv{i}}
                                  }
    { \ltiSsubtype{\ltiCombinedThreadedEnv{0}}{\ltiEnv{}}
                  {\ltiT{}}
                  {\ltiIFn{\ova{\ltiS{}}^n}}
                  {\ltiCombinedThreadedEnv{n}}
                  }

    \infer [S-Closure]
    {
    0 < \ltiFuel{}
    \\\\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                  {\ltiClosureCache{}}}
                      {\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnvp{}}{\ltiEnv{}}}{\hastype{\ltivar{}}{\ltiT{}}}}
                      {\ltiE{}}
                      {\ltiSp{}}
                      {\ltiCombinedThreadedEnv{}}
                      {\ltiEp{}}
                      \\\\
    \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiSp{}}{\ltiS{}}
                {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                            {\ltiClosureCachep{}}}
                      \\\\
    \ltiupdateClosureCache{\ltiClosureCachep{}}{\ltiEnv{}}{\ltiClosureID{}}{\ltiT{}}{\ltiS{}}{\ltiEp{}}{\ltiClosureCachepp{}}
    }
    { \ltiSsubtype{\ltimakeCombinedThreadedEnv{\ltiFuel{}}
                                              {\ltiClosureCache{}}}
                  {\ltiEnv{}}
                  {\ltiClosureWithStkID
                                       {\ltiEnvp{}}
                                       {\ltiClosureID{}}
                                       {\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiFn{\ltiT{}}{\ltiS{}}}
                  {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                              {\ltiClosureCachepp{}}}
                  }

  \end{mathpar}

  \caption{Algorithmic Subtyping for Symbolic Closure Language:
                 \ltiSsubtype{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}{\ltiCombinedThreadedEnv{}}.
  }
  \label{symbolic:figure:SC-language-subtype}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
    \ltiunifyContextsSC{\ltiCombinedThreadedEnv{}}{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}{\ltiEnv{}}{\ova{\ltiS{}}}{\ltiCombinedThreadedEnvp{}}
    \text{ Use \ova{\ltiT{}}'s context \ltiEnvp{} to prepare \ova{\ltiT{}} for use in current context \ltiEnv{}.
    }
    \\\\
    \text{Helper function also takes the already-processed prefix of the current context as second argument.
    }
    }
    }

    \infer[]
    {}
    {
      \ltiunifyContextsSCLHS{\ltiCombinedThreadedEnv{}}
                       {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                       {\ltiEnv{}}
                       =
                       {\ltiunifyContextsHSCLHS{\ltiCombinedThreadedEnv{}}
                                               {\ltiEmptyEnv}
                                               {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                               {\ltiEnv{}}}
                                             }

    \begin{array}{lllll}
      \ltiunifyContextsHSCalign{\ltiCombinedThreadedEnv{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEmptyEnv{}}{\ova{\ltiT{}}}}
                             {\ltiEnv{}}
                             {\ltiunifyContextsHSCRHS{\ova{\ltiT{}}}
                                                     {\ltiCombinedThreadedEnv{}}}
                                                     \\
      \ltiunifyContextsHSCalign{\ltiCombinedThreadedEnv{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEnvConcat{\ltitvarp{}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                             {\ltiEnvConcat{\ltitvar{}}{\ltiEnv{}}}
                             {\ltiunifyContextsHSCLHS{\ltiCombinedThreadedEnv{}}
                                                   {\ltiEnvConcat{\ltiEnvpp{}}{\ltitvar{}}}
                                                   {\ltireplace{\ltitvar{}}{\ltitvarp{}}
                                                               {(\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}})}}
                                                   {\ltiEnv{}}}\\
      \ltiunifyContextsHSCalign{\ltiCombinedThreadedEnv{}}
                             {\ltiEnvpp{}}
                             {\ltistackmapping{\ltiEnvConcat{\hastype{\ltivarp{}}{\ltiSp{}}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                            {\ltiEnvConcat{\hastype{\ltivar{}}{\ltiS{}}}{\ltiEnv{}}}
                            {\ltiunifyContextsHSCLHS{\ltiCombinedThreadedEnvp{}}
                                                  {\ltiEnvConcat{\ltiEnvpp{}}{\hastype{\ltivar{}}{\ltiS{}}}}
                                                  {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                                  {\ltiEnv{}}},
                                                 \text{ if } \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                                                                          {\ltiEnvpp{}}
                                                                          {\ltiS{}}
                                                                          {\ltiSp{}}
                                                                          {\ltiCombinedThreadedEnvp{}}
    \end{array}

    \boxed{
    \infer[]
    {}
    {
           \ltiSfindTA{\ltiCombinedThreadedEnv{}}
                      {\ltiEnv{}}
                      {\ova{\ltitvar{}}}
                      {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
                      {\ova{\ltiR{}}}
                      {\ltiCombinedThreadedEnvp{}}
                      \\
     \text{ With initial environments \ltiCombinedThreadedEnv{} and \ltiEnv{}, 
     return the actual type arguments \ova{\ltiR{}} to provide for \ova{\ltitvar{}}.
    }
    }
    }

    \infer[]
    {
    \ova{\ltiRp{}}_0 = \varnothing\\
    \overrightarrowcaption{
    (\ova{\ova{\ltiRp{}}}_i, \ltiCombinedThreadedEnv{i})
    = \left\{
                     \begin{array}{llll}
                       (\ova{\ova{\ltiRp{}}}_{i-1} \ova{\ltiR{}}_i, &\ltiCombinedThreadedEnv{i})
                       , & \text{ if }
                        \ltiunifyContextsSC{\ltiCombinedThreadedEnv{i-1}}
                                           {\ltistackmapping{\ltiEnv{i}}{\ova{\ltiRp{}}_i}}
                                           {\ltiEnv{}}
                                           {\ova{\ltiR{}}_i}
                                           {\ltiCombinedThreadedEnv{i}}
                                           \\
                       (\ova{\ova{\ltiRp{}}}_{i-1}, &\ltiCombinedThreadedEnv{i-1})
                       , & \text{ otherwise}
                     \end{array}
      \right.
    }^{1 \leq i \leq n}
    \\\\
                  \ova{\ova{\ltiRp{}}}_n
                  =
                  (\ltiR{1}^1, ...,\ltiR{p}^1)
                  ,...,
                  (\ltiR{1}^m ,..., \ltiR{p}^m)
                  \\ m > 0 
                  \\ p = |\ova{\ltitvar{}}|
                  \\
                  \ova{\ltiRpp{}} = [\ltiMeetMany{\ltiR{k}^1 ... \ltiR{k}^m} | k \in 1...p]
                  }
    { \ltiSfindTA{\ltiCombinedThreadedEnv{0}}
                 {\ltiEnv{}}
                 {\ova{\ltitvar{}}}
                 {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}^n}
                 {\ova{\ltiRpp{}}}
                 {\ltiCombinedThreadedEnv{n}}
                 }


  \end{mathpar}

  \[
    \boxed{\ltimergeTaggedTerms{\ltiE{1}}{\ltiE{2}}{\ltiE{3}}
    \text{ Recursively merges \ltiE{1} and \ltiE{2}, appending Closure tags.}
    }
    \]

  $$
  \begin{array}{llll}

    \ltimergeTaggedTermsalign{\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltiE{1}}}
                             {\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltiE{2}}}
                             {\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
                             \\
    \ltimergeTaggedTermsalign{\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^n}
                                     {\ltivar{}}
                                     {\ltiE{1}}}
                             {\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^m}
                                     {\ltivar{}}
                                     {\ltiE{2}}}
                             {\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^n
                                           \ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^m
                                                            }
                                     {\ltivar{}}
                                     {\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltiappinst{\ltiF{1}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^n}{\ltiE{1}}}
                             {\ltiappinst{\ltiF{2}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^m}{\ltiE{2}}}
                             {\ltiappinst{\ltimergeTaggedTermsLHS{\ltiF{1}}{\ltiF{2}}}
                                         {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^n 
                                          \ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^m}
                                         {\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltisel{\ltiE{1}}{\ltivar{}}}
                             {\ltisel{\ltiE{2}}{\ltivar{}}}
                             {\ltisel{\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}{\ltivar{}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltiRec{\ova{\ltivar{} = \ltiE{}}}}
                             {\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                             {\ltiRec{\ova{\ltivar{} = \ltimergeTaggedTermsLHS{\ltiE{}}{\ltiF{}}}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltivar{}}
                             {\ltivar{}}
                             {\ltivar{}}
                                     \\
  \end{array}
  $$

  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiupdateClosureCache{\ltiClosureCache{}}{\ltiEnv{}}{\ltiClosureID{}}{\ltiT{}}{\ltiS{}}{\ltiE{}}{\ltiClosureCachep{}}
    \\\\
    \text{ Record closure \ltiClosureID{} as \ltiFn{\ltiT{}}{\ltiS{}} under application context \ltiEnv{}, with elaboration \ltiE{}.
    }}
    }

    \\
    \infer[]
    {
    \ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = \ltiClosureCacheVal{\ltiSplitIFn{}{\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiTp{}}{\ltiSp{}}}}}
                                                                         {\ltiF{}}
    \\\\
    \ltiClosureCachep{} = \ltimapsto{\ltiClosureCache{}}
                                    {\ltiClosureID{}}
                                    {\ltiClosureCacheVal{\ltiSplitIFn{}
                                                         {\ltiContextualFn{\ltiEnv{}}{\ltiT{}}{\ltiS{}}\ 
                                                          \ova{\ltiContextualFn{\ltiEnvp{}}{\ltiTp{}}{\ltiSp{}}}}}
                                                        {\ltimergeTaggedTermsLHS{\ltiE{}}{\ltiF{}}}}
    }
    {\ltiupdateClosureCache{\ltiClosureCache{}}{\ltiEnv{}}{\ltiClosureID{}}{\ltiT{}}{\ltiS{}}{\ltiE{}}{\ltiClosureCachep{}}
    }
  \end{mathpar}
  \caption{Metafunctions for Symbolic Closure language}
\end{figure}

\begin{figure}

  \[
    \boxed{\ltielabDriver{\ltiE{}}{\ltiEp{}}
    \text{ Elaborates \ltiE{} from external language to \ltiEp{} in internal language.
    }
    }
  \]

  \begin{mathpar}
    \infer[ElabDriver]
    {
     \exists \ltiFuel{}.\ 
     \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                       {\ltiEmptyEnv}
                       {\ltiE{1}}
                       {\ltiT{}}
                       {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                   {\ltiClosureCache{}}}
                       {\ltiE{2}}
                       \\
     \ltielimClos{\ltiClosureCache{}}{\ltiE{2}}{\ltiE{3}}
    }
    {
    \ltielabDriver{\ltiE{1}}{\ltiE{3}}
    }
  \end{mathpar}

  \[
    \boxed{\ltielimClos{\ltiClosureCache{}}{\ltiE{}}{\ltiEp{}}
    \text{ Converts symbolic closures in \ltiE{} to explicit types in \ltiEp{}}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosalign{\ltiClosureCache{}}{\ltivar{}}
                     {\ltivar{}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltiappinst{\ltiF{}}
                                 {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}
                                 {\ltiE{}}}
                     {\ltiappinst{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}
                                 {\ova{\ltistackmapping{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}
                                                       {\ova{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiR{}}}}}}
                                 {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
                             \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltisel{\ltiF{}}{\ltivar{}}}
                     {\ltisel{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}{\ltivar{}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                     {\ltiRec{\ova{\ltivar{} = \ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltiE{}}}
                     {\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
  \end{array}
  \]

  \begin{mathpar}
    \infer [Elab-UAbs]
    {
    n>0
    \\
    1 \leq i \leq n
    \\
    \overrightarrow{
    \ltilookup{\ltiClosureCache{}}{\ltiClosureID{i}} = 
      \ltiClosureCacheVal{\ltiSplitIFn{}{\overrightarrow{\ltiContextualFn{\ltiEnv{j}^i}{\ltiT{j}^i}{\ltiS{j}^i}}}}{\ltiF{i}}
    }
    \\
    \overrightarrow{
    \ltimergeTaggedTerms{\ltiE{i-1}}{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{i}}}{\ltiE{i}}
    }
    \\\\
    % this unrolls recursive symbolic closure types once, at the benefit of not duplicating
    % the freshening conditions in elimClosT
    \ltiT{} =  \ltiSplitIFn{}{\overrightarrow
                              {\overrightarrow{\ltiContextualFn{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{j}^i}}
                                                    {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{j}^i}}
                                                    {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiS{j}^i}}}}} 
    }
    { \ltielimClos{\ltiClosureCache{}}
                  {\ltiufunelab{\ova{\ltiufunelabentry{\ltiClosureID{}}}^n}
                               {\ltivar{}}
                               {\ltiE{0}}}
                  {\ltifuninterface{\ltiT{}}{\ltivar{}}{\ltiE{n}}}
                  }
  \end{mathpar}


  \[
    \boxed{\ltielimClosEnv{\ltiClosureCache{}}{\ltiEnv{}}{\ltiEnvp{}}
    \text{ Eliminates symbolic closures in \ltiEnv{} using \ltiClosureCache{}.
    }
    }
  \]

  \[
  \begin{array}{llllll}
    \ltielimClosEnvalign{\ltiClosureCache{}}{\ltiEmptyEnv}{\ltiEmptyEnv}
    \\
    \ltielimClosEnvalign{\ltiClosureCache{}}
                        {\ltiEnvConcat{\hastype{\ltivar{}}{\ltiT{}}}{\ltiEnv{}}}
                        {\ltiEnvConcat{\hastype{\ltivar{}}{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}}
                                      {\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}}
    \\
    \ltielimClosEnvalign{\ltiClosureCache{}}
                        {\ltiEnvConcat{\ltitvar{}}{\ltiEnv{}}}
                        {\ltiEnvConcat{\ltitvar{}}
                                      {\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}}
  \end{array}
  \]

  \[
    \boxed{\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    \text{ Converts symbolic closures in \ltiT{} to explicit types in \ltiTp{}}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltitvar{}}{\ltitvar{}}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiTop}{\ltiTop}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiBot}{\ltiBot}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}}
                                   {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiTp{}}{\ltiSp{}}}}}
                      {\ltiSplitIFn{\ova{\ltiFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}
                                               {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiS{}}}}}
                                   {\ova{\ltiContextualFn{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnvp{}}}
                                                         {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiTp{}}}
                                                         {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiSp{}}}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiMu{\ltitvar{}}{\ltiT{}}}
                      {\ltiMu{\ltitvar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}
                      , \ltitvar{} \not\in \ova{\ltiClosureID{}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}
                      , \ova{\ltitvar{}} \cap \ova{\ltiClosureID{}} = \varnothing
  \end{array}
  \]

  \begin{mathpar}

    \infer[Elab-UnseenClosure]
    {
    \ltiClosureIDp{} \not\in \ova{\ltiClosureID{}}
    \\
    \ltilookup{\ltiClosureCache{}}{\ltiClosureIDp{}} = \ltiClosureCacheVal{\ltiT{}}{\ltiF{}}
    \\\\
    \ltiClosureID{} \not\in \ltifvLHS{\ltiT{}}
    \\
    \ltielimClosT{(\ltiClosureIDp{}, \ova{\ltiClosureID{}})}
                 {\ltiClosureCache{}}
                 {\ltiT{}}
                 {\ltiS{}}
    }
    {\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                  {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiMu{\ltiClosureIDp{}}
                         {\ltiS{}}}
                  }

    \infer[Elab-SeenClosure]
    {
    \ltiClosureIDp{} \in \ova{\ltiClosureID{}}
    }
    {\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                  {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiClosureIDp{}}
                  }
  \end{mathpar}
  \caption{Elaboration Metafunctions for Symbolic Closure language}
\end{figure}

\subsection{External Language with type-argument synthesis}

\subsection{External Language with bidirectional checking}

\begin{figure}
$$
\begin{array}{lrll}
%  \ltiE{}, \ltiF{} &::=& ... \alt
%                         \ltiufun{\ltivar{}}{\ltiE{}} \alt
%                         \ltiapp{\ltiF{}}{\ltiE{}}
%                      &\mbox{Terms} \\
%  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
%                         \ltiSyn{\ltitvar{}} \alt
%                         \ltiSyn{\ltiTop} \alt
%                         \ltiSyn{\ltiBot} \alt
%                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSyn{\ltiT{1}}}, ..., \hastype{\ltivar{n}}{\ltiSyn{\ltiT{n}}}}}
%                         \\&\alt&
%                         \ltiSyn{\ltiArrowMono{\ltiSyn{\ltiT{}}}{\ltiSyn{\ltiS{}}}} \alt
%                         \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
%                      &\mbox{Synthesized types} \\
%  \ltiChk{\ltiT{}}, \ltiChk{\ltiS{}}, \ltiChk{\ltiR{}} &::=& 
%                         \ltiChk{\ltitvar{}} \alt
%                         \ltiChk{\ltiTop} \alt
%                         \ltiChk{\ltiBot} \alt
%                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiChk{\ltiT{1}}}, ..., \hastype{\ltivar{n}}{\ltiChk{\ltiT{n}}}}}
%                         \\&\alt&
%                         \ltiChk{\ltiArrowMono{\ltiChk{\ltiT{}}}{\ltiChk{\ltiS{}}}} \alt
%                         \ltiChk{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
%                      &\mbox{Inherited types} \\
%  \ltiSynChk{\ltiT{}}, \ltiSynChk{\ltiS{}}, \ltiSynChk{\ltiR{}} &::=& 
%                         \ltiSyn{\ltitvar{}} \alt
%                         \ltiSyn{\ltiTop} \alt
%                         \ltiSyn{\ltiBot} \alt
%                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},...,\hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
%                                    \\&\alt&
%                         \ltiSyn{\ltiArrowMono{\ltiSynChk{\ltiT{}}}{\ltiSynChk{\ltiS{}}}} \alt
%                         \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
%                                    \\&\alt&
%                         \ltiChk{\ltitvar{}} \alt
%                         \ltiChk{\ltiTop} \alt
%                         \ltiChk{\ltiBot} \alt
%                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},...,\hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
%                         \\&\alt&
%                         \ltiChk{\ltiArrowMono{\ltiSynChk{\ltiT{}}}{\ltiSynChk{\ltiS{}}}} \alt
%                         \ltiChk{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
%                      &\mbox{Colored types} \\
\ltiSynChk{\ltiT{}}, \ltiSynChk{\ltiS{}}, \ltiSynChk{\ltiR{}} &::=& 
                         \ltiSynChk{\ltitvar{}} \alt
                         \ltiSynChk{\ltiTop} \alt
                         \ltiSynChk{\ltiBot} \alt
                         \ltiSynChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},...,\hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                                    \\&\alt&
                         \ltiSynChk{\ltiArrow{\ltiSynChk{\ltiT{}}}{\ova{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}} \alt
                         \ltiSynChk{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{Colored types} \\
  \ltiEnv{} &::=& \hastype{\ltivar{}}{\ltiSyn{\ltiT{}}} \alt
                  \ltiEmptyEnv \alt
                  \ltiSyn{\ltitvar{}} \alt
                  \ltiEnvConcat{\ltiEnv{}}{\ltiEnvp{}}
                      &\mbox{Environments} \\
  \ltiFuel{} &::=& \ltinat{}
                      &\mbox{Fuel} \\
\end{array}
$$
\caption{Colored Type System Syntax (External Language),
  where $\ltinat{} \in \mathbb{N}$.
A type constructor's color \ltiSynChk{} stands for exactly one of either a blue up-tick \ltiSyn{} (``synthesized'')
or a red down-tick \ltiChk{} (``inherited'').
The types \ltiSyn{\ltiT{}} and \ltiChk{\ltiT{}} contain only synthesized and inherited constructors, respectively.
Both are structurally equivalent to \ltiSynChk{\ltiT{}}, differing only in color.
If the same constructor appears more than once in a rule without annotation,
they are assumed to have the same color, and similarly for two occurrences of \ltiSynChk{\ltiT{}}.
}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer[]
    {}
    {\lticsubtype{\ltiT{}}{\ltiT{}}}

    \infer[]
    {
    \lticfsubtype{\ltiFuel{}}{\ltiT{1}}{\ltiT{2}}{\ltiFuelp{}}
    \\
    \lticfsubtype{\ltiFuelp{}}{\ltiT{2}}{\ltiT{3}}{\ltiFuelpp{}}
    }
    {\lticfsubtype{\ltiFuel{}}{\ltiT{1}}{\ltiT{3}}{\ltiFuelpp{}}
    }

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltitvar{}}}{\ltiChk{\ltitvar{}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}{\ltiChk{\ltiBot}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiTop}}{\ltiChk{\ltiTop}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}{\ltiChk{\ltiTop}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}},
                                  \hastype{\ltivar{n+1}}{\ltiChk{\ltiTop}},..., \hastype{\ltivar{m}}{\ltiChk{\ltiTop}}
                                  }}}
                 {\ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}}, ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}}
                 }

    \infer[]
    {}
    {
    \lticsubtype{\ltiSyn{\ltiArrowMono{\ltiSynChk{\ltiT{}}}{\ltiSynChk{\ltiS{}}}}}
                {\ltiChk{\ltiArrowMono{\ltiSynChk{\ltiT{}}}{\ltiSynChk{\ltiS{}}}}}
    }

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}{\ltiChk{\ltitvar{}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}
                 {\ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSyn{\ltiBot}}, ..., \hastype{\ltivar{n}}{\ltiSyn{\ltiBot}}}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}
                 {\ltiChk{\ltiArrowMono{\ltiSyn{\ltiTop}}{\ltiSyn{\ltiBot}}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltitvar{}}}
                 {\ltiChk{\ltiTop{}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiChk{\ltiTop}}, ..., \hastype{\ltivar{n}}{\ltiChk{\ltiTop}}}}}
                 {\ltiChk{\ltiTop{}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiArrowMono{\ltiChk{\ltiBot}}{\ltiChk{\ltiTop}}}}
                 {\ltiChk{\ltiTop}}
                 }

    \infer[]
    {
    \lticfsubtype{\ltiFuel{1}}{\ltiT{1}}{\ltiTp{1}}{\ltiFuel{2}}
    \\
    ...
    \\
    \lticfsubtype{\ltiFuel{n}}{\ltiT{n}}{\ltiTp{n}}{\ltiFuel{n+1}}
    }
    {
    \lticfsubtype{\ltiFuel{1}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},...,\hastype{\ltivar{n}}{\ltiT{n}}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiTp{1}},...,\hastype{\ltivar{n}}{\ltiTp{n}}}}
                 {\ltiFuel{n+1}}
    }

    \infer[SC-Arrow]
    {
    \lticfsubtypeinv{\ltiFuel{}}{\ltiT{1}}{\ltiTp{1}}{\ltiFuelp{}}
    \\
    \lticfsubtype{\ltiFuelp{}}{\ltiT{2}}{\ltiTp{2}}{\ltiFuelpp{}}
    }
    {
    \lticfsubtype{\ltiFuel{}}
                {\ltiArrow{\ltiTp{1}}{\ova{\ltitvar{}}}{\ltiT{2}}}
                {\ltiArrow{\ltiT{1}}{\ova{\ltitvar{}}}{\ltiTp{2}}}
                {\ltiFuelpp{}}
    }

%    \infer[SC-ArrowMonoR]
%    {
%                  \ltiagreeexcepttvars{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiChk{\ltiS{}}}
%                  \\
%                  \lticsubtype{\ltiSp{}}
%                              {\ltireplace{\ova{\ltiR{}}}
%                                          {\ova{\ltitvar{}}}
%                                          {\ltiChk{\ltiS{}}}}
%                  \\
%                  \lticsubtype{\ltireplace{\ova{\ltiR{}}}
%                                          {\ova{\ltitvar{}}}
%                                          {\ltiSyn{\ltiT{}}}}
%                              {\ltiTp{}}
%                  \\\\
%      \forall \ova{\ltiRp{}}, \ltiTpp{}.
%      (
%                  {\lticsubtype{\ltiSp{}}
%                              {\ltireplace{\ova{\ltiRp{}}}
%                                          {\ova{\ltitvar{}}}
%                                          {\ltiChk{\ltiS{}}}}}
%                                          \ \ 
%                                          \wedge
%                                          \ \ 
%                  {\lticsubtype{\ltireplace{\ova{\ltiRp{}}}
%                                          {\ova{\ltitvar{}}}
%                                          {\ltiSyn{\ltiT{}}}}
%                              {\ltiTpp{}}}
%                                          \ \ 
%                                          \wedge
%                                          \ \ 
%                              {\lticoincideinherited{\ltiTpp{}}{\ltiTp{}}}
%                                          \ \ 
%                              \Rightarrow
%                                          \ \ 
%                  {\lticsubtype{\ltireplace{\ova{\ltiR{}}}
%                                          {\ova{\ltitvar{}}}
%                                          {\ltiSyn{\ltiT{}}}}
%                               {\ltireplace{\ova{\ltiRp{}}}
%                                           {\ova{\ltitvar{}}}
%                                           {\ltiChk{\ltiT{}}}}}
%      )
%    }
%    {
%    \lticsubtype{\ltiChk{\ltiArrow{\ltiSyn{\ltiS{}}}{\ova{\ltitvar{}}}{\ltiSyn{\ltiT{}}}}}
%                {\ltiArrowMono{\ltiSp{}}{\ltiTp{}}}
%    }

    \\

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}
                 {\ltiChk{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiBot}}
                 {\ltiChk{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}}

    \infer[]
    {}
    {\lticsubtype{\ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}
                 {\ltiChk{\ltiTop}}
                 }

    \infer[SC-Closure]
    {
    \lticfjudgement{\ltiFuel{}}
                   {\ltiEnv{},\ova{\ltitvar{}}, \hastype{\ltivar{}}{\ltiSyn{\ltiT{}}}}
                   {\ltiE{}}
                   {\ltiSynChk{\ltiS{}}}
                   {\ltiFuelp{}}
    }
    {
    \lticfsubtype{\ltiFuel{}}
                 {\ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}
                 {\ltiChk{\ltiArrow{\ltiSyn{\ltiT{}}}{\ova{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}}
                 {\ltiFuelp{}}
    }

  \end{mathpar}
  \caption{Subtyping for colored types
  \lticfsubtype{\ltiFuel{}}{\ltiT{}}{\ltiS{}}{\ltiFuelp{}},
  with
  \lticfsubtype{\ltiFuel{}}{\ltiT{}}{\ltiS{}}{\ltiFuel{}}
  abbreviated 
  to \lticsubtype{\ltiT{}}{\ltiS{}}.
  The upside-down \lticsubtypesymbol relation 
  is defined like \lticsubtypesymbol, except with inverted colors.
  % TODO can't have this command in a caption (rotatebox incompatibility I think)
  %The relation
  %\ltiinvertedleq
  %is defined similarly, except with inverted colors.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer[(C-Var)]
    {
    \ltiEnvLookup{\ltiEnv{}}{\ltivar{}} = {\ltiSyn{\ltiT{}}}
    }
    {
    \lticfjudgement{\ltiFuel{}}{\ltiEnv{}}{\ltivar{}}{\ltiSyn{\ltiT{}}}{\ltiFuel{}}
    }

    \infer[(C-Sub)]
    {\lticfjudgement{\ltiFuel{1}}
                    {\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiT{}}
                    {\ltiFuel{2}}
                   \\
                   \lticfsubtype{\ltiFuel{2}}{\ltiT{}}{\ltiTp{}}{\ltiFuel{3}}
    }
    {\lticfjudgement{\ltiFuel{1}}
                    {\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiTp{}}
                    {\ltiFuel{3}}
                   }

    \infer[(C-Abs)]
    {\lticfjudgement{\ltiFuel{}}
                    {\ltiEnv{}, \ltiSyn{\ova{\ltitvar{}}}, \hastype{\ltivar{}}{\ltiSyn{\ltiT{}}}}
                    {\ltiE{}}
                    {\ltiS{}}
                    {\ltiFuelp{}}
                   \\
                   \ova{\ltitvar{}} \not\in \ltitv{\ltiE{}}
    }
    {\lticfjudgement{\ltiFuel{}}
                   {\ltiEnv{}}
                   {\ltiufun{\ltivar{}}{\ltiE{}}}
                   {\ltiChk{\ltiArrow{\ltiT{}}{\ova{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}}
                   {\ltiFuelp{}}
                   }

    \infer [(C-UAbs)]
    {\lticfjudgement{\ltiFuel{}}
                    {\ltiEnv{}, \hastype{\ltivar{}}{\ltiSyn{\ltiBot{}}}}
                    {\ltiE{}}
                    {\ltiS{}}
                    {\ltiFuelp{}}
                    }
    {\lticfjudgement{\ltiFuel{}}
                    {\ltiEnv{}}
                    {\ltiufun{\ltivar{}}{\ltiE{}}}
                    {\ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}}
                    {\ltiFuelp{}}
                   }

    \infer [($\text{C-Abs}_{tp}$)]
    {
    \lticfjudgement{\ltiFuel{}}
                   {\ltiEnv{}, \ltiSyn{\ova{\ltitvar{}}}, \hastype{\ltivar{}}{\ltiSyn{\ltiT{}}}}
                   {\ltiE{}}
                   {\ltiS{}}
                   {\ltiFuelp{}}
    }
    {
    \lticfjudgement{\ltiFuel{}}
                  {\ltiEnv{}}
                  {\ltifun{\ova{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                  {\ltiSyn{\ltiArrow{\ltiT{}}{\ova{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}}
                  {\ltiFuelp{}}
    }

    \infer [(C-Sel)]
    {
    \lticfjudgement{\ltiFuel{}}
                   {\ltiEnv{}}
                   {\ltiE{}}
                   {\ltiChk{\ltiRec{\hastype{\ltivar{}}{\ltiSynChk{\ltiT{}}}}}}
                   {\ltiFuelp{}}
    }
    {
    \lticfjudgement{\ltiFuel{}}
                   {\ltiEnv{}}
                   {\ltisel{\ltiE{}}{\ltivar{}}}
                   {\ltiT{}}
                   {\ltiFuelp{}}
    }

    \infer [(C-Rec)]
    {
    \lticfjudgement{\ltiFuel{i}}
                  {\ltiEnv{}}
                  {\ltiE{i}}
                  {\ltiSynChk{\ltiT{i}}}
                  {\ltiFuel{i+1}}
    }
    {
    \lticfjudgement{\ltiFuel{1}}
                  {\ltiEnv{}}
                  {\ltiRec{\ova{\ltivar{} = \ltiE{}}^n}}
                  {\ltiSyn{\ltiRec{\ova{\hastype{\ltivar{}}{\ltiSynChk{\ltiT{}}}}^n}}}
                  {\ltiFuel{n+1}}
    }

    \infer [($\text{C-App}_{tp}$)]
    {
    \lticfjudgement{\ltiFuel{1}}
                  {\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiChk{\ltiArrow{\ltiSyn{\ltiS{}}}{\ova{\ltitvar{}}}{\ltiSyn{\ltiT{}}}}}
                  {\ltiFuel{2}}
                  \\
    \lticfjudgement{\ltiFuel{2}}
                  {\ltiEnv{}}
                  {\ltiE{}}
                  {\ltireplace{\ova{\ltiR{}}}
                              {\ova{\ltitvar{}}}
                              {\ltiChk{\ltiS{}}}}
                  {\ltiFuel{3}}
    }
    {
    \lticfjudgement{\ltiFuel{1}}
                  {\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}}}
                  {\ltireplace{\ova{\ltiR{}}}
                              {\ova{\ltitvar{}}}
                              {\ltiChk{\ltiT{}}}}
                  {\ltiFuel{3}}
    }

    \infer [(C-App)]
    {
    \lticjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiChk{\ltiArrow{\ltiSyn{\ltiS{}}}{\ova{\ltitvar{}}}{\ltiSyn{\ltiT{}}}}}
                  \\
    \lticjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSp{}}
                  \\
                  \ltiagreeexcepttvars{\ltiSp{}}{\ova{\ltitvar{}}}{\ltiChk{\ltiS{}}}
                  \\
                  \lticsubtype{\ltiSp{}}
                              {\ltireplace{\ova{\ltiR{}}}
                                          {\ova{\ltitvar{}}}
                                          {\ltiChk{\ltiS{}}}}
                  \\
                  \lticsubtype{\ltireplace{\ova{\ltiR{}}}
                                          {\ova{\ltitvar{}}}
                                          {\ltiSyn{\ltiT{}}}}
                              {\ltiTp{}}
                  \\\\
      \forall \ova{\ltiRp{}}, \ltiTpp{}.
      (
                  {\lticsubtype{\ltiSp{}}
                              {\ltireplace{\ova{\ltiRp{}}}
                                          {\ova{\ltitvar{}}}
                                          {\ltiChk{\ltiS{}}}}}
                                          \ \ 
                                          \wedge
                                          \ \ 
                  {\lticsubtype{\ltireplace{\ova{\ltiRp{}}}
                                          {\ova{\ltitvar{}}}
                                          {\ltiSyn{\ltiT{}}}}
                              {\ltiTpp{}}}
                                          \ \ 
                                          \wedge
                                          \ \ 
                              {\lticoincideinherited{\ltiTpp{}}{\ltiTp{}}}
                                          \ \ 
                              \Rightarrow
                                          \ \ 
                  {\lticsubtype{\ltireplace{\ova{\ltiR{}}}
                                          {\ova{\ltitvar{}}}
                                          {\ltiSyn{\ltiT{}}}}
                               {\ltireplace{\ova{\ltiRp{}}}
                                           {\ova{\ltitvar{}}}
                                           {\ltiChk{\ltiT{}}}}}
      )
    }
    {
    \lticjudgement{\ltiEnv{}}
                  {\ltiapp{\ltiF{}}{\ltiE{}}}
                  {\ltiTp{}}
                 }

%    \infer [(C-App)]
%    {
%    \lticfjudgement{\ltiFuel{1}}
%                  {\ltiEnv{}}
%                  {\ltiF{}}
%                  {\ltiR{}}
%                  {\ltiFuel{2}}
%                  \\\\
%    \lticfjudgement{\ltiFuel{2}}
%                  {\ltiEnv{}}
%                  {\ltiE{}}
%                  {\ltiSynChk{\ltiS{}}}
%                  {\ltiFuel{3}}
%                  \\\\
%    \lticfsubtype{\ltiFuel{3}}{\ltiR{}}
%                 {\ltiChk{\ltiArrowMono{\ltiSynChk{\ltiS{}}}{\ltiSynChk{\ltiT{}}}}}
%                 {\ltiFuel{4}}
%    }
%    {
%    \lticfjudgement{\ltiFuel{1}}
%                  {\ltiEnv{}}
%                  {\ltiapp{\ltiF{}}{\ltiE{}}}
%                  {\ltiSynChk{\ltiT{}}}
%                  {\ltiFuel{4}}
%    }

    \infer[C-AppClosure]
    {
    \lticfjudgement{\ltiFuel{1}}
                   {\ltiEnv{}}
                   {\ltiF{}}
                   {\ltiChk{\ltiClosure{\ltiEnvp{}}{\ltiufun{\ltivar{}}{\ltiEp{}}}}}
                   {\ltiFuel{2}}
                   \\
    \lticfjudgement{\ltiFuel{2}}
                  {\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSynChk{\ltiS{}}}
                  {\ltiFuel{3}}
                  \\
    \ltiFuel{3} > 0
    \\
    \lticfjudgement{\ltiFuel{3} - 1}
                   {\ltiEnvp{},\hastype{\ltivar{}}{\ltiSyn{\ltiS{}}}}
                   {\ltiEp{}}
                   {\ltiSynChk{\ltiT{}}}
                   {\ltiFuel{4}}
    }
    {
    \lticfjudgement{\ltiFuel{1}}
                  {\ltiEnv{}}
                  {\ltiapp{\ltiF{}}{\ltiE{}}}
                  {\ltiSynChk{\ltiT{}}}
                  {\ltiFuel{4}}
    }

  \end{mathpar}
  \caption{Polymorphic Colored Type System rules
  \lticfjudgement{\ltiFuel{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}
                 {\ltiFuel{}},
    abbreviated \lticjudgement{\ltiEnv{}}
                              {\ltiE{}}
                              {\ltiT{}}
    when fuel is propagated left-to-right through premises,
    as in \textsc{C-App}.
  }
\end{figure}

% FIXME these 2 paragraphs used to apply to the internal language, now just the colored type system
%The last three rules
%of \figref{symbolic:figure:internal-language-type-system}
%shows our extensions to the type system.
%\textsc{I-UAbs} assigns unannotated functions a symbolic closure type.
%The rules \textsc{I-UApp} and \textsc{S-Closure} together handle
%checking symbolic closures.
%In \textsc{I-UApp}, the argument type \ltiS{} (which itself might contain
%symbolic closures via \textsc{I-UAbs}) is
%propagated to
%\textsc{S-Closure}
%where it is used as the parameter type to check the body of the symbolic
%closure.
%Moving the checking of a symbolic closure to 
%\textsc{S-Closure},
%(instead of \textsc{I-UApp})
%allows symbolic closures to participate with other rules.
%In particular, checking \clj{(f (fn [x] (inc x)))},
%where \clj{f : [[Int -> Int] -> Int]},
%uses the \textsc{I-App} application rule,
%but manages to propagate \clj{x : Int}
%via \textsc{S-Closure}.
%
%Note that \textsc{S-Closure} uses the symbolic closure's definition type environment
%for type checking. The definition environment is (somewhat analogously to runtime closures)
%``captured'' by \textsc{I-UAbs},
%and carefully propagated in select rules.
%For example, in \textsc{S-UApp}
%the definition environment \ltiEnvp{} is passed to subtyping,
%rather than the application environment \ltiEnv{}.
%This arrangement correctly type checks \figref{symbolic:example:closure-red}.


\subsection{Type Inference Algorithm}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiC{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiT{}},...,\ltiCEntry{\ltiT{}}{\ltitvar{n}}{\ltiT{}}}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{Type Inference Syntax}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(W-Var)]
    {}
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}{\ltivar{}}
                 {\ltimatchsuper{\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}{\ltiP{}}}
    }

    
    \infer [(W-Abs)]
    {
    \ltijudgement{\ltiP{}}
                 {\ltiEnv{},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrowMono{\ltiT{}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrowMono{\ltiT{}}{\ltiS{}}}
    }

    \infer [($\text{W-App}_{\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot}
                                {\ltiP{}}}
    }

    \infer [(W-Sel)]
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{}}{\ltiP{}}}}{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiRec{\hastype{\ltivar{}}{\ltiT{}}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltisel{\ltiE{}}{\ltivar{}}}
                 {\ltiT{}}
    }

    \infer [($\text{W-Rec}_{\ltiWild{}}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiE{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiE{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [($\text{W-Rec}_{\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [(W-Rec)]
    {
    \ltijudgement{\ltiP{1}}
                 {\ltiEnv{}}
                 {\ltiE{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiP{m}}
                 {\ltiEnv{}}
                 {\ltiE{m}}
                 {\ltiT{m}}
    \\\\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{m+1}}
                 {\ltiT{m+1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{1}}{\ltiP{1}}, ..., \hastype{\ltivar{m}}{\ltiP{m}}}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{m}}{\ltiT{m}}}}
    }
  \end{mathpar}
  \caption{Type Inference algorithm rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\section{Metatheory}

\begin{verbatim}
Soundness (based on CLTI)
=========
If 
 Env |-c E : T
then there exists a term F such that
 1. E is a partial erasure of F,
 2. F is a partial beta-reduction of E,
 3. F does not contain symbolic closure types
and there exists an environment Env' such that.
  1. Env' is Env except all symbolic closure types are replaced by [Bot -> Top]
with
 Env' |-  F : S
such that
 S <: T'
where T' is T except all symbolic closure types are replaced by [Bot -> Top].
\end{verbatim}

\section{Comparison to Hindley-Milner type inference}

% TODO let-polymorphism comparison
Schwartzbach~\cite{schwartzbach1995polymorphic}
gives an accessible introduction to the tradeoffs of
global type inference
in the style of Milner~\cite{milner1978theory}.
%The use of a polymorphic let-construct

% TODO I thought Mairson was the source of these large benchmarks when I wrote this,
% but it's actually Kanellakis and Mitchell, POPL '89.
% I think a lot of the following can be removed and simplified
% to just talk about Examples 3.1, 3.4, and 3.4 from POPL '89.
% The test suite in lti-model has notes about all their behaviors with
% symbolic closures.

Related performance issues have infamously arisen in ML, summarized
by Mairson~\cite{Mairson:1989}, whose work confirmed
that the problem of ML type-checking is \textsc{DExpTime}-complete.
Several ML programs that exhibit exponential
growth in the size of principal type schemes of certain (pathological)
programs are provided as part of Mairson's initial investigation.
We use their benchmark from Appendix A~\cite{Mairson:1989} to stress-test our implementation of symbolic closures.

The benchmark uses Church pairs (an encoding of pairs using only lambdas)
to build an expression that has an enourmous principal function type,
both exponentially large in its size and number of type variables, relative
to the program size.
First, to demonstrate how the benchmark works, 
\figref{symbolic:figure:pair-benchmark}
presents a slightly smaller program size
($n=3$, where $n$ is the number of times size of the type duplicates).

%\begin{lstlisting}[language=ml]
%let fun pair x y = fn z => z x y in
%  let fun x1 y = pair y y in
%    let fun x2 y = x1(x1(y)) in (*@\label{symbolic:pair-x2:x2}@*)
%      x2(fn z => z)(*@\label{symbolic:pair-x2:x0}@*)
%    end
%  end
%end;
%val it = fn
%  : ((((?.X1 -> ?.X1) -> (?.X1 -> ?.X1) -> ?.X2) -> ?.X2)
%     -> (((?.X1 -> ?.X1) -> (?.X1 -> ?.X1) -> ?.X2) -> ?.X2) -> ?.X3)
%    -> ?.X3
%\end{lstlisting}

\begin{figure}
\begin{lstlisting}[language=ml, numbers=left]
let fun pair x y = fn z => z x y in
let fun x1 y = pair y y in(*@\label{symbolic:pair-x3:x1}@*)
  let fun x2 y = x1(x1(y)) in(*@\label{symbolic:pair-x3:x2}@*)
    let fun x3 y = x2(x2(y)) in(*@\label{symbolic:pair-x3:x3}@*)
      x3(fn z => z)(*@\label{symbolic:pair-x3:x0}@*)
    end
  end
end
end;
val it = fn : ((T -> T -> ?.X5) -> ?.X5)(*@\label{symbolic:pair-x3:it}@*)
    where T = ((U -> U -> ?.X4) -> ?.X4)
    where U = ((V -> V -> ?.X3) -> ?.X3)
    where V = ((W -> W -> ?.X2) -> ?.X2)(*@\label{symbolic:pair-x3:X2}@*)
    where W = (?.X1 -> ?.X1)(*@\label{symbolic:pair-x3:W}@*)
\end{lstlisting}
\caption{Benchmark demonstrating exponential growth of principal type schemes in ML.
  Types are manually abbreviated for readability, ungeneralized type variables are
  instantiated to dummy types (\sml{X1},\sml{X2},...).}
\label{symbolic:figure:pair-benchmark}
\end{figure}

The abbreviated output type \sml{it} (line \ref{symbolic:pair-x3:it}) is the result of the call to \sml{x3}
on line \ref{symbolic:pair-x3:x0}.
For each function $\text{\sml{x}}_n$, the range of its principal type is twice as large as
the range of the principle type of $\text{\sml{x}}_{n-1}$.
This pattern starts with \sml{x1} (line \ref{symbolic:pair-x3:x1}),
whose type is \sml{'a -> (('a -> 'a -> 'b) -> 'b)}---note that \sml{'a}
is duplicated, which provides a foundation for the exponential growth.
Then, \sml{x2} (line \ref{symbolic:pair-x3:x2})
has a principal type that is twice as large as \sml{x1}'s because it
iteratively calls \sml{x1} twice on its input---thus \sml{x2} duplicates its input \emph{four} times.
Extending this reasoning, \sml{x3} (line \ref{symbolic:pair-x3:x3})
has a principal type twice as large as \sml{x2}'s,
duplicating its input \emph{sixteen} times.
This is the number number of times \sml{W} (line \ref{symbolic:pair-x3:W},
the type of the argument \sml{fn z => z} on line \ref{symbolic:pair-x3:x0})
occurs in the output type (line \ref{symbolic:pair-x3:it}).

As mentioned, the number of type variables introduced is also exponential
in the size of the program. For $n=3$, $2^{n-1}=4$ variables are introduced---they are the types from
\sml{?.X2} onwards on lines \ref{symbolic:pair-x3:it}-\ref{symbolic:pair-x3:X2}.
For $n=4$, the output type will have \sml{W} occurring 32 times,
and introduce 8 type variables.
Mairson's original experiment with $n=5$ output reams of principal
types before crashing (circa 1989).
Repeating this experiment on a 2011 Macbook Pro with a 30-year-newer version of Standard ML
completed in 45 seconds (with around 20,000 lines of principal types).

% - parametric polymorphism
%  - (map f (map g l))
%    - "We are concerned with a conceptual framework in which these map functions may all be regarded semantically as the same object"
%      - Milner 1978;
%    - ie. in contrast to adhoc polymorphism
%      - where instead:
%         - (let [map1 ...
%                 map2 ...]
%             (map2 f (map1 g l)))
%    - Milner-style type inference (apparently?) applies to either case
%      - (compatibility with adhoc polymorphism seems tentative in 1978 paper)
%  - [?] type of a local function is the intersection of all the types it was checked at
%    - ordered intersection?
% - type schemes
%   - we don't attempt to infer type schemes
%     - (let [f (fn [y] y)] (f 1))
%     - in ML:
%       - infer f as (All [a] [a -> a]), via unification based constraint solving
%       - 

\section{Experiments}

% - Solution
%   - "obvious" function annotations
%     - can be derived from usage context
%   - introduce "symbolic" closure types
%     - a function's type is its code + typed local scope
%   - don't need to check a function that isn't called
% - Constraints
%   - wildcard "?" type
%     - needed to provide argument types while inferring body
%     - from Colored LTI
%   - Infinite loops
%     - subtyping
%     - type generalization
%     - term reduction limits
%   - user-level story
%     - symbolic closures enabled by flag
%     - users cannot write a symbolic closure
%     - that way, global annotations cannot contain a symbolic closure
%       - helps with polymorphism story
%         - constraint solving
%           - hypothesis/goal: only one side of contraint solving can have a symbolic closure
%             - one side is from global annotation, other side from local inference
%     - compatible with occurrence typing
%   - reporting errors
%     - suggesting types
%     - avoid showing inlining to users
%   - checking fn with arguments at type Bot is equivalent (?) to not checking at all
%     - what about strange disjoint ordered intersection types like `into`
%     - do they break? do they need initial Bot arities?
%   - 0-n checks to same function
%     - avoid double expansion
%       - many copies of symbolic closures are made, could be expanded at different times
%         - how to synchronize?
%     - skipping unreachable functions
%       - potential for latent bugs, if type checker turned off in future and fn is made reachable
%     - performance
%   - consistent evaluation results
%     - how to ensure correct inlining?
%     - relationship between inlined and evaluated code?
%       - do we want to "undo" the inlining when finally evaluating?
%   - when to use a closure type?
%     - partial annotations
%   - polymorphism
%     - postpone discussion to next chapter
%   - applying symbolic analysis to infer loop/recur annotations
%     - similar issues
%     - different type generalization story?
%   - comparison to let-polymorphism
%     - expressiveness
%     - performance
%   - help check macros?
%     - not directly applicable, since too much context would be lost
%       - would help check *more* of an expansion, but error messages
%         are still unrelated to original code
%   - is this a sound strategy?
%     - faithfully simulates beta reduction
%     - termination story?
%   - case studies
%     - criteria:
%       - good errors?
%       - predictable behavior?
%       - performance?
%     - simple eta expansions
%       - (+ 1 2)
%       - ((fn [x y] (+ x y)) 1 2)
%     - let-bound functions
%       - (+ 1 2)
%       - (let [plus (fn [x y] (+ x y))]
%           (plus 1 2))
%     - y-combinator
%       - stress test
%     - let-polymorphism worst case (exponential) comparison
%       - stress test
%     - completely inlined transducers
%       - case study: inlining map + comp
%         - why: non recursive polymorphic functions
%           - common idiom
%         - how to report errors?
%   - polymorphic function-intersection types
%     - how to handle, do we need backtracking?
%     - do we need to recheck arguments? 

\chapter{Type Argument Reconstruction with Delayed Function Checking}
\label{chapter:symbolic:directed-lti}

\section{Colored local type inference}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltifun{\ova{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}} \alt
                         \ltiappinst{\ltiF{}}{\ova{\ltiT{}}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& ... \alt
                         \ltiArrow{\ltiT{}}{\ova{\ltitvar{}}}{\ltiS{}} \alt
                      &\mbox{Types} \\
\end{array}
$$
\caption{Internal Language syntax extensions for polymorphic functions}
\label{symbolic:figure:internal-language}
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
\end{array}
$$
\caption{Syntax Extensions for type argument inference.}
\end{figure}

\begin{figure}
  \begin{mathpar}

  \end{mathpar}
  \caption{Polymorphic Colored Type System rules
  $\lticjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [($\text{W-Abs}_{tp,?}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-Abs}_{tp}$)]
    {
    \ltijudgement{\ltiPp{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                                {\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}}
    }
    
    \infer [($\text{W-Abs}_{tp,\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiTop}
    }
    
    \infer [(W-AbsPoly)]
    {
    \ltijudgement{\ltiP{}}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-App}_{tp}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-App}_{tp,\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot}
                                {\ltiP{}}}
    }

  \end{mathpar}
  \caption{Extensions to Type Inference algorithm for polymorphic functions.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(W-App)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }
  \end{mathpar}
  \caption{
  Extension to type inference algorithm for type argument reconstruction.
  }

\end{figure}

% - Solution
%   - extend colored LTI with directed inference
%   - introduce constrained types
%   - derive data flow from (variances of) polymorphic variable occurrences 
%   - simple example
%     - (identity 1)
%     - demonstrate how this is checked with colored LTI
%     - compare to directed LTI:
%       - 2/----v
%         [x -> x]  Int
%          ^--------/1
%
%         1. Int flows to contravariant position
%         2. contravariant position flows to covariant position (because it's on the other side of ->)
%       - no loop, because variables not under different numbers of function types
%         - (we don't know the precise rule yet)
%   - complex example
% - Constraints
%   - advantages over colored LTI
%     - aids symbolic analysis
%       - because we derive potential dataflows, we don't need to over-approximate,
%         and thus trigger unneeded symbolic analysis
%         - which might then fail because of not enough contextual information
%   - disadvantages over colored LTI
%     - significant deviation from LTI
%       - constrained types
%       - aggressive local inference based on data flows
%     - not obvious how to prove soundness
%   - infinite loops
%     - how to manage cycles in inferred data flow 
%   - constraint solving
%     - constrained types
%       - literature (see symb.tex)
%   - flow diagrams
%     - see symb.tex
%   - relationship to colored LTI model
%     - see symb.tex
%   - related work
%     - ML_sub
%     - see: symb.tex
% - investigate implications 
%   - Remy ICFP '05
%     - (seems to) propagate information simultaneously in both directions like CLTI
%     - intro prose does a nice job explaining ML moving towards System F & challenges
%   - Joe B Wells 1994
%     - explains Church vs Curry style System F formulations
%     - some mentions of decidable fragments of System F
%   - Boxy types, ICFP '06
%     - explains higher-rank types
%       - types with forall quantifiers nested inside function types
%     - explains impredicativity
%       - being allowed to instantiate a type variable with a polytype (polymorphic type)
%     - explains "local type inference"
%       - a partial inference technique for a language with bounded, impredicative quantification,
%         and higher-rank types.
%     - explains "CLTI"
%       - reformulated bidirectional checking for F_sub so that the _type_ and not the _judgment form_
%         describes the direction in which type information flows
%     - CLTI's colors inspired their "boxy" types
%       - they outline differences in related work

\chapter{Custom Typing rules}
\label{chapter:symbolic:custom-rules}

% - Solution
%   - allow users to provide custom typing rules
%   - 
% - Constraints
%   - wildcard type from colored LTI useful
%   - custom error messages
%     - propagation via expected types
%       - outer-most wins
%   - using clojure.spec to conform/unform
%     - to rip apart and put syntax back together
%     - more robust than manual parsing
%   - differences with Turnstile
%     - in Turnstile, the macro *is* the rule
%       - here, we separate the two
%       - we preserve the macro call until evaluation
%       - use the typing rule to expand "under" the macro as many times as we want
%         - can do this 0-n times, thus compatible with directed LTI & symbolic analysis
