\chapter{Formalism}

We present \lambdatrack{}, an untyped $\lambda$-calculus
that describes the essense of our approach to automatic annotations.
Our model is split into two phases: the collection phase 
\collectOp{}
that runs an instrumented program and collects observations, and
an inference phase 
\inferanns{}
that derives type annotations from these observations
that can be used to automatically annotate the program.

Before getting into details, we define the top-level driver function \annotateOp{} that connects
both pieces.
It says, given a program \e{}
and top-level variables $\ova{\x{}}$ to infer annotations for,
return an annotation environment \atenv{} with possible entries for
$\ova{\x{}}$ based on observations from evaluating
an instrumented \e{}.
%
%\begin{mathpar}
%\infer[]
%{ \collectnoalign{\e{}}{\ova{\x{}}}{\res{}}
%  \\
%  \inferannsnoalign{\res{}}{\atenv{}}
%}
%{ \annotatenoalign{\e{}}{\ova{\x{}}}{\atenv{}} }
%\end{mathpar}
\begin{mathpar}
  \begin{array}{lllll}
    \annotateOp{} : \e{}, {\ova{\x{}}} \rightarrow \atenv{}\\
    \annotateOp{} = \inferanns{} \circ \collectOp{}
  \end{array}
\end{mathpar}

To contextualize the presentation of these phases, we begin a running example:
inferring the type of a top-level function $f$, that takes a map and
returns its {\makekw{a}} entry, 
based on the following usage.
%
\begin{Verbatim}[commandchars=\\\{\}, codes={\catcode`$=3\catcode`^=7}]
define $f$ = \uabs{m}{\getexp{m}{\makekw{a}}}

\appexp{f}{\curlymap{\makekw{a} 42}}
=> 42
\end{Verbatim}
%
Plugging this example into our driver function
we get a candidate annotation for $f$:
$$
\annotatenoalign{\appexp{f}{\curlymap{\makekw{a}\ 42}}}{[f]}{\{\hastype{f}{[\{\makekw{a}\ \IntT{}\} \rightarrow \IntT{}]}\}}
$$

\section{Collection phase}

Now that we have a high-level picture of how these phases interact,
we describe the syntax and semantics of \lambdatrack{}, before
presenting the details of \collectOp{}.
%
\figref{infer:fig:syntax} presents the syntax of \lambdatrack{}.
Values \v{} consist of numbers \num{}, Clojure-style keywords {\kw{}},
closures {\closure{\uabs{\x{}}{\e{}}}{\openv{}}}, constants \const{},
and keyword keyed hash maps {\curlymapvaloverrightnoarrow{\kw{}}{\val{}}}.

Expressions \e{} consist of variables \x{}, values,
functions, hash-maps, and function applications.
The special form
\trackE{\e{}}{\inferpath{}}
observes {\e{}} as related to path {\inferpath{}}.
Paths \inferpath{} 
record the source of a runtime value with respect
to a sequence of path elements \pth{}, which always starts with
a variable \x{}, and are read left-to-right.
Other path elements are
a function domain \dompe{}, 
a function range \rngpe{},
and a map entry {\inferkeype{\ova{\kw{1}}}{\kw{2}}}
which represents the result of looking up key {\kw{2}}
in a map with keyset ${\ova{\kw{1}}}$.

Inference results \restwoarrow{\inferpath{}}{\t{}}
are pairs of paths {\inferpath{}} and types \t{}
that say the path \inferpath{} was observed to be 
type \t{}.
Types \t{} are numbers \IntT{}, function types \arrow{\t{}}{\t{}},
ad-hoc union types \Union{\t{}}{\t{}},
type aliases \alias{},
%top type \Top{},
and unknown type \UnknownT{} that represents
a temporary lack of knowledge during the inference process.
Heterogeneous keyword map types \HMappretty{\ova{\kw{}\ \t{}}}
for now represent a series of required keyword entries---we will extend
them to have optional entries in later phases.

\begin{figure*}
  $$
  \begin{altgrammar}
    \val{} &::=& \num{}
       \alt {\kw{}}
       \alt {\closure{\uabs{\x{}}{\e{}}}{\openv{}}}
       \alt {\curlymapvaloverrightnoarrow{\kw{}}{\val{}}}
       \alt {\const{}}
       &\mbox{Values} \\
   \e{} &::=& \x{}
       \alt \val
       \alt \trackE{\e{}}{\inferpath{}}
       \alt {\uabs{\x{}}{\e{}}}
       \alt {\curlymapvaloverrightnoarrow{\e{}}{\e{}}}
       \alt {\appexp{\e{}}{\ova{\e{}}}}
       &\mbox{Expressions} \\
    \openv{} &::=& \{\ova{x \mapsto \val{}}\}
       &\mbox{Runtime environments} \\
   \pth{}
      &::=& \x{}
       \alt \dompe{}
       \alt \rngpe{}
       \alt {\inferkeype{\HMapreq{}}{\kw{}}}
       &\mbox{Path Elements} \\
   \inferpath{} &::=& \ova{\pth{}}
       &\mbox{Paths} \\
       \res{}
      &::=& \restwoarrow{\inferpath{}}{\tau{}}
      &\mbox{Inference results} \\
    \t{}, \s{}
      &::=& \IntT{}
       \alt \arrow{\t{}}{\t{}}
       %\alt \HMappretty{\ova{\kw{}\ \t{}}}
       \alt \HMaptwo{\HMapreq{}}{\HMapopt{}}
       \alt \Unionsplice{\ova{\t{}}}
       \alt \alias{} % type alias
       \\
       &\alt& \kw{}
       \alt \Keyword{}
       \alt \Top{}
       \alt \IPersistentMap{\t{}}{\t{}}
       \alt \UnknownT{}
      &\mbox{Types} \\
    \tenv{} &::=& \{\ova{\hastype{\x{}}{\t{}}}\}
      &\mbox{Type environments} \\
    \HMapreq{}, \HMapopt{}
      &::=& \{ \ova{\kw{}\ {\t{}}} \}
      &\mbox{HMap entries} \\
    \aenv{} &::=& \{\ova{\alias{} \mapsto \tau}\}
      &\mbox{Type alias environments} \\
    \atenv{} &::=& (\aenv{}, \tenv{})
      &\mbox{Annotation environments} \\
  \end{altgrammar}
  $$
\caption{Syntax of Terms, Types, Inference results, and Environments for \lambdatrack{}}
\label{infer:fig:syntax}
\end{figure*}

The big-step operational semantics
{\opsemtrack{\openv{}}{\e{}}{\v{}}{\res{}}}
(\figref{infer:fig:semantics})
says under runtime environment \openv{}
expression \e{} evaluates to value \v{}
with inference results \res{}.
Most rules are standard, with extensions to correctly
propagate inference results \res{}.
B-Track is the only interesting rule, which instruments
its fully-evaluated argument with the \trackmetaOp{}
metafunction.

The metafunction \trackmeta{\v{}}{\inferpath{}}{\vp{}}{\res{}} (\figref{infer:fig:trackmeta})
says if value \v{} occurs at path {\inferpath{}}, then return a possibly-instrumented
\vp{} paired with inference results {\res{}} that can be immediately derived
from the knowledge that \v{} occurs at path {\inferpath{}}.
It has a case for every kind of value.
The first case records the number input as type {\IntT{}}.
The second case, for closures, returns a wrapped value
resembling higher-order function contracts~\cite{findler2002contracts},
but we track the domain and range rather than verify them.
The third case, for maps, recursively tracks each map value,
and returns a map with possibly wrapped values.
Immediately accessible inference results are combined
and returned.
The other cases are straightforward.

\begin{figure*}
\begin{mathpar}
%\infer [B-Var]
%{ track(\openv{}(x), [x]) = v\ ; res }
%{ \openv{} \vdash x \Downarrow v\ ; res}

% track is inserted manually
\infer [B-Var]
{}
{ \opsemtrack{\openv{}}{\xvar{}}{\inopenvnoeq{\openv{}}{\xvar{}}}{\emptyres{}}
}

\infer [B-Track]
{ \opsemtrack{\openv{}}{\e{}}{\v{}}{\res{}} \\
  \trackmeta{\v{}}{\inferpath{}}{\vp{}}{\resp{}}}
{ \opsemtrack{\openv{}}{\trackE{\e{}}{\inferpath{}}}{\vp{}}{\unionres{\res{}}{\resp{}}}
}

\infer [B-App]
{ \opsemtrack{\openv{}}{\e{1}}{[\lambda \x{}. \e{}, \openvp{}]}{\res{1}} \\\\
  \opsemtrack{\openv{}}{\e{2}}{\v{}}{\res2} \\\\
  \opsemtrack{\extendopenv{\openvp{}}{\x{}}{\v{}}}{\e{}}{\vp{}}{\res{3}} \\
}
{ \opsemtrack{\openv{}}{\appexp{\e{1}}{\e{2}}}{\vp{}}{\unionresthree{\res{1}}{\res{2}}{\res{3}}}
}

\infer [B-Clos]
{}
{ \opsemtrack{\openv{}}{\lambda \xvar{}. \e{}}{[\lambda \ova{\xvar{}} . \e{}, \openv{} ]}{\emptyres{}}}

\infer [B-Val]
{}
{ \opsemtrack{\openv{}}{\val{}}{\val{}}{\emptyres{}} }

%\infer [B-Get]
%{ \opsemtrack{\openv{}}{\e{1}}{\{ \ova{\kw{}\ \v{}} \}}{\res{1}} \\
%  \opsemtrack{\openv{}}{\e{2}}{\kw1}{\res{2}} \\
%}
%{ \opsemtrack{\openv{}}{\getexp{\e{1}}{\e{2}}}{\getmap{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\kw{1}}}{\unionres{\res{1}}{\res{2}}}
%}
%
%\infer [B-Assoc]
%{ 
%  \opsemtrack{\openv{}}{\e{1}}{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\res{1}} \\
%  \opsemtrack{\openv{}}{\e{2}}{\kw{1}}{\res{2}} \\
%  \opsemtrack{\openv{}}{\e{3}}{\v{}}{\res{3}} \\
%}
%{ \opsemtrack{\openv{}}
%             {\assocexp{\e{1}}{\e{2}}{\e{3}}}
%             {\extendmap{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\kw{1}}{\v{}}}
%             {\unionresthree{\res{1}}{\res{2}}{\res{3}}}
%}

\infer [B-Delta]
{ \opsemtrack{\openv{}}{\e{}}{\const{}}{\res{}}
  \\
  \ova{\opsemtrack {\openv{}}{\ep{}}{\v{}}{\resp{}}}
  \\
  \constantopsem{\const{}}{\ova{\v{}}} = \vp{}
}
{ \opsemtrack {\openv{}}
              {\appexp {\e{}} {\ova{\ep{}}}}
              {\vp{}}
              {\unionres{\bigunionres{\resp{}}}{\res{}}}
       }

\end{mathpar}
\caption{Operational Semantics for \lambdatrack{}}
\label{infer:fig:semantics}
\end{figure*}

\begin{figure*}
\begin{mathpar}

  \begin{array}{lllll}
    %\trackmeta{\v{}}{\inferpath{}}{\v{}}{\res{}}\\\\

    \trackmetaalign{\num{}}{\inferpath{}}{\num{}}{\singletonres{\inferpath{}}{\IntT{}}}
    \\
    \trackmetaalign{\kw{}}{\inferpath{}}{\kw{}}
                   {\singletonres{\inferpath{}}
                                 {\Keyword{}}}
    \\
    \trackmetaalign{\const{}}{\inferpath{}}{\const{}}{\emptyres{}}
    \\
    \trackmetaalign{\closure{\uabs{\x{}}{\e{}}}{\openv{}}}
                   {\inferpath{}}
                   {\closure{\uabs{\y{}}
                                  {\trackE{\appexp{\uabs{\x{}}{\e{}}}
                                                  {\trackE{\yvar{}}{\appendone{\inferpath{}}{\dompe{}}})}}
                                          {\appendone{\inferpath{}}{\rngpe{}}}}}
                            {\openv{}}}
                   {\emptyres{}}
                   % let's treat functions as opaque wrt arity as they are in clojure
                   %{\singletonres{\inferpath{}}
                   %              {\arrow{\UnknownT{}}{\UnknownT{}}}}
         \\
    &&
    \text{where}\ \y{} \text{ is fresh}
    \\
    \trackmetaalign{\{\}}
                   {\inferpath{}}
                   {\{\}}
                   {\singletonres{\inferpath{}}
                                 {\HMappretty{}}}
    \\
    \trackmetaalign{\{\ova{\kw{1}\ {\kw{2}}}\ 
                      \ova{\kw{}\ {\v{}}}
                    \}}
                   {\inferpath{}}
                   {\{\ova{\kw{1}\ {\kw{2}}}\ 
                      \ova{\kw{}\ {\vp{}}}
                    \}}
                   {\bigunionres{\res{}}}
    \\
    &&
    \text{where}\ \ova{\trackmeta{\v{}}
                                            {\appendone{\inferpath{}}
                                                       {\inferkeype{\{\ova{\kw{1}\ {\kw{2}}}\ 
                                                                      \ova{\kw{}\ {\UnknownT{}}}
                                                                    \}}
                                                                   {\kw{}}}}
                                            {\vp{}}
                                            {\res{}}}
    \\
  \end{array}

\end{mathpar}
\caption{Definition of \trackmeta{\v{}}{\inferpath{}}{\v{}}{\res{}}}
\label{infer:fig:trackmeta}
\end{figure*}

Now we have sufficient pieces to describe the initial collection phase of our model.
Given an expression \e{} and variables ${\ova{\x{}}}$ to track,
\instrumentnoalign{\e{}}{\ova{\x{}}}{\ep{}}
returns an instrumented expression \ep{}
that tracked usages of $\ova{\x{}}$.
It is defined via capture-avoiding substitution:
$$
\instrumentnoalign{\e{}}{\ova{\x{}}}{\replacefor{\e{}}{\ova{\trackE{\x{}}{[\x{}]}}}{\ova{\x{}}}}
$$

Then, the overall collection phase 
\collectnoalign{\e{}}{\ova{\x{}}}{\res{}}
says, given an expression \e{}
and variables
$\ova{\x{}}$
to track,
returns inference results {\res{}}
that are the results of evaluating \e{}
with instrumented occurrences of $\ova{\x{}}$.
It is defined as:
%
$$
\collectnoalign{\e{}}{\ova{\x{}}}{\res{}}, \text{ where }
  \opsemtrack{}{\instrument{\e{}}{\ova{\x{}}}}{\v{}}{\res{}}
$$

For our running example
of collecting for the program \appexp{f}{\curlymap{\makekw{a}\ 42}},
we instrument the program by wrapping occurrences of $f$ with \trackEOp{}
with path $[f]$.
$$
\instrumentnoalign{\appexp{f}{\curlymap{\makekw{a}\ 42}}}{[f]}{\appexp{\trackE{f}{[f]}}{\curlymap{\makekw{a}\ 42}}}
$$

Then we evaluate the instrumented program and derive two inference results:
$$
\opsemtrack{}{\appexp{\trackE{f}{[f]}}{\curlymap{\makekw{a}\ 42}}}{42}{\resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT{}}, \resentry{[f, \rngpe{}]}{\IntT{}}}}
$$

Here is the full derivation:
\begin{Verbatim}[commandchars=\\\{\}, codes={\catcode`$=3\catcode`^=7}]
=> \appexp{\trackE{f}{[f]}}{\curlymap{\makekw{a}\ 42}}
=> \trackE{\getexp{\trackE{\curlymap{\makekw{a}\ 42}}{[f, \dompe{}]}}{\makekw{a}}}{[f, \rngpe{}]}
=> \trackE{\getexp{{\curlymap{\makekw{a}\ 42}} ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT{}}}}{\makekw{a}}}{[f, \rngpe{}]}
=> \trackE{42 ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT{}}}}{[f, \rngpe{}]}
=> $42 ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT{}}, \resentry{[f, \rngpe{}]}{\IntT{}}}$
\end{Verbatim}

Notice that intermediate values can have inference results (colored) attached to them with a semicolon,
and the final value has inference results about both $f$'s domain and range.

\section{Inference phase}

After the collection phase, we have a collection of inference results \res{}
which can be passed to the 
metafunction \inferanns{}(\res{}) = \atenv{} to produce an annotation environment:
\begin{mathpar}
  \begin{array}{lllll}
    \inferanns{} : \res{} \rightarrow \atenv{}\\
    \inferanns{} = \inferrecOp{} \circ \generatetenv{}\\\\
  \end{array}
\end{mathpar}

The first pass $\generatetenv{} (\res{}) = \tenv{}$ generates an initial type environment
from inference results \res{}.
%It is defined (in \figref{infer:fig:generatetenv})
%as a fold over \res{}, building a \tenv{} incrementally via the \inferupdateOp{}
%metafunction.
%
The second pass $\squashlocal{}(\tenv{}) = \atenvp{}$ creates individual type aliases
for each HMap type in \tenv{} and then merges aliases that both occur inside the same
nested type into possibly recursive types. % (\figref{infer:fig:squashlocal}).
%
The third pass $\squashglobal{} (\atenv{}) = \atenvp{}$
merges type aliases in \atenv{} based on their similarity. % (\figref{infer:fig:squashglobal}).

\subsection{Pass 1: Generating initial type environment}

The first pass is given in \figref{infer:fig:generatetenv}.

%\begin{figure*}
%\begin{mathpar}
%  \begin{array}{lllll}
%    \inferanns{} : \res{} \rightarrow \atenv{}\\
%    \inferanns{} = \squashglobal{} \circ \squashlocal{} \circ \generatetenv{}\\
%  \end{array}
%\end{mathpar}
%\caption{Algorithm summary: Generate an initial type environment from inference results.
%Then generate an updated type environment paired with a type alias environment by 1: creating
%a recursive type if a HMap contains another HMap whose keysets have a non-empty intersection, 2:
%globally merging type aliases based on identical HMap keysets, 3: cleaning up redundant aliases.}
%\label{infer:fig:inferanns}
%\end{figure*}

\begin{figure*}
\begin{mathpar}
  \begin{array}{rllll}
    \joinOp{} : \t{}, \t{} \rightarrow \t{}
    \\
    \joinalign{\Unionsplice{\ova{\s{}}}}{\t{}}{\Unionsplice{\ova{\joinexpression{\s{}}{\t{}}}}}
    \\
    \joinalign{\t{}}{\Unionsplice{\ova{\s{}}}}{\Unionsplice{\ova{\joinexpression{\s{}}{\t{}}}}}
    \\
    \joinalign{\UnknownT{}}{\t{}}{\t{}}
    \\
    \joinalign{\t{}}{\UnknownT{}}{\t{}}
    \\
    \joinalign{\arrow{\t{1}}{\s{1}}}{\arrow{\t{2}}{\s{2}}}
              {\arrow{\joinexpression{\t{1}}{\t{2}}}
                     {\joinexpression{\s{1}}{\s{2}}}}
    \\
    \joinalign{\HMaptwo{\HMapreq{1}}{\HMapopt{1}}}
              {\HMaptwo{\HMapreq{2}}{\HMapopt{2}}}
              {\joinHMapexpression{\HMaptwo{\HMapreq{1}}{\HMapopt{1}}}
                                  {\HMaptwo{\HMapreq{2}}{\HMapopt{2}}}}
                                  \text{,}
                                  \\
    &&\ova{(\kw{}, \kw{i}) \in {\HMapreq{i}}} \Rightarrow \ova{\kw{i-1} = \kw{i}}
    \\
    \joinalign{\t{}}{\s{}}{\Union{\t{}}{\s{}}} \text{, otherwise}
  \end{array}
%
  \begin{array}{lllll}
    \joinHMapnoalign{\HMaptwo{\HMapreq{1}}{\HMapopt{1}}}{\HMaptwo{\HMapreq{2}}{\HMapopt{2}}}{\HMaptwo{\HMapreq{}}{\HMapopt{}}}
    \\
    \begin{array}{lllll}
      \text{where}
          &\mathsf{req}  = \bigcup \ova{\textsf{dom}({\HMapreq{i}})} \\
          &\mathsf{opt}  = \bigcup \ova{\textsf{dom}({\HMapopt{i}})} \\
          &\ova{\kw{}^r} = \bigcap \ova{\textsf{dom}({\HMapreq{i}})} \setminus \mathsf{opt}\\
          &\ova{\kw{}^o} = \mathsf{opt} \cup (\mathsf{req} \setminus \ova{\kw{}^r})\\
          &\HMapreq{}    = \{\ova{\kw{}^r\ \joinstarexpression{\ova{\HMapreq{i}[\kw{}^r]}}} \} \\
          &\HMapopt{}    = \{\ova{\kw{}^o\ \joinstarexpression{\ova{\HMapreq{i}[\kw{}^o], \HMapopt{i}[\kw{}^o]}}} \}
    \end{array}
  \end{array}

  \begin{array}{lllll}
    \textsf{fold} : (\alpha, \beta \rightarrow \alpha), \alpha, \ova{\beta} \rightarrow \alpha\\
    \textsf{fold}(\textsf{f}, \textsf{a}_0, \ova{\textsf{b}}^n) = \textsf{a}_n\\
    \begin{array}{llll}
      \text{where } \ova{\textsf{a}_i = \textsf{f}(\textsf{a}_{i-1}, \textsf{b}_{i})}^{1 \leq i \leq n}\\
    \end{array}
    \\\\
    \generatetenv{} : \res{} \rightarrow \tenv{}\\
    \generatetenv{} (\res{}) = \textsf{fold}(\inferupdateOp{}, \{\}, \res{})\\
  \end{array}
  \begin{array}{lllll}
    \inferupdateOp : \tenv{}, \resentry{\inferpath{}}{\t{}} \rightarrow  \tenv{} 
    \\
    \inferupdatealign{\tenv{}}{\appendone{\inferpath{}}{\inferkeype{\{\ova{\kwp{}\ \s{}} \}}{\kw{}}}}{\t{}}
            {\inferupdate{\tenv{}}{\inferpath{}}{\{\ova{\kwp{}\ \s{}}\ \kw{}\ \t{} \}}}
    \\
    \inferupdatealign{\tenv{}}{\appendone{\inferpath{}}{\dompe{}}}{\t{}}
                     {\inferupdate{\tenv{}}{\inferpath{}}{\arrow{\t{}}{\UnknownT{}}}}
    \\
    \inferupdatealign{\tenv{}}{\appendone{\inferpath{}}{\rngpe{}}}{\t{}}
                {\inferupdate{\tenv{}}{\inferpath{}}{\arrow{\UnknownT{}}{\t{}}}}
    \\
    \inferupdatealign{\updatemap{\tenv{}}{\x{}}{\s{}}}{[x]}{\t{}}
                     {\updatemap{\tenv{}}
                                {\x{}}
                                {\joinexpression{\t{}}{\s{}}}
                                 }
    \\
    \inferupdatealign{\tenv{}}{[\xvar{}]}{\t{}}{\updatemap{\tenv{}}{\x{}}{\t{}}}
    \\
  \end{array}

\end{mathpar}
\caption{Definition of $\generatetenv{}(\res{}) = \tenv{}$}
\label{infer:fig:generatetenv}
\end{figure*}


\begin{figure*}
\begin{mathpar}
  \begin{array}{lllll}
    \aliashmap{} : \atenv{}, \t{} \rightarrow (\atenv{}, \t{})\\
    \aliashmap{}(\atenv{}, \t{}) = \textsf{postwalk}(\atenv{}, \t{}, \textsf{f})\\
    \begin{array}{lllll}
      \text{where} %&\textsf{f} : \atenv{}, \t{} \rightarrow (\atenv{}, \t{})\\
                   &\textsf{f}(\atenv{}, {\HMaptwo{\HMapreq{1}}{\HMapreq{2}}}) = \register{}(\atenv{},\HMaptwo{\HMapreq{1}}{\HMapreq{2}})\\
                   &\textsf{f}(\atenv{}, \Unionsplice{\ova{\t{}}}) = \register{}(\atenv{},\Unionsplice{\ova{\textsf{resolve}(\t{})}}) \text{,}\\
                   &\text{ if } \exists\t{}(\ova{\s{}}^m) \in\ova{\t{}} .\ m > 0\\
                   &\textsf{f}(\atenv{}, \t{}) = (\atenv{}, \t{}), \text{otherwise}
    \end{array}
  \end{array}
  \begin{array}{lllll}
    \register{} : \atenv{}, \t{} \rightarrow (\atenv{}, \t{})\\
    \register{}(\atenv{}, \t{}) = (\updatemap{\atenv{}}{\alias{}}{\t{}}, \alias{}), \text{ where } \alias{} \text{ is fresh}
    \\\\
    \textsf{resolve} : \atenv{}, \t{} \rightarrow \t{}\\
    \textsf{resolve}(\atenv{}, \alias{}) = \textsf{resolve}(\atenv{}[\alias{}])\\
    \textsf{resolve}(\atenv{}, \t{}) = \t{}  \text{, otherwise}
  \end{array}

  \begin{array}{lllll}
    \textsf{postwalk} : \atenv{}, \t{}, (\atenv{}, \t{} \rightarrow (\atenv{}, \t{})) \rightarrow (\atenv{}, \t{})\\
    \textsf{postwalk}(\atenv{0}, \t{}(\ova{\s{}}^n), \textsf{w}) = \textsf{w}(\atenv{n}, \t{}(\ova{\sp{}}))\\
    \begin{array}{lllll}
      \text{where}
        &\ova{(\atenv{i}, \sp{i}) = \textsf{postwalk}(\atenv{i-1}, \s{i}, \textsf{w})}\\
    \end{array}
    \\\\
    \shouldmergeOp{} : \ova{\t{}} \rightarrow \textbf{Bool}\\
    \shouldmergeOp{}(\ova{\HMaptwo{\HMapreq{i}}{\HMapopt{i}}}) = \exists\kw{}. \ova{(\kw{}, \kw{i}) \in \HMapreq{i}}\\
    \shouldmergeOp{}(\ova{\t{}}) = \textbf{F}, \text{ otherwise}\\
    \\
    \trymergealias{} : \atenv{}, \alias{}, \alias{} \rightarrow \atenv{}
    \\
    \trymergealias{}(\atenv{}, \alias{1}, \alias{2}) =\\
    \begin{array}{llll}
      \textsf{if } \neg \shouldmergeOp{}(\ova{\textsf{resolve}(\alias{})}) \textsf{ then } \atenv{}\\
      \textsf{else } \updatemap{\updatemap{\atenv{}}{\alias{2}}{\alias{1}}}
                               {\alias{1}}
                               % this fixes the "too much garbage" issue
                               {\joinstarexpression{\ova{\replacefor{\atenv{}[\alias{i}]}{\alias{1}}{\alias{2}}}}}\\
    \end{array}\\
      \\
      %fold-based version
    \squashlocal{} : \tenv{} \rightarrow \atenv{}\\
    \squashlocal{}(\tenv{}) = \textbf{fold}(\steptwohelper{}, \emptyatenv{}, \tenv{})\\
    \begin{array}{lllll}
      \text{where} &\steptwohelper{} (\atenv{}, \hastype{\x{}}{\t{}}) = \updatemap{\atenv{2}}{\x{}}{\t{2}}\\
                   &\begin{array}{lllll}
                      \text{where}
                        &(\atenv{1}, \t{1}) = \aliashmap{}(\atenv{}, \t{})\\
                        &(\atenv{2}, \t{2}) = \squashall{}(\atenv{1}, \t{1})\\
                    \end{array}
    \end{array}
      %nonfold-based version
    %\squashlocal{} : \atenv{} \rightarrow \atenv{}\\
    %\squashlocal{}(\atenv{0}) = \atenv{n}\\
    %\begin{array}{lllll}
    %  \text{where}\\
    %  \begin{array}{lllll}
    %    \steptwohelper{} (\atenv{}, \x{}, \t{}) = \replacefor{\atenv{2}}{\t{2}}{\x{}}\\
    %    \begin{array}{lllll}
    %      \text{where}
    %      &(\atenv{1}, \t{1}) = \aliashmap{}(\atenv{}, \t{})\\
    %      &(\atenv{2}, \t{2}) = \squashall{}(\atenv{1}, \t{1})\\
    %    \end{array}
    %    \\
    %    \ova{\hastype{\x{}}{\t{}}}^n = \atenv{0}[\tenv{}]\\
    %    \ova{\atenv{i} = \steptwohelper{}(\atenv{i-1},{\x{i}},{\t{i}})} \\
    %  \end{array}
    %\end{array}
  \end{array}
  \begin{array}{llll}
    \squashall{} : \atenv{}, \t{} \rightarrow \atenv{}\\
    \squashall{}(\atenv{0}, \t{}) = \atenv{n} \\
    \begin{array}{lllll}
      \begin{array}{@{}llll}
        \text{where}\\
        \begin{array}{llll}
          \ova{\alias{}}^n = \aliasesin{}(\t{})\\
          \ova{\atenv{i} = \squash{}(\atenv{i-1}, [\alias{i}], [])}\\
          \squash : \atenv{}, \ova{\alias{}}, \ova{\alias{}} \rightarrow \atenv{}\\
          \squash(\atenv{}, [], \textsf{d}) = \atenv{}\\
          \squash(\atenv{}, \alias{} :: \textsf{w}, \textsf{d}) = \\
          \begin{array}{lllll}
            \squash(\atenvp{}, \textsf{w} \cup \textsf{as}, \textsf{d} \cup \{\alias{}\})\\
            \begin{array}{@{}llll}
              \text{where }
              &\textsf{as} = \aliasesin{}(\atenv{}[\alias{}]) \setminus \textsf{d}\\
              &\textsf{ap} = \textsf{d} \setminus \{\alias{}\}\\
              &\textsf{f}(\atenv{}, \aliasp{}) = \trymergealias{}(\atenv{}, \aliasp{}, \alias{})\\
              &\begin{array}{@{}llll}
                \atenvp{} &= \textsf{if } \alias{} \in \textsf{d} \textsf{, then } \atenv{} \text{,}\\
                          &\textsf{else } \textsf{fold}(\textsf{f}, \atenv{}, \textsf{ap} \cup \textsf{as})
              \end{array}
            \end{array}
          \end{array}
        \end{array}
      \end{array}
    \end{array}
    \\\\
    \aliasesin{} : \t{} \rightarrow \ova{\alias{}}\\
    \aliasesin{}(\alias{}) = [\alias{}]\\
    \aliasesin{}(\t{}(\ova{\s{}})) = \bigcup{\ova{\aliasesin{}(\s{})}}
  \end{array}

\end{mathpar}
\caption{Definition of $\squashlocal{}(\tenv{}) = \atenv{}$
%\aliasesin{}(\t{}) returns the set of aliases that syntactically occur in \t{}.
%  Step 2 summary: Create aliases for HMaps (graph nodes), then squash recursive types locally
%(don't try to merge data examples from different paths). Omitted: follow-aliases call, that erases
%redundant aliases.
  }
  \label{infer:fig:squashlocal}
\end{figure*}

\begin{figure*}
\begin{mathpar}
  \begin{array}{lllll}
    \squashglobal{} : \atenv{} \rightarrow \atenv{}\\
    \squashglobal{} = \squashhorizonally{} \circ \aliassinglehmap{}
    \\\\
    \aliassinglehmap{} : \atenv{} \rightarrow \atenv{}\\
    \aliassinglehmap{}(\atenv{}) = \textsf{fold}(\textsf{f}, \atenvp{}, \text{rng}(\atenvp{}[\aenv{}]))\\
    \begin{array}{llll}
      \text{where } &\atenvp{} = \textsf{fold}(\singlehmap{}, \atenv{}, \text{rng}(\atenv{}[\tenv{}]))\\
                    &\textsf{f}(\atenv{0}, \t{}(\ova{\s{}}^n)) = (\atenv{n}, \t{}(\sp{})) \text{, if } \t{} = \HMaptwo{\HMapreq{}}{\HMapopt{}}\\
                    &\begin{array}{lllll}
                      \text{where } \ova{(\atenv{i}, \s{i}) = \singlehmap{}(\atenv{i-1}, \s{i})}
                     \end{array}
                    \\
                    &\textsf{f}(\atenv{}, \t{}) = \singlehmap{}(\atenv{}, \t{}) \text{, otherwise}
    \end{array}
    \\\\
    \singlehmap{} : \atenv{}, \t{} \rightarrow (\atenv{}, \t{})\\
    \singlehmap{}(\atenv{}, \t{}) = \textsf{postwalk}(\atenv{}, \t{}, \textsf{f})\\
    \begin{array}{lllll}
      \text{where} &\textsf{f}(\atenv{}, {\HMaptwo{\HMapreq{1}}{\HMapreq{2}}}) = \register{}(\atenv{},\HMaptwo{\HMapreq{1}}{\HMapreq{2}})\\
                   &\textsf{f}(\atenv{}, \t{}) = (\atenv{}, \t{}), \text{otherwise}
    \end{array}
  \end{array}

  \begin{array}{lllll}
    \inferrecOp{} : \tenv{} \rightarrow \atenv{}\\
    \inferrecOp{} = \squashglobal{} \circ \squashlocal{}
  \end{array}
\end{mathpar}
\caption{
%  Step 3 summary: First ensure all HMaps correspond to an alias. Then merge
%aliases that point to a HMaps with identical required keysets (aliases must point to exactly one
%top-level HMap, no unions).
  }
  \label{infer:fig:squashglobal}
\end{figure*}

% Things we could prove:
% - update is commutative
