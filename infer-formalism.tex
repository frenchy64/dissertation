\chapter{Formalism}

We present \lambdatrack{}, an untyped $\lambda$-calculus
that describes the essense of our approach to automatic annotations.
Our model is split into two phases: the collection phase 
\collectOp{}
that runs an instrumented program and collects observations, and
an inference phase 
\inferanns{}
that derives type annotations from these observations
that can be used to automatically annotate the program.

Before getting into details, we define the top-level driver function \annotateOp{} that connects
both pieces.
It says, given a program \e{}
and top-level variables $\overrightarrow{\x{}}$ to infer annotations for,
return an annotation environment \atenv{} with possible entries for
$\overrightarrow{\x{}}$ based on observations from evaluating
an instrumented \e{}.

\begin{mathpar}
\infer[Driver]
{ \collectnoalign{\e{}}{\overrightarrow{\x{}}}{\res{}}
  \\
  \inferannsnoalign{\res{}}{\atenv{}}
}
{ \annotatenoalign{\e{}}{\overrightarrow{\x{}}}{\atenv{}} }
\end{mathpar}

To contextualize the presentation of these phases, we begin a running example:
inferring the type of a top-level function $f$, that takes a map and
returns its {\makekw{a}} entry, 
based on the following usage.

\begin{Verbatim}[commandchars=\\\{\}, codes={\catcode`$=3\catcode`^=7}]
define $f$ = \uabs{m}{\getexp{m}{\makekw{a}}}

\appexp{f}{\curlymap{\makekw{a} 42}}
=> 42
\end{Verbatim}

Plugging this example into our driver function, where \e{} = {\appexp{f}{\curlymap{\makekw{a}\ 42}}},
we derive an annotation for $f$:

$$
\annotatenoalign{\e{}}{[f]}{\{\hastype{f}{[\{\makekw{a}\ \IntT{}\} \rightarrow \IntT{}]}\}}
$$

Now that we have a high-level picture of how these phases interact,
we describe the syntax and semantics of \lambdatrack{}, before
presenting the details of \collectOp{}.

\figref{infer:fig:syntax} presents the syntax of \lambdatrack{}.
Values \v{} consist of numbers \num{}, Clojure-style keywords {\kw{}},
closures {\closure{\uabs{\x{}}{\e{}}}{\openv{}}}, constants \const{},
and keyword keyed hash maps {\curlymapvaloverrightnoarrow{\kw{}}{\val{}}}.

Expressions \e{} consist of variables \x{}, values,
functions, hash-maps, and function applications.
The special form
\trackE{\e{}}{\inferpath{}}
observes {\e{}} as related to path {\inferpath{}}.
Paths \inferpath{} 
record the source of a runtime value with respect
to a sequence of path elements \pth{}, which always starts with
a variable \x{}, and are read left-to-right.
Other path elements are
a function domain \dompe{}, 
a function range \rngpe{},
and a map entry {\inferkeype{\overrightarrow{\kw{1}}}{\kw{2}}}
which represents the result of looking up key {\kw{2}}
in a map with keyset ${\overrightarrow{\kw{1}}}$.

Inference results \restwoarrow{\inferpath{}}{\t{}}
are pairs of paths {\inferpath{}} and types \t{}
that say the path \inferpath{} was observed to be 
type \t{}.
Types \t{} are numbers \IntT{}, function types \arrow{\t{}}{\t{}},
ad-hoc union types \Union{\t{}}{\t{}},
type aliases \alias{},
%top type \Top{},
and unknown type \UnknownT{} that represents
a temporary lack of knowledge during the inference process.
Heterogeneous keyword map types \HMappretty{\overrightarrow{\kw{}\ \t{}}}
for now represent a series of required keyword entries---we will extend
them to have optional entries in later phases.

\begin{figure*}
  $$
  \begin{altgrammar}
    \val{} &::=& \num{}
       \alt {\kw{}}
       \alt {\closure{\uabs{\x{}}{\e{}}}{\openv{}}}
       \alt {\curlymapvaloverrightnoarrow{\kw{}}{\val{}}}
       \alt {\const{}}
       &\mbox{Values} \\
   \e{} &::=& \x{}
       \alt \val
       \alt \trackE{\e{}}{\inferpath{}}
       \alt {\uabs{\x{}}{\e{}}}
       \alt {\curlymapvaloverrightnoarrow{\e{}}{\e{}}}
       \alt {\appexp{\e{}}{\overrightarrow{\e{}}}}
       &\mbox{Expressions} \\
    \openv{} &::=& \{\overrightarrow{x \mapsto \val}\}
       &\mbox{Runtime environments} \\
   \pth{}
      &::=& \x{}
       \alt \dompe{}
       \alt \rngpe{}
       \alt {\inferkeype{\overrightarrow{\kw{}}}{\kw{}}}
       &\mbox{Path Elements} \\
   \inferpath{} &::=& \overrightarrow{\pth{}}
       &\mbox{Paths} \\
       \res{}
      &::=& \restwoarrow{\inferpath{}}{\tau{}}
      &\mbox{Inference results} \\
    \ty{}, \sigma
      &::=& \IntT{}
       \alt \arrow{\t{}}{\t{}}
       \alt \HMappretty{\overrightarrow{\kw{}\ \t{}}}
       %&\alt& \HMaptwo{\{\overrightarrow{\kw{}\ \tau}\}}{\{\overrightarrow{\kw{}\ \tau}\}}
       \alt \Union{\t{}}{\t{}}
       \alt \alias{} % type alias
       %\alt \Top{}
       \alt \UnknownT{}
      &\mbox{Types} \\
    \tenv{} &::=& \{\overrightarrow{\xvar{} : \tau}\}
      &\mbox{Type environments} \\
    \aenv{} &::=& \{\overrightarrow{\alias{} \mapsto \tau}\}
      &\mbox{Type alias environments} \\
    \atenv{} &::=& (\aenv{}, \tenv{})
      &\mbox{Annotation environments} \\
  \end{altgrammar}
  $$
\caption{Syntax of Terms, Types, Inference results, and Environments for \lambdatrack{}}
\label{infer:fig:syntax}
\end{figure*}

The big-step operational semantics
{\opsemtrack{\openv{}}{\e{}}{\v{}}{\res{}}}
(\figref{infer:fig:semantics})
says under runtime environment \openv{}
expression \e{} evaluates to value \v{}
with inference results \res{}.
Most rules are standard, with extensions to correctly
propagate inference results \res{}.
B-Track is the only interesting rule, which instruments
its fully-evaluated argument with the \trackmetaOp{}
metafunction.

The metafunction \trackmeta{\v{}}{\inferpath{}}{\vp{}}{\res{}} (\figref{infer:fig:trackmeta})
says if value \v{} occurs at path {\inferpath{}}, then return a possibly-instrumented
\vp{} paired with inference results {\res{}} that can be immediately derived
from the knowledge that \v{} occurs at path {\inferpath{}}.
It has a case for every kind of value.
The first case records the number input as type {\IntT{}}.
The second case, for closures, returns a wrapped value
resembling higher-order function contracts~\cite{findler2002contracts},
but we track the domain and range rather than verify them.
The third case, for maps, recursively tracks each map value,
and returns a map with possibly wrapped values.
Immediately accessible inference results are combined
and returned.
The other cases are straightforward.

\begin{figure*}
\begin{mathpar}
%\infer [B-Var]
%{ track(\openv{}(x), [x]) = v\ ; res }
%{ \openv{} \vdash x \Downarrow v\ ; res}

% track is inserted manually
\infer [B-Var]
{}
{ \opsemtrack{\openv{}}{\xvar{}}{\inopenvnoeq{\openv{}}{\xvar{}}}{\emptyres{}}
}

\infer [B-Track]
{ \opsemtrack{\openv{}}{\e{}}{\v{}}{\res{}} \\
  \trackmeta{\v{}}{\inferpath{}}{\vp{}}{\resp{}}}
{ \opsemtrack{\openv{}}{\trackE{\e{}}{\inferpath{}}}{\vp{}}{\unionres{\res{}}{\resp{}}}
}

\infer [B-App]
{ \opsemtrack{\openv{}}{\e{1}}{[\lambda \x{}. \e{}, \openvp{}]}{\res{1}} \\\\
  \opsemtrack{\openv{}}{\e{2}}{\v{}}{\res2} \\\\
  \opsemtrack{\extendopenv{\openvp{}}{\x{}}{\v{}}}{\e{}}{\vp{}}{\res{3}} \\
}
{ \opsemtrack{\openv{}}{\appexp{\e{1}}{\e{2}}}{\vp{}}{\unionresthree{\res{1}}{\res{2}}{\res{3}}}
}

\infer [B-Clos]
{}
{ \opsemtrack{\openv{}}{\lambda \xvar{}. \e{}}{[\lambda \overrightarrow{\xvar{}} . \e{}, \openv{} ]}{\emptyres{}}}

\infer [B-Val]
{}
{ \opsemtrack{\openv{}}{\val{}}{\val{}}{\emptyres{}} }

%\infer [B-Get]
%{ \opsemtrack{\openv{}}{\e{1}}{\{ \overrightarrow{\kw{}\ \v{}} \}}{\res{1}} \\
%  \opsemtrack{\openv{}}{\e{2}}{\kw1}{\res{2}} \\
%}
%{ \opsemtrack{\openv{}}{\getexp{\e{1}}{\e{2}}}{\getmap{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\kw{1}}}{\unionres{\res{1}}{\res{2}}}
%}
%
%\infer [B-Assoc]
%{ 
%  \opsemtrack{\openv{}}{\e{1}}{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\res{1}} \\
%  \opsemtrack{\openv{}}{\e{2}}{\kw{1}}{\res{2}} \\
%  \opsemtrack{\openv{}}{\e{3}}{\v{}}{\res{3}} \\
%}
%{ \opsemtrack{\openv{}}
%             {\assocexp{\e{1}}{\e{2}}{\e{3}}}
%             {\extendmap{\curlymapvaloverrightnoarrow{\kw{}}{\v{}}}{\kw{1}}{\v{}}}
%             {\unionresthree{\res{1}}{\res{2}}{\res{3}}}
%}

\infer [B-Delta]
{ \opsemtrack{\openv{}}{\e{}}{\const{}}{\res{}}
  \\
  \overrightarrow{\opsemtrack {\openv{}}{\ep{}}{\v{}}{\resp{}}}
  \\
  \constantopsem{\const{}}{\overrightarrow{\v{}}} = \vp{}
}
{ \opsemtrack {\openv{}}
              {\appexp {\e{}} {\overrightarrow{\ep{}}}}
              {\vp{}}
              {\unionres{\bigunionres{\resp{}}}{\res{}}}
       }

\end{mathpar}
\caption{Operational Semantics for \lambdatrack{}}
\label{infer:fig:semantics}
\end{figure*}

\begin{figure*}
\begin{mathpar}

  \begin{array}{lllll}
    %\trackmeta{\v{}}{\inferpath{}}{\v{}}{\res{}}\\\\

    \trackmetaalign{\num{}}{\inferpath{}}{\num{}}{\singletonres{\inferpath{}}{\IntT{}}}
    \\
    \trackmetaalign{\closure{\uabs{\x{}}{\e{}}}{\openv{}}}
                   {\inferpath{}}
                   {\closure{\uabs{\y{}}
                                  {\trackE{\appexp{\uabs{\x{}}{\e{}}}
                                                  {\trackE{\yvar{}}{\appendone{\inferpath{}}{\dompe{}}})}}
                                          {\appendone{\inferpath{}}{\rngpe{}}}}}
                            {\openv{}}}
                   {\singletonres{\inferpath{}}
                                 {\arrow{\UnknownT{}}{\UnknownT{}}}}
         \\
    &&
    \text{where}\ \y{} \text{ is fresh}
    \\
    \trackmetaalign{\curlymapvaloverrightnoarrow{\v{1}}{\v{2}}}
                   {\inferpath{}}
                   {\curlymapvaloverrightnoarrow{\v{1}}{\vp{2}}}
                   {\unionres{\bigunionres{\res{}}}
                             {\singletonres{\inferpath{}}{\curlymapvaloverrightnoarrow{\v{1}}{\UnknownT{}}}}}
    \\
    &&
    \text{where}\ \overrightarrow{\trackmeta{\v{2}}{\appendone{\inferpath{}}{\inferkeype{\overrightarrow{\val1}}{\val1}}}{\vp{2}}{\res{}}}
    \\
    \trackmetaalign{\kw{}}{\inferpath{}}{\kw{}}{\emptyres{}}
    \\
    \trackmetaalign{\const{}}{\inferpath{}}{\const{}}{\emptyres{}}
    \\
  \end{array}

\end{mathpar}
\caption{Definition of \trackmeta{\v{}}{\inferpath{}}{\v{}}{\res{}}}
\label{infer:fig:trackmeta}
\end{figure*}

Now we have sufficient pieces to describe the initial collection phase of our model.
Given an expression \e{} and variables ${\overrightarrow{\x{}}}$ to track,
\instrumentnoalign{\e{}}{\overrightarrow{\x{}}}{\ep{}}
returns an expression \ep{} with each occurrence of \x{} instrumented.
It is defined via capture-avoiding substitution:

$$
\instrumentnoalign{\e{}}{\overrightarrow{\x{}}}{\replacefor{\e{}}{\overrightarrow{\trackE{\x{}}{[\x{}]}}}{\overrightarrow{\x{}}}}
$$

Then, the overall collection phase 
\collectnoalign{\e{}}{\overrightarrow{\x{}}}{\res{}}
says, given an expression \e{}
and variables
$\overrightarrow{\x{}}$
to track,
returns inference results {\res{}}
that are the results of evaluating \e{}
with instrumented occurrences of $\overrightarrow{\x{}}$.
It is defined as:

\begin{mathpar}
\infer[]
  { \instrumentnoalign{\e{}}{\overrightarrow{\x{}}}{\ep{}}
  \\
  \opsemtrack{\emptyopenv{}}{\ep{}}{\v{}}{\res{}}
  }
  { \collectnoalign{\e{}}{\overrightarrow{\x{}}}{\res{}} }
\end{mathpar}

For our running example,
we instrument the program by wrapping each usage of $f$ with \trackEOp{}
with an initial path of $[f]$ (itself), and collect \emph{inference results}
as the program evaluates.

\opsemtrack{}{\e{}}{\v{}}{\res{}}

\begin{Verbatim}[commandchars=\\\{\}, codes={\catcode`$=3\catcode`^=7}]
=> \appexp{f}{\curlymap{\makekw{a}\ 42}}
=> \appexp{\trackE{f}{[f]}}{\curlymap{\makekw{a}\ 42}}
=> \trackE{\getexp{\trackE{\curlymap{\makekw{a}\ 42}}{[f, \dompe{}]}}{\makekw{a}}}{[f, \rngpe{}]}
=> \trackE{\getexp{{\curlymap{\makekw{a}\ 42}} ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT}}}{\makekw{a}}}{[f, \rngpe{}]}
=> \trackE{42 ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT}}}{[f, \rngpe{}]}
=> $42 ; \resflatcolor{\resentry{[f, \dompe{}, \inferkeypenokeyset{[\makekw{a}]}{\makekw{a}}]}{\IntT{}}, \resentry{[f, \rngpe{}]}{\IntT{}}}$
\end{Verbatim}

Notice that values can have inference results (colored) attached to them with a semicolon,
and the final value has inference results about both $f$'s domain and range.
To explain this reduction, we introduce the semantic rules of \lambdatrack{}.

\begin{figure*}
\begin{mathpar}
  \begin{array}{lllll}
    %\inferupdatenoalign{\aenv{}}{\tenv{}}{\inferpath{}}{\tau}{\atenv{}}
    %\\\\

    \inferupdatealign{\aenv{}}{\tenv{}}{\appendone{\inferpath{}}{\inferkeype{\overrightarrow{\kw{}'}}{\kw{}}}}{\ty{}}
            {\inferupdate{\aenv{}}{\tenv{}}{\inferpath{}}{\{\overrightarrow{\kw{}' : \UnknownT{}},\ \kw{} : \ty{} \}}}
    \\
    \inferupdatealign{\aenv{}}{\tenv{}}{\appendone{\inferpath{}}{\dompe{}}}{\ty{}}
                {\inferupdate{\aenv{}}{\tenv{}}{\inferpath{}}{\arrow{\ty{}}{\UnknownT{}}}}
    \\
    \inferupdatealign{\aenv{}}{\tenv{}}{\appendone{\inferpath{}}{\rngpe{}}}{\ty{}}
                {\inferupdate{\aenv{}}{\tenv{}}{\inferpath{}}{\arrow{\UnknownT{}}{\ty{}}}}
    \\
    \inferupdatealign{\aenv{}}{\tenv{}}{[x]}{\ty{}}{(\tenv{}[\sigma / \xvar{}] , \aenv{}')}
    \\
    && \text{where}\ \tenv{}(\xvar{}) = \ty{}', join(\aenv{}, \ty{}, \ty{}') = \sigma\ ;\ \aenv{}'
    \\
    \inferupdatealign{\aenv{}}{\tenv{}}{[\xvar{}]}{\ty{}}{(\tenv{}[\ty{} / \xvar{}], \aenv{})}
    \\
    && \text{where}\ \xvar{} \not\in dom(\tenv{})
  \end{array}
\end{mathpar}
\caption{Definition of \inferupdatenoalign{\aenv{}}{\tenv{}}{\inferpath{}}{\tau}{\atenv{}}}
\label{infer:fig:update}
\end{figure*}

\begin{figure*}
\begin{mathpar}
  \begin{array}{lllll}
    %\joinnoalign{\aenv{}}{\tau}{\tau}{\tau}
    %\\ \\

    \joinalign{\aenv{}}{(\cup\ \overrightarrow{\tau_1})}{\tau}{(\cup\ \overrightarrow{\sigma})}\\
                                                    && \text{where }
                                                    \overrightarrow{\joinnoalign{\aenv{}}{\tau_1}{\tau}{\sigma}}
    \\
    \joinalign{\aenv{}}{\tau}{(\cup\ \overrightarrow{\tau_1})}{(\cup\ \overrightarrow{\sigma})} \\
                                                    && \text{where }
                                                    \overrightarrow{\joinnoalign{\aenv{}}{\tau_1}{\tau}{\sigma}}
    \\
    \joinalign{\aenv{}}{\UnknownT{}}{\tau}{\tau}
    \\
    \joinalign{\aenv{}}{\tau}{\UnknownT{}}{\tau}
    \\
    \joinalign{\aenv{}}{[\overrightarrow{\tau_1} \rightarrow \sigma_1]}{[\overrightarrow{\tau_2} \rightarrow \sigma_2]}{[\overrightarrow{\joinexpression{\aenv{}}{\tau_1}{\tau_2}}
    \rightarrow
    \joinexpression{\aenv{}}{\sigma_1}{\sigma_2}]}
    \\
    % TODO add condition on should-join-HMap?
    %join(A, (HMap\  m_1\ o_1), (HMap\  m_2\ o_2))
    %&=& joinHMap(A, (HMap\  m_1\ o_1), (HMap\  m_2\ o_2))
    %\\
    \joinalign{\aenv{}}{\tau}{\sigma}{(\cup\ \tau\ \sigma)}

  \end{array}

\end{mathpar}
\caption{Definition of \joinnoalign{\aenv{}}{\tau}{\tau}{\tau}}
\label{infer:fig:join}
\end{figure*}
