We thank the reviewers for their time and thorough reviews.

EVALUATION


Most reviewers had reservations about our evaluation.

We will clarify (here and in the paper) the *purpose* of our evaluation to the reader.

Our evaluation tests whether our *workflow* is effective starting from types
generated following our *methodology* (Section 2).

Our workflow is:

1. Run our tool, generating initial annotations
2. Type check the program with Typed Clojure (TC)
   (incorrectly annotated TC programs run as normal Clojure programs)
3. Respond to static typing errors by scanning the program and making minor changes.
4. Go to 2. until ported.

Figure 13 demonstrates that this workflow works for 5 real-world programs,
and quantifies the exact changes needed.
As reviews noted, we failed to enumerate the changes for dj&mo (fixed in final version),
but we *did* succesfully port them (see MD column).

For the type checker mini.occ, we infer 3 *mutually-recursive types* (representations for
types, propositions, and expressions) named T, P, and E, with 14 total cases (5, 5, 4, respectively).
Names are (always) derived from local information (L242-252) and entirely depend on the squashing
algorithm's effectiveness -- here each uses a unique dispatch key :T, :P, and :E.

The missing data will show how the workflow constructively guides the user through the entire
process of porting an untyped program using recursive plain-data, without burdening the
user with complex decisions (unlike our related work on the same problem, described next).




RELATED WORK



Section 1 will be amended to emphasise the drastically different experiences of applying our workflow
to porting a type-erased Figure 1 starting from

1) Figure 2 (TypeWiz), and
2) Figure 3 (Our tool).

With 1), applications of tree height >2 will throw an error, so
the programmer must reverse engineer the recursive definition of Tree (L106-108)
from the flat annotation (which grows linearly with test coverage---the height=2 TypeWiz
annotation was the smallest we could fit in the paper!).

With 2), a recursive type already exists, and so no lengthy diagnosis is needed.

Starting instead with Figure 4, we introduce :node3, which may or may not be shared between
nodes and nodes' (like B's 'staged' AST question).
Our algorithm decides they are related (via squashGlobal).
If they are not shared, the Op type can easily be remixed/copied and a combination of manual search+replace
for occurrences and attempting to check with TC can guide to the correct
annotation.
One way our tool can reduce such unwanted sharing is by eliding squashGlobal (which only squashes
immediately nested types via squashLocal).
Then, a distinct Op' would be automatically inferred only for nodes'.
