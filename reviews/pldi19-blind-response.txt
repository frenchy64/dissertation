We thank the reviewers for their time and thorough reviews. Several
reviewers provide helpful suggestions for improvements to the
technical presentation; we will adopt these in a revised version.

## Evaluation

The most significant questions raised by the reviewers concern the
empirical evaluation of our tool. To understand this evaluation, it is
imperative to consider the _workflow_ our tool is a part of (we will
emphasize this more in the paper).

That workflow is:
1. Automatically generate an initial set of annotations.

2. Type check the program with Typed Clojure (incorrectly annotated
   programs run as normal Clojure programs)

3. Fix static typing errors by making (hopefully minor) changes.

4. Repeat steps 2&3 until the program type checks.

Of course, it would be better to automatically generate types that
work immediately, but this is impossible. Full static type inference
(as used in many prior systems) is undecidable for the Typed Clojure
type system, and similarly for other optional type systems. Dynamic
inference relies on both usually-incomplete test suites and the
ability to generalize from them. Further, most programs ported with
this process are ill-typed for at least minor reasons, even if
every annotation was generated automatically. Our workflow is thus the
only plausible approach.

Our evaluation shows that following this workflow results in a
tool-assisted recipe for porting untyped Clojure programs.

Experiment 1 demonstrates that initial annotations are navigable (Step 1).

Experiment 2 tests whether our porting workflow is effective starting from types
generated following our methodology (Steps 2-4).

Experiment 3 raises confidence that initial annotations are meaningfully
underprecise by enforcing them as contracts, given that emitting *sound*
recursive types via a simple dynamic analysis is not plausible (Step 1).

The key Experiment 2 evaluates the porting workflow not in terms of
number of changes, but the *kinds* of changes needed---simple changes
are significantly preferred.

Figure 13 shows the porting workflow for 5 real-world programs
consisted of only straightforward changes.  As noted, we omitted the
changes for dj&mo (fixed in final version), but we *did* successfully
port them (see MD column).

For mini.occ (a type checker), we infer 3 *mutually-recursive types*
for types, propositions, and expressions, with 14 total cases.  Names
are (always) derived from local information (L242-252) and entirely
depend on the squashing algorithm's effectiveness -- they end up named
`T`, `P`, and `E` because each uses a unique dispatch key `:T`, `:P`,
and `:E`.

While porting the entire 10,000+ LOC of the ClojureScript compiler was not
feasible, our experiment on the cljs.compiler file shows promising results for 
using the methodology and tool with large-scale, complex Clojure programs.
Anecdotally, the tool discovers the key types expected for a
compiler (Figure 5), however the porting effort would still be very
large, although hopefully following the form of mini.occ.


## Related Work

Several reviewers mention additional related work, as well as
requesting more detail on our relationship to existing systems such as
TypeWiz.

#### TypeWiz

Our ability to "Squash the work!" of porting real-world programs
is clear after using TypeWiz to port our tiny opening example (Figure 1).

The programmer must (L134-135) reverse engineer the overprecise annotation (Figure 2).
Extending coverage slightly to height=3 balloons the annotation size linearly (L150).
Now, the porting process is unreasonable even for our toy example:

  function nodes(t: {left: {left: {op: string, val: number},
                            op: string,
                            right: {op: string, val: number}},
                     op: string,
                     right: {left: {op: string, val: number},
                             op: string, 
                             right: {op: string, val: number}}}
                   |{left: {op: string, val: number},
                     op: string,
                     right: {op: string, val: number}}
                   |{op: string, val: number}) ...

Our approach's global squashing further distinguishes our approach.
Figure 4 introduces :node3, which may or may not be shared between
functions nodes and nodes'. squashGlobal's aggressive merging
decides they are related anyway because of the shared :op key.

To our knowledge, all other automatic annotation systems treat plain
data as trivially as TypeWiz (eg [4,7,10,12,15,20]).  Without
the special effort of recovering recursive types, there is no choice
but to either throw away valuable information (eg Pytype) or
suffer from enormous types (TypeWiz).

The DB schema inference papers are helpful, and we will discuss
them. Note that Baazizi et al recursively merge types, as we do, but
do not generate recursive types, the key novelty in our work. Bex et
al do generate recursive schemas, but have the benefit of nominal tag
names, similar to class-structured data in programming
languages. Their paper rules out schemas that would describe idiomatic
Clojure use of maps.

Review B also lists a wide variety of related work from the optional
and gradual typing literature. This work primarily focuses on static
typing and verification as well as runtime monitoring of types, which
are not closely related to our work (eg Dimoulas et al, Nguyen's work
with Van Horn et al, Furr et al, Siek & Tobin-Hochstadt). Our lazy
tracking is inspired by contract checking a la Findler & Felleisen,
and thus is related to Guo et al, which we will cite. While our
inference procedure always produces an answer, it does not insert
dynamic checks as in soft typing or quasi-static typing. We agree with
with Rastogi et al that the porting process is iterative, however their
inference optimizes programs and ours communicates suggested annotations
to programmers.
