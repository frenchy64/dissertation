We thank the reviewers for their time and thorough reviews.

EVALUATION


Most reviewers seemed to enjoy the premise of our paper, but had significant reservations about our evaluation.
In reading the reviews, it is clear that we failed to convey the *purpose* of our evaluation.

Together with our methodology (Section 2), we present a simple porting *workflow* for programmers:

1. Automate initial annotations
2. Type check the program with Typed Clojure (TC)
   (incorrectly annotated TC programs run as normal Clojure programs)
3. Respond to static typing errors by scanning the program/annotations and making minor changes.
4. Go to 2. until ported.

Our evaluation shows that combining this workflow with our methodology
results in a semi-automated recipe for porting untyped Clojure programs.

Experiment 1 ensures initial annotations are navigatable (Step 1).

Experiment 2 (E2) tests whether our porting workflow is effective starting from types
generated following our methodology. (Step 2-4)

Experiment 3 raises confidence that generated types are meaningfully underprecise, given that emitting
*sound* recursive types via a simple dynamic analysis is not plausible. (Step 1)

The key experiment E2 evaluates the porting workflow not in terms of number of changes (lower=>better),
but instead the *kinds* of changes needed (simpler=>better).

Figure 13 shows the porting workflow for 5 real-world programs consisted of only straightforward changes.
As reviews noted, we failed to enumerate the changes for dj&mo (fixed in final version), but we *did* succesfully port them (see MD column).

For mini.occ (a type checker), we infer 3 *mutually-recursive types* for types T, propositions P, and expressions E, with 14 total cases.
Names are (always) derived from local information (L242-252) and entirely depend on the squashing algorithm's effectiveness --
they are so named here because each uses a unique dispatch key :T, :P, and :E.

The missing data/prose will show how the workflow constructively guides the user through the entire
process of porting an untyped program using recursive plain-data, without burdening the
user with complex decisions, like whether a type is recursive (unlike our related work, below).

The cljs.compiler shows promising results for using the methodology and tool with large-scale,
complex Clojure programs. Anecdotally, the tool discovers the key types expected for a compiler (Figure 5),
however the porting effort would still be very large and perhaps mostly simulated by porting the
similarly structured mini.occ.




RELATED WORK



Compare Figure 13's modest changes to the difficultly of applying the porting workflow to Figure 1 starting with TypeWiz (Figure 2).

The programmer must immediately reverse engineer the overprecise type from the flat annotation.
This type grows linearly with test coverage---tree height=3 better demonstrates the unreasonable task this presents the user:

  function nodes(t: {left: {left: {op: string, val: number},
                            op: string,
                            right: {op: string, val: number}},
                     op: string,
                     right: {left: {op: string, val: number},
                             op: string, 
                             right: {op: string, val: number}}}
                   |{left: {op: string, val: number},
                     op: string,
                     right: {op: string, val: number}}
                   |{op: string, val: number}) ...

Our approach's global squashing further distinguishes our approach.
Figure 4 introduces :node3, which may or may not be shared between functions nodes and nodes' .
squashGlobal's aggressive merging decides they are related anyway because of the shared :op key.

If they are not actually shared, the (recognizable) Op type can easily be remixed/copied
and a combination of manual search+replace for occurrences and attempting to check with TC can guide to the correct annotation. 
`squashGlobal` can be skipped by the tool to reduce such unwanted sharing across functions.
A distinct (recursive) Op' would be automatically inferred only for nodes'. (RE: B's ANF question)

To our knowledge, all other automatic annotation systems treat plain data as trivially as TypeWiz (especially [4,7,10,12,15,20]).
Without the special effort of recovering recursive types,
there is no choice but to either throw away valuable information like Pytype L1289
(our tool tries to only throws away superfluous information like L1065)
or suffer from enormous types (TypeWiz).



TECHNICAL PRESENTATION

We will:

- add declarative specifications to non-trivial metafunctions
- clarify missing syntax cases
- fix L576
