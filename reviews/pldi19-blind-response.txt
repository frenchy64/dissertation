We thank the reviewers for their time and thorough reviews.

EVALUATION

We have failed to convey the *purpose* of our evaluation to the reader.

We replace Contribution #1 (L197) with:

 "We present a new *methodology* for building tools to automatically
  annotate plain-data-driven untyped programs, and a corresponding
  straightforward *workflow* for the programmer to complete the porting process."

Our evaluation tests whether our *workflow* is effective starting from types
generated following our *methodology* (Section 2).

Our workflow:

1. Run our tool, generating initial annotations
2. Type check the program with Typed Clojure (TC)
   (incorrectly annotated TC programs run as normal Clojure programs)
3. Respond to static typing errors by scanning the program and making minor changes.
4. Go to 2. until ported.


Figure 13 demonstrates that this workflow works for 5 real-world programs,
and quantifies the exact changes needed.
As reviews noted, we failed to enumerate the changes for dj&mo (fixed in final version),
but we *did* succesfully port them (see MD column).

For the type checker mini.occ, we infer 3 *mutually-recursive types* (representations for
types, propositions, and expressions) named T, P, and E, with 14 total cases (5, 5, 4, respectively).
Each uses different dispatch keys: :T, :P, and :E.

We also infer
  (defalias NameTypeMap '{:name Sym, :type T})
for function parameters types.

Manual amendment using the *workflow* consisted of:
- adding cases
  - 2 to E
  - 3 to T
- amend one overprecise T case 
  - unit tests only used 1-argument function types in T,
    so change singleton collection '[NameTypeMap] => (Vec NameTypeMap)
- change 5 recognizably overprecise function annotations (eg. (Vec Nothing) => (Vec T))
- insert 8 casts for TC
- annotate unexercised local function with NameTypeMap
- fix 1 overprecise local annotation
- other: deleted trivial type annotations for unit tests embedded in file,
         disable type checking unit tests

This shows how the workflow can constructively guide a user through the entire
process of porting an untyped program using plain-data.




RELATED WORK



Section 1 will be amended to emphasise the drastically different experiences of applying our workflow
to porting a type-erased Figure 1 starting from

1) Figure 2 (TypeWiz), and
2) Figure 3 (Our tool).

With 1), applications of tree height >2 will throw an error, so
the programmer must reverse engineer the recursive definition of Tree (L106-108)
from the flat annotation (which grows linearly with test coverage---the height=2 TypeWiz
annotation was the smallest we could fit in the paper!).

With 2), a recursive type already exists, and so no lengthy diagnosis is needed.

Starting instead with Figure 4, we introduce :node3, which may or may not be shared between
nodes and nodes' (like B's 'staged' AST question).
If they are not shared, the Op type can easily be remixed/copied and a combination of manual search+replace
for occurrences and attempting to check with TC can guide to the correct
annotation.
One way our tool reduces such unwanted sharing is by eliding squashGlobal.
