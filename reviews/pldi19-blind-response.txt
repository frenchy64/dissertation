We thank the reviewers for their time and thorough reviews.

## Evaluation

The most significant questions raised by the reviewers concern the
empirical evaluation of our tool. To understand this evaluation, it is
imperative to consider the _workflow_ our tool is a part of (we will
emphasize this more in the paper).

That workflow is:
1. Automatically generate an initial set of annotations.

2. Type check the program with Typed Clojure (incorrectly annotated
   programs run as normal Clojure programs)

3. Fix static typing errors by making (hopefully minor) changes.

4. Repeat steps 2&3 until the program type checks.

Of course, it would be better to automatically generate types that
work immediately, but this is impossible. Full static type inference
(as used in many prior systems) is undecideable for the Typed Clojure
type system, and similarly for other optional type systems. Dynamic
inference relies on both usually-incomplete test suites and the
ability to generalize from them. Further, most programs that being
this porting process are ill-typed for at least minor reasons, even if
every annotation was generated automatically. Our workflow is thus the
only plausible approach.

Our evaluation shows that following this workflow results in a
tool-assisted recipe for porting untyped Clojure programs.

Experiment 1 demonstrates that initial annotations are navigatable (Step 1)

Experiment 2 tests whether our porting workflow is effective starting from types
generated following our methodology (Steps 2-4).

Experiment 3 raises confidence that generated types are meaningfully
underprecise, given that emitting *sound* recursive types via a simple
dynamic analysis is not plausible. (Step 1)

The key Experiment 2 evaluates the porting workflow not in terms of
number of changes, but the *kinds* of changes needed---simple changes
are significantly preferred.

Figure 13 shows the porting workflow for 5 real-world programs
consisted of only straightforward changes.  As noted, we omitted the
changes for dj&mo (fixed in final version), but we *did* succesfully
port them (see MD column).

For mini.occ (a type checker), we infer 3 *mutually-recursive types*
for types, propositions, and expressions, with 14 total cases.  Names
are (always) derived from local information (L242-252) and entirely
depend on the squashing algorithm's effectiveness -- they end up named
`T`, `P`, and `E` because each uses a unique dispatch key `:T`, `:P`,
and `:E`.

While porting the entire 10,000+ LOC of the cljs.compiler was not
feasible, our experiment on it shows promising results for using the
methodology and tool with large-scale, complex Clojure
programs. Anecdotally, the tool discovers the key types expected for a
compiler (Figure 5), however the porting effort would still be very
large, although hopefully following the form of mini.occ.


RELATED WORK



Compare Figure 13's modest changes to the difficultly of applying the porting workflow to Figure 1 starting with TypeWiz (Figure 2).

The programmer must immediately reverse engineer the overprecise type from the flat annotation.
This type grows linearly with test coverage---tree height=3 better demonstrates the unreasonable task this presents the user:

  function nodes(t: {left: {left: {op: string, val: number},
                            op: string,
                            right: {op: string, val: number}},
                     op: string,
                     right: {left: {op: string, val: number},
                             op: string, 
                             right: {op: string, val: number}}}
                   |{left: {op: string, val: number},
                     op: string,
                     right: {op: string, val: number}}
                   |{op: string, val: number}) ...

Our approach's global squashing further distinguishes our approach.
Figure 4 introduces :node3, which may or may not be shared between functions nodes and nodes' .
squashGlobal's aggressive merging decides they are related anyway because of the shared :op key.

If they are not actually shared, the (recognizable) Op type can easily be remixed/copied
and a combination of manual search+replace for occurrences and attempting to check with TC can guide to the correct annotation. 
`squashGlobal` can be skipped by the tool to reduce such unwanted sharing across functions.
A distinct (recursive) Op' would be automatically inferred only for nodes'. (RE: B's ANF question)

To our knowledge, all other automatic annotation systems treat plain data as trivially as TypeWiz (especially [4,7,10,12,15,20]).
Without the special effort of recovering recursive types,
there is no choice but to either throw away valuable information like Pytype L1289
(our tool tries to only throws away superfluous information like L1065)
or suffer from enormous types (TypeWiz).



TECHNICAL PRESENTATION

We will:

- add declarative specifications to non-trivial metafunctions
- clarify missing syntax cases
- fix L576
