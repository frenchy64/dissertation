We thank the reviewers for their time and thorough reviews.

The final paper will include B's Related Works and these clarifications/fixes:

> Naming unexplained/unevaluated?

Naming is a simple local analysis hinted in L242-252.
So, its effectiveness entirely depends on 'squashing' to bring together related names.
We evaluate, instead, the latter's ability to merge related concepts,
which makes creating "recognizable names" (L232) easier.

We assume that a sufficiently squashed type contains enough local information (e.g., key names)
to assign recognizable names.
L249 discusses a case where this hypothesis fails.

> Non-contribution #1?

We replace L197:
  "We outline a new methodology for automatically annotating untyped programs
   that primarily use plain data (Section 2)."

> Writing good tests easier than annotating code?

Clojure's "culture of unit testing" [L22] allows us to skip this question,
and take advantage of existing tests to assist porting untyped code.

> Runtime technique?

Our "simple dynamic analysis gives a nice baseline solution" (B)
that may be combined with other static, or statistical approaches.

> Typed Clojure (TC)?

The literature [5] reports that TC's lack of library annotations hinders its usability
for real programmers. The Clojure 2018 survey's asks:

  "What has been most frustrating or has prevented you from using Clojure more than you do now?".

11.7% of 1,851 chose:

  "No static typing".

This suggests TC's usability issues are preventing adoption of both itself and Clojure,
which motivates us to tailor our tool to improve TC to fill a need of real programmers.

> (A) Experiment 3 (Sec 5.3) No soundness guarantee? Generative testing caveat?

We amend L1225:
  "Some >generated< function specs..."
because our tool *generates* the function spec.

The caveat: spec's generative testing semantics for HOF weakens our "passes unit tests" result
over standard HOF contract checking (wrapping), because it is more permissive.

> (B) Non-recursive, ad-hoc data structures?

groupSimilarReq (Figure 10) merges non-recursive maps with similar required keys,
and our tool assigns a type alias name based on its keys.
This way, types are not copied throughout the program.
The downside is that types might be too broad (for example,
the same entry might be optional in one function, but required in another)
but TC will throw a type error when it is checked in that case.

See ColumnLineContextMap in Figure 5 for a real example.

We don't perform this grouping for homogeneous data-structures, but
their members can be named (eg. L1040, EnergySectorMap is named, but not
Vec). This matches our intuition of how helper functions are written in
Clojure (usually processes a single item, and then combined with map/filter).

> (B) How to handle excessive merging in subtle cases? (eg. 'staged' ASTs)

Say we have two types T{1,2}, and functions f{1,2} process T1 and T{1,2}, respectively.

If T_n share the same dispatch key, we will likely infer:

(defalias T (U T1 T2))
(ann f1 [T :-> T])
(ann f2 [T :-> T])

But we actually want:

(defalias T  T1)
(defalias T' (U T T2))
(ann f1 [T :-> T])
(ann f2 [T' :-> T'])

The current algorithm encourages the following manual fix:

First, the programmer finds T and uses it to create T'.
Since the tool chooses meaningful names (L232) and assumes
some familiarity with what the data represents (L239), it helps quickly
identify the underspecified AST type.

Then, a manual search for T reveals the places where T' should be used (like f2).
If it is unclear which T{,'} should be used, the type system could be used
to experiment whether adding/removing cases would throw warnings or type errors.

If hypotheses L345-350 do not hold, the algorithm can be tuned to
squash per-function (or further granuality) by changing the driver (L353)
to isolate runtime results after "collect", and running "infer" multiple times
on the smaller groups.

Alternatively, removing the squashGlobal pass would have similar results, which
prevents recursive types from merging between f{1,2} (our tool supports this).

> Fig 13 is incomplete/confusing. Did you port `mini.occ` or `data.json`?

We will make this clear, but the MD column (Fig 13) shows we *did* port them.

The final paper will fill-in Fig 13 for mini.occ and data.json.

Only cljs.compiler was not ported due to the large number of local annotations
needed, but is a crucial stress test of 'squashing' (L993-L1000, 14/36 recursive Op
cases inferred using only 39 assertions).

> (B) Successfully port programs with recursive types?

For mini.occ, we infer 3 mutually recursive data structures (representations for
types, propositions, and expressions) named T, P, and E, with 14 total cases (5, 5, 4, respectively).
Each uses different dispatch keys: :T, :P, and :E.

Manual amendment (MD=46/24, Fig 13):
- add: 2 cases to E, 3 to T
- amend: one overprecise T case (no. function arguments can be non-1)
- change: 5 recognizably overprecise function annotations (eg. (Vec Nothing) => (Vec T))
- casts: inserted 8 casts for TC
- other: deleted trivial type annotations for unit tests embedded in file

Adding various local annotations to appease the type checker.

> (B) The title is misleading: you're not 'collapsing' much work.

Our evaluation supports our title after a few small fixes.
The Git line diff (MD, Fig 13) is insufficient, which we try to supplement
with all the columns to right of it.
Our experience shows the cognitive overhead saved is significant.

For example, for mini.occ, the programmer was saved from identifying,
naming, or even specifying the relationship between 3 mutually recursive
heterogeneous data structures with over a dozen cases. 
Their job, instead, becomes finding "recognizable names" for minor fixes and 
following the instructions of TC.

Furthermore, in our experience (like above), changes are often obvious by sight (eg. overprecise argument, the "O" metric)
or indicated by the type checker (eg. casts, the "C" metric).

> (B) Emit more interesting contracts?

Yes, and this information could be collected by our runtime analysis, and could be
added as the need/demand arises. Memory during collection
and processing time for extra samples are the main concerns.

> (D) What's conceptually new compared to [4,20,18]?

[4] Type (class) names provided by programmers, then types are naturally recursive via class invariants.
    Neither is true in our setting, yet we create well-named recursive types.

> (D) Why not start the evaluation with a corpus of type-annotated code, which would allow to remove and infer again the type annotations? 

TC users are discouraged by annotating both their own code and libraries [5]. We present
the messy experience of automatically annotating such real-world cases because:

- Using real code allows us to fairly test our hypotheses about Clojure idioms
- We believe pre-annotated would be misleadingly easier to port than always-untyped because
  TC enforces stricter discipline. We chose the more challenging representative benchmarks of real, always-untyped code.

Our results seem weaker (merely messier, in our opinion) from avoiding misleading results.
