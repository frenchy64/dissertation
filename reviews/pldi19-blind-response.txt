We thank the reviewers for their time and thorough reviews.

## Evaluation

The most significant questions raised by the reviewers concern the
empirical evaluation of our tool. To understand this evaluation, it is
imperative to consider the _workflow_ our tool is a part of (we will
emphasize this more in the paper).

That workflow is:
1. Automatically generate an initial set of annotations.

2. Type check the program with Typed Clojure (incorrectly annotated
   programs run as normal Clojure programs)

3. Fix static typing errors by making (hopefully minor) changes.

4. Repeat steps 2&3 until the program type checks.

Of course, it would be better to automatically generate types that
work immediately, but this is impossible. Full static type inference
(as used in many prior systems) is undecideable for the Typed Clojure
type system, and similarly for other optional type systems. Dynamic
inference relies on both usually-incomplete test suites and the
ability to generalize from them. Further, most programs that being
this porting process are ill-typed for at least minor reasons, even if
every annotation was generated automatically. Our workflow is thus the
only plausible approach.

Our evaluation shows that following this workflow results in a
tool-assisted recipe for porting untyped Clojure programs.

Experiment 1 demonstrates that initial annotations are navigatable (Step 1)

Experiment 2 tests whether our porting workflow is effective starting from types
generated following our methodology (Steps 2-4).

Experiment 3 raises confidence that generated types are meaningfully
underprecise, given that emitting *sound* recursive types via a simple
dynamic analysis is not plausible. (Step 1)

The key Experiment 2 evaluates the porting workflow not in terms of
number of changes, but the *kinds* of changes needed---simple changes
are significantly preferred.

Figure 13 shows the porting workflow for 5 real-world programs
consisted of only straightforward changes.  As noted, we omitted the
changes for dj&mo (fixed in final version), but we *did* succesfully
port them (see MD column).

For mini.occ, we infer 3 *mutually-recursive types* for types,
propositions, and expressions, with 14 total cases.  Names are
(always) derived from local information (L242-252) and entirely depend
on the squashing algorithm's effectiveness -- they end up named `T`,
`P`, and `E` because each uses a unique dispatch key `:T`, `:P`, and
`:E`.

While porting the entire 10,000+ LOC of the cljs.compiler was not
feasible, our experiment on it shows promising results for using the
methodology and tool with large-scale, complex Clojure
programs. Anecdotally, the tool discovers the key types expected for a
compiler (Figure 5), however the porting effort would still be very
large, although hopefully following the form of mini.occ.




RELATED WORK



Consider the drastically different experiences of porting Figure 1 using our
workflow, starting with 1) or 2).


1) Figure 2 (TypeWiz):

  function nodes(t:{left: {op: string, val: number},
                    op: string,
                    right: {op: string, val: number}}
                  |{op: string, val: number}) ...

2) Figure 3 (Our tool):

  (defalias Op
    (U '{:op ':node, :left Op, :right Op}
       '{:op ':leaf, :val Int}))
  (ann nodes [Op -> Int])

With 1), applications of tree height >2 will type error, so
the programmer must reverse engineer the recursive definition of Tree (L106-108)
from the flat annotation. This type grows linearly with test coverage---the height=2 TypeWiz
annotation was the smallest we could fit in the paper! Height=3 better demonstrates
the unreasonable task this presents the user:

  function nodes(t: {left: {left: {op: string, val: number},
                            op: string, right: {op: string, val: number}},
                     op: string,
                     right: {left: {op: string, val: number},
                             op: string, 
                             right: {op: string, val: number}}}
                   |{left: {op: string, val: number},
                     op: string,
                     right: {op: string, val: number}}
                   |{op: string, val: number}) ...

With 2), a recursive type already exists, and so no lengthy diagnosis is needed. In fact,
it type checks all valid uses of 'nodes'.

To make things harder, Figure 4 we introduce :node3, which may or may not be shared between
nodes and nodes' (related to B's 'staged' AST question).
Our algorithm decides they are related anyway (via squashGlobal) because of the shared :op key.

If they are not actually shared, the (recognizable) Op type can easily be remixed/copied
and a combination of manual search+replace for occurrences and attempting to check with TC
can guide to the correct annotation.

One way our tool can reduce such unwanted sharing is by eliding squashGlobal (which only squashes
immediately nested types via squashLocal).
Then, a distinct Op' would be automatically inferred only for nodes'.

TypeWiz and similar tools excel at using existing class names to
create recursive types, because recursive types are created automatically when an instance
of itself is used in a field or method (L151-152).

Our key novelty is recovering this recursive structure *without* the help of existing names.
To our knowledge, all other automatic annotation systems treat plain data as trivially as TypeWiz (especially [4,7,10,12,15,20]).
Without the special effort of recovering recursive types,
there is no choice but to either throw away valuable information (Pytype L1289), or suffer from enormous types (TypeWiz).



TECHNICAL PRESENTATION

We will:

- add declarative specifications to non-trivial metafunctions
- clarify missing syntax cases
- fix L576
