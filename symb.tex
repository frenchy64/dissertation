\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{symb-common}
\usepackage{pdflscape}
\usepackage{tikz}
\usetikzlibrary{positioning,calc}

%\title{Symbolic execution in Typed Clojure}
%\title{Local Type Inference for Optional Type Systems}
%\title{Local Type Inference for Anonymous Functions in Higher-Order contexts}
%\title{Local Type Inference for Higher-Order usages of Anonymous Functions}
%\title{Delayed Local Type Inference with Free Theorems}
%\title{Lazy Local Type Inference with Free Theorems}
%\title{Free Theorems for Local Type Inference}
\title{Directed Local Type Inference for Typed Clojure}

\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
Many type systems using local type inference do not reuse type information aggressively
enough to elide annotations for local functions.
Common solutions to checking an unannotated function is to try and
immediately check it with the top type, or a dynamic type, or simply
require annotations.

  We present a variant of System $F_{<:}$ that delays type checking until
the free theorems of a polymorphic type tells us there is enough information
available that further delay would threaten type-soundness.

We particularly target type systems for untyped languages, who require
top-level annotations, but allow annotations to be elided from local functions.
A key hypothesis we rely on is that re-checking the body of a local function
is resonable and cheap.
\end{abstract}

%\input{symb-proof-system}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}} \alt
                         \ltiappinst{\ltiF{}}{\overline{\ltitvar{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltivar{} \alt
                         \ltiTop{} \alt
                         \ltiBot{} \alt
                         \ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}} \alt
                         \ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}
                      &\mbox{Types} \\
\end{array}
$$
\caption{Internal Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(I-Var)]
    {}
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltivar{}}
                  {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [(I-Abs)]
    { 
    \ltitjudgement{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 }

    \infer [(I-App)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSp{}}
                  \\
    \ltisubtype{\ltiSp{}}{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                  {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
    }

    \infer [($\text{I-App}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiBot}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiR{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiT{}}}{\ltiE{}}}
                  {\ltiBot}
    }

    \infer [(I-Sel)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [($\text{I-Sel}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [(I-Rec)]
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \\\\

    \infer [(S-Bot)]
    {}
    {
    \ltisubtype{\ltiBot}{\ltiT{}}
    }

    \infer [(S-Top)]
    {}
    {
    \ltisubtype{\ltiT{}}{\ltiTop}
    }

    \infer [(S-Var)]
    {}
    {
    \ltisubtype{\ltitvar{}}{\ltitvar{}}
    }

    \infer [(S-Rec)]
    {
    \ltisubtype{\ltiT{1}}
               {\ltiTp{1}}
                 \\
                 ...
                 \\
    \ltisubtype{\ltiT{n}}
               {\ltiTp{n}}
    }
    {
    \ltisubtype{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}},
                        \hastype{\ltivar{n+1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{m}}}}
               {\ltiRec{\hastype{\ltivar{1}}{\ltiTp{1}}, ..., \hastype{\ltivar{n}}{\ltiTp{n}}}}
    }

    \infer [(S-Fun)]
    {
    \ltisubtype{\ltiT{1}}{\ltiTp{1}}
    \\
    \ltisubtype{\ltiT{2}}{\ltiTp{2}}
    }
    {
    \ltisubtype{\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
  \end{mathpar}
  \caption{Type system for internal language:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(CG-Top)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty{}}
    }

    \infer [(CG-Bot)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty{}}
    }

    \infer [(CG-Upper)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [(CG-Lower)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [(CG-Refl)]
    {
                     {\ltitvarp{}}
                     \not\in
                     {\overline{\ltitvar{}}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [(CG-Fun)]
    {
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }
  \end{mathpar}
  \caption{Constraint generation system
                 $\ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}$
                 where $\ltiV{} \cap {\overline{\ltitvar{}}} = \varnothing$.
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufun{\ltivar{}}{\ltiE{}} \alt
                         \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Synthesized types} \\
  \ltiChk{\ltiT{}}, \ltiChk{\ltiS{}}, \ltiChk{\ltiR{}} &::=& 
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Inherited types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                                    \\&\alt&
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}
                         \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                      &\mbox{General types} \\
  \ltiC{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiT{}}, ...,
                          \ltiCEntry{\ltiT{}}{\ltitvar{n}}{\ltiT{}}}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{External Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(W-var)]
    {}
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}{\ltivar{}}
                 {\ltimatchsuper{\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}{\ltiP{}}}
    }

    \infer [($\text{W-abs}_{tp,?}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-abs}_{tp}$)]
    {
    \ltijudgement{\ltiPp{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                                {\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}}
    }
    
    \infer [($\text{W-abs}_{tp,\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiTop}
    }
    
    \infer [(W-abs)]
    {
    \ltijudgement{\ltiP}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-app}_{tp}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{tp,\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [(W-app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }

    \infer [(W-sel)]
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{}}{\ltiP{}}}}{\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiRec{\hastype{\ltivar{}}{\ltiT{}}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltisel{\ltiF{}}{\ltivar{}}}
                 {\ltiT{}}
    }

    \infer [($\text{W-rec}_{\ltiWild{}}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [($\text{W-rec}_{\ltiTop}$)]
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [(W-rec)]
    {
    (
    \ltijudgement{\ltiP{1}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiP{m}}
                 {\ltiEnv{}}
                 {\ltiF{m}}
                 {\ltiT{m}}
                 )
    \\
    (
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{m+1}}
                 {\ltiT{m+1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
                 )
    }
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{1}}{\ltiP{1}}, ..., \hastype{\ltivar{m}}{\ltiP{m}}}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{m}}{\ltiT{m}}}}
    }
  \end{mathpar}
  \caption{Colored Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{Synthesized types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{General types} \\
  \ltiD{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{1}}{\ltitvar{1}}{\ltiTp{1}}, ...,
                          \ltiCEntry{\ltiT{n}}{\ltitvar{n}}{\ltiTp{n}},
                          \ltiDEntry{\ltiClosure{\ltiEnv{1}}{\ltiufun{\ltivar{1}}{\ltiE{1}}}}{\ltiT{}}
                          , ...,
                          \ltiDEntry{\ltiClosure{\ltiEnv{m}}{\ltiufun{\ltivar{m}}{\ltiE{m}}}}{\ltiT{m}}
}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{Extension Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
  \end{mathpar}
  \caption{Extension Type system:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(S-Closure)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
    {
    \ltisubtype{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }

    \infer [(CG-Closure)]
    {
    \ltidemote{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiS{1}}
    \\\\
    \ltijudgement{\ltiArrow{\ltiS{1}}{\overline{\ltitvarp{}}}
                           {\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiT{2}}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiS{1}}{\overline{\ltitvarp{}}}{\ltiS{2}}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup {\overline{\ltitvarp{}}}}
                     {\overline{\ltitvar{}}}{\ltiS{2}}{\ltiT{2}}
                     {\ltiC{}}
    \\\\
                     \ltiCDep{\ltitv{\ltiT{1}} \cap \overline{\ltitvar{}}}
                              {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}
                              \mathbin{<:}
                               \ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                              {\ltiC{}}
                              =
                              {\ltiCp{}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                     {\ltiCp{}}
    }
    \\
    \infer [(CG-Fun2)]
    {
    \ltitv{\ltiT{1}} \cap \overline{\ltitvar{}} = \overline{\ltitvarpp{}}
    \\
    \ltidemote{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiS{1}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarp{}}}
                     {\overline{\ltitvarpp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarp{}}}
                     {\overline{\ltitvar{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvarp{}} \cap (\ltiV{} \cup \overline{\ltitvar{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }

    \infer [($\text{W-abs}_{\ltiWild{}\rightarrow}$)]
    {
    \ltijudgement{\ltiPp{}}
                 {\ltiEnv{},\overline{\ltitvar{}},
                  \hastype{\ltivar{}}{\ltimatchsuper{\ltiBot}{{\ltiP{}}}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [($\text{W-abs}_{\ltiTop}$)]
    {}
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiTop}
    }

    \infer [($\text{W-abs}_{\ltiWild{}}$)]
    {}
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [(W-app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }
    \\\\

    \infer [(CO-More)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \overline{\ltitvarp{}}
     \\
     \overline{\ltitvarp{}} \not= \varnothing
     \\\\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
     \\
     \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }

    \infer [(CO-Done)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \varnothing
     \\
     \overline{\ltitvar{}} \not= \varnothing
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
  \end{mathpar}

  $$
  \begin{array}{lllr}
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltitvar{1}} &=&  \{\ltitvar{1}\} 
         & \text{if } \ltitvar{1} \in \overline{\ltitvar{}} \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
      &=& (\bigcup \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{1}}
            ...
            \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{n}})
      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiArrow{\ltiT{}}{\overline{\ltitvarp{}}}{\ltiS{}}}
      &=& \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}}
         & \text{if } \ltitv{\ltiT{}} \cap \overline{\ltitvar{}} = \varnothing \\

      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} &=&  \varnothing & \text{otherwise}\\
  \end{array}
  $$
  \caption{Delayed checking Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\newpage
\begin{landscape}
\begin{figure}
  \small
  \begin{mathpar}
  \inferrule* [right=CG-LeftPoly]
  {
   \inferrule* [right=CG-Fn]
   { 
     {\inferrule*[right=CG-Delay,vdots=1.5em,leftskip=2em,rightskip=2em
                  ]
      { 
        \ltidemote{a}{a,b}{\ltiBot}
        \\\\
        \ltigenconstraint{r,a,b}
                         {x}
                         {\ltiBot}
                         {x}
                         {\ltiCSet{\ltiCEntry{\ltiBot}{x}{\ltiTop}}}
        \\\\
        \ltiSubst{\ltiCSet{\ltiCEntry{\ltiBot}{x}{\ltiTop}}}
                 {x}
                 {x}
                 =
                 \ltiBot
        \\\\
        \ltigenconstraint{r}
                         {a,b}
                         {\ltiBot}
                         {b}
                         {\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}}
      }
      { \ltigenconstraint{r}
                         {a,b}
                         {\ltiArrow{x}{x}{x}}
                         {\ltiArrow{a}{}{b}}
                         {\textbf{delay}^{a}({\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}})}
                         }
     }
     \\
     {\inferrule*[right=CG-Seq]
      {
       \ltigenconstraint{r}
                        {a,b}
                        {\ltiInt}
                        {a}
                        {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
      }
      {
       \ltigenconstraint{r}
                        {a,b}
                        {\ltiSeqable{\ltiInt}}
                        {\ltiSeqable{a}}
                        {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
                        }
     }
     \\
     {\inferrule*[]
       {}
       {
        \ltigenconstraint{}
                         {r}
                         {\ltiSeqable{b}}
                         {r}
                         {\ltiCSet{\ltiCEntry{\ltiSeqable{b}}{r}{\ltiTop}}}
                        }
     }
   }
   { \ltigenconstraint{r}
                      {a,b}
                      {\ltiArrow{(\ltiArrow{a}{}{b}, \ltiSeqable{a})}
                                {}
                                {\ltiSeqable{b}}}
                      {\ltiArrow{(\ltiArrow{x}{x}{x}, \ltiSeqable{\ltiInt})}
                                {}
                                {r}}
                      {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}},
                       \textbf{delay}^{a}({\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}})}
                      }
  }
  {  \ltigenconstraint{}
                      {r}
                      {\ltiArrow{(\ltiArrow{a}{}{b}, \ltiSeqable{a})}
                                {a, b}
                                {\ltiSeqable{b}}}
                      {\ltiArrow{(\ltiArrow{x}{x}{x}, \ltiSeqable{\ltiInt})}
                                {}
                                {r}}
                      {}
  }

  \end{mathpar}
\caption{Derivation of \texttt{(map identity [1 2 3])}}
\end{figure}

\begin{figure}
  \small
  \begin{mathpar}
   \inferrule* [right=CG-Fn]
   { 
     {\inferrule*[%right=CG-Delay%,
                  vdots=1.5em,leftskip=2em,rightskip=2em
                  ]
      { {\ltigenconstraint{}
                          {a,b}
                          {\ltiBot}
                          {\ltiInt}
                          {\ltiCEmpty{}}
                         }
        \\
        {\ltigenconstraint{}
                          {a,b}
                          {\ltiInt}
                          {\ltiTop}
                          {\ltiCEmpty{}}
                         }
      }
      { \ltigenconstraint{}
                         {a,b}
                         {\ltiArrow{\ltiInt}{}{\ltiInt}}
                         {\ltiArrow{a}{}{b}}
                         {\texttt{delay}_{b}^{a}()}
                         }
     }
     \\
     {\ltigenconstraint{}
                       {a,b}
                       {\ltiInt}
                       {a}
                       {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
     }
   }
   { \ltigenconstraint{}
                      {a,b}
                      {(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}
                      {(\ltiArrow{a}{}{b}, a)}
                      {}
                      }


  \infer [(W-app)]
  {
  \ltijudgement{\ltiWild{}}
               {\ltiEnv{}}
               {\texttt{app}}
               {\ltiArrow{(\ltiArrow{a}{}{b}, a)}{a, b}{b}}
               %{\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
               \\
  \ltijudgement{(\ltiArrow{\ltiWild{}}{}{\ltiWild{}}, \ltiWild{})}
               {\ltiEnv{}}
               {(\texttt{inc}, \texttt{1})}
               {(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}
               %{\ltiSp{}}
               \\\\
  \ltigenconstraint{}{a,b}{(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}{(\ltiArrow{a}{}{b}, a)}{\ltiC{1}}
               \\
  \ltigenconstraint{}{a,b}{b}{\ltimatchsub{\ltiTop}{\ltiWild{}}}{\ltiC{2}}
  }
  {
  \ltijudgement{\ltiWild{}}%{\ltiP{}}
               {\ltiEnv{}}
               {\ltiapp{\texttt{app}}{\texttt{inc}, \texttt{1}}}
               {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{b}{\ltimatchsuper{b}{\ltiWild{}}}}
  }
  \end{mathpar}

  $$
  \begin{array}{l}
    \hastype{\texttt{app}}{\ltiArrow{(\ltiArrow{a}{}{b}, a)}{a, b}{b}}\\
    \hastype{\texttt{inc}}{\ltiArrow{\ltiInt}{}{\ltiInt}}\\
    \hastype{\texttt{1}}{\ltiInt}
  \end{array}
  $$
\caption{Derivation of \texttt{(app inc 1)}
  }
\end{figure}
\end{landscape}

\newpage

\section{Introduction}

We apply the area of constrained types to a type system with Local Type Inference.
All top level functions are type-annotated, and we are left to infer the types of
unannotated anonymous functions and reconstruct the type arguments of polymorphic
applications.

Often, Clojure programmers write anonymous functions that are not recursive, and
are only used once. With that insight, we can start to design a local type inference
algorithm that attempts to infer parameter types for lambdas.

For example, take the following code. We draw an arrow to show how data flows
through this expression.

\begin{lstlisting}[escapeinside={(*@}{@*)}]
(let [f #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*)]
  (f (*@\tikz[overlay,remember picture] \node [] (a) {};@*)1))(*@\tikz[overlay,remember picture] \node [] (d) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
\end{tikzpicture} 

Checking this code, intuitively, is a matter of delaying checking
\clj{f} until it is called, and then using the type of the provided arguments
to check the body of \clj{f}.

In a higher order setting, this becomes slightly more complicated, as
the control flow is not readily apparent.

\begin{lstlisting}
(let [f #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*)]
  (map f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3]))(*@\tikz[overlay,remember picture] \node [] (d) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
\end{tikzpicture} 

Composing two anonymous functions with \clj{comp} and mapping
them over a collection has an even more interesting control flow.

\begin{lstlisting}
(let [f (comp #(dec (*@\tikz[overlay,remember picture] \node [] (d) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (e) {};@*)
              #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*))]
  (map f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3]))(*@\tikz[overlay,remember picture] \node [] (f) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
  \draw[->](Start3.north) to (End3.south);
\end{tikzpicture} 

%\begin{lstlisting}
%(let [f (map #(inc %))]
%  (sequence f [1 2 3]))
%\end{lstlisting}
%

Transducers compose ``left-to-right'', so their control flow is inverted.

\begin{lstlisting}
(let [f (comp (map #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*))
              (map #(dec (*@\tikz[overlay,remember picture] \node [] (d) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (e) {};@*)))]
  (sequence f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3]))(*@\tikz[overlay,remember picture] \node [] (f) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
  \draw[->](Start3.north) to (End3.south);
\end{tikzpicture} 

%\begin{lstlisting}
%(let [f (map #(inc %))]
%  (sequence f [1 2 3]))
%\end{lstlisting}
%

\section{Improved Error Messages}

\section{Related Work}

Xie and Oliveira~\cite{xie2018let} present a type system where
argument type information flows to the function position in applications.
Then, defining `let` as sugar propagates enough information to avoid
a custom rule for `let`.
No information is propagated from functions to applications, so the benefits
of Colored Local Type Inference are negated.

% MLsub
% https://www.cl.cam.ac.uk/~sd601/thesis.pdf
% https://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
%
% Polar type system (Jim)
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8718&rep=rep1&type=pdf

% survey
% Expansion: the Crucial Mechanism for Type Inference with Intersection Types: A Survey and Explanation1
% https://www.sciencedirect.com/science/article/pii/S1571066105050656

% ML_F
% http://gallium.inria.fr/~remy/mlf/mlf-type-inference-long.pdf

% Pottier
% Simplifying Subtyping Constraints: A Theory
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.7032&rep=rep1&type=pdf
% A Framework for Type Inference with Subtyping%
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.2364&rep=rep1&type=pdf

\printbibliography

\end{document}
