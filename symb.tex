\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{symb-common}

\title{Symbolic execution in Typed Clojure}
%\title{Local Type Inference for Optional Type Systems}
%\title{Local Type Inference for Anonymous Functions in Higher-Order contexts}
%\title{Local Type Inference for Higher-Order usages of Anonymous Functions}
%\title{Delayed Local Type Inference with Free Theorems}
%\title{Lazy Local Type Inference with Free Theorems}
%\title{Free Theorems for Local Type Inference}
\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
Many type systems using local type inference do not reuse type information aggressively
enough to elide annotations for local functions.
Common solutions to checking an unannotated function is to try and
immediately check it with the top type, or a dynamic type, or simply
require annotations.

  We present a variant of System $F_{<:}$ that delays type checking until
the free theorems of a polymorphic type tells us there is enough information
available that further delay would threaten type-soundness.

We particularly target type systems for untyped languages, who require
top-level annotations, but allow annotations to be elided from local functions.
A key hypothesis we rely on is that re-checking the body of a local function
is resonable and cheap.
\end{abstract}

%\input{symb-proof-system}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}} \alt
                         \ltiappinst{\ltiF{}}{\overline{\ltitvar{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltivar{} \alt
                         \ltiTop{} \alt
                         \ltiBot{} \alt
                         \ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}} \alt
                         \ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}
                      &\mbox{Types} \\
\end{array}
$$
\caption{Internal Language}
\end{figure}


\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufun{\ltivar{}}{\ltiE{}} \alt
                         \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Synthesized types} \\
  \ltiChk{\ltiT{}}, \ltiChk{\ltiS{}}, \ltiChk{\ltiR{}} &::=& 
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Inherited types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                                    \\&\alt&
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}
                         \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                      &\mbox{General types} \\
\end{array}
$$
\caption{External Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(var)]
    {}
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}{\ltivar{}}
                 {\ltimatchsuper{\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}{\ltiP{}}}
    }

    \infer [($\text{abs}_{tp,?}$)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{abs}_{tp}$)]
    {
    \ltijudgement{\ltiPp{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                                {\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}}
    }
    
    \infer [($\text{abs}_{tp,\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiTop}
    }
    
    \infer [(abs)]
    {
    \ltijudgement{\ltiP}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{app}_{tp}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
                                {\ltiP{}}}
    }

    \infer [($\text{app}_{tp,\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [($\text{app}_{\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [(app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }

    \infer [(sel)]
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{}}{\ltiP{}}}}{\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiRec{\hastype{\ltivar{}}{\ltiT{}}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltisel{\ltiF{}}{\ltivar{}}}
                 {\ltiT{}}
    }

    \infer [($\text{rec}_{\ltiWild}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [($\text{rec}_{\ltiTop}$)]
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [(rec)]
    {
    (
    \ltijudgement{\ltiP{1}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiP{m}}
                 {\ltiEnv{}}
                 {\ltiF{m}}
                 {\ltiT{m}}
                 )
    \\
    (
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{m+1}}
                 {\ltiT{m+1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
                 )
    }
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{1}}{\ltiP{1}}, ..., \hastype{\ltivar{m}}{\ltiP{m}}}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{m}}{\ltiT{m}}}}
    }
  \end{mathpar}
  \caption{Colored Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{Synthesized types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{General types} \\
\end{array}
$$
\caption{Extension Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(T-Var)]
    {}
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltivar{}}
                  {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [(T-Abs)]
    { 
    \ltitjudgement{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 }

    \infer [(T-App)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSp{}}
                  \\
    \ltisubtype{\ltiSp{}}{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                  {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
    }

    \infer [($\text{T-App}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiBot}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiR{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiT{}}}{\ltiE{}}}
                  {\ltiBot}
    }

    \infer [(T-Sel)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [($\text{T-Sel}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [(T-Rec)]
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \\\\

    \infer [(S-Bot)]
    {}
    {
    \ltisubtype{\ltiBot}{\ltiT{}}
    }

    \infer [(S-Top)]
    {}
    {
    \ltisubtype{\ltiT{}}{\ltiTop}
    }

    \infer [(S-Var)]
    {}
    {
    \ltisubtype{\ltitvar{}}{\ltitvar{}}
    }

    \infer [(S-Rec)]
    {
    \ltisubtype{\ltiT{1}}
               {\ltiTp{1}}
                 \\
                 ...
                 \\
    \ltisubtype{\ltiT{n}}
               {\ltiTp{n}}
    }
    {
    \ltisubtype{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}},
                        \hastype{\ltivar{n+1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{m}}}}
               {\ltiRec{\hastype{\ltivar{1}}{\ltiTp{1}}, ..., \hastype{\ltivar{n}}{\ltiTp{n}}}}
    }

    \infer [(S-Fun)]
    {
    \ltisubtype{\ltiT{1}}{\ltiTp{1}}
    \\
    \ltisubtype{\ltiT{2}}{\ltiTp{2}}
    }
    {
    \ltisubtype{\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }

    \\

    \infer [(CG-Top)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty{}}
    }

    \infer [(CG-Bot)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty{}}
    }

    \infer [(CG-Upper)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [(CG-Lower)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [(CG-Refl)]
    {
                     {\ltitvarp{}}
                     \not\in
                     {\overline{\ltitvar{}}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [(CG-Fun)]
    {
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}})
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }

  \end{mathpar}
  \caption{Type system for internal language:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$.
                 Also
                 %$\ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}$
                 %where $\ltiV{} \cap \ltitvar{} = \varnothing$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [($\text{T-Uabs}$)]
    {}
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [(S-Closure)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
    {
    \ltisubtype{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
  \end{mathpar}
  \caption{Extension Type system:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [($\text{abs}_{\ltiWild}$)]
    {}
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [(app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }

  \end{mathpar}
  \caption{Delayed checking Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\section{Introduction}

\section{Related Work}

Xie and Oliveira~\cite{xie2018let} present a type system where
argument type information flows to the function position in applications.
Then, defining `let` as sugar propagates enough information to avoid
a custom rule for `let`.
No information is propagated from functions to applications, so the benefits
of Colored Local Type Inference are negated.

\printbibliography

\end{document}
