\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{symb-common}
\usepackage{pdflscape}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{positioning,calc}

%\title{Symbolic execution in Typed Clojure}
%\title{Local Type Inference for Optional Type Systems}
%\title{Local Type Inference for Anonymous Functions in Higher-Order contexts}
%\title{Local Type Inference for Higher-Order usages of Anonymous Functions}
%\title{Delayed Local Type Inference with Free Theorems}
%\title{Lazy Local Type Inference with Free Theorems}
%\title{Free Theorems for Local Type Inference}
\title{Directed Local Type Inference for Typed Clojure}

\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
Many type systems using local type inference do not reuse type information aggressively
enough to elide annotations for local functions.
Common solutions to checking an unannotated function is to try and
immediately check it with the top type, or a dynamic type, or simply
require annotations.

  We present a variant of System $F_{<:}$ that delays type checking until
the free theorems of a polymorphic type tells us there is enough information
available that further delay would threaten type-soundness.

We particularly target type systems for untyped languages, who require
top-level annotations, but allow annotations to be elided from local functions.
A key hypothesis we rely on is that re-checking the body of a local function
is reasonable and cheap.
\end{abstract}

%\input{symb-proof-system}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}} \alt
                         \ltiappinst{\ltiF{}}{\overline{\ltitvar{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltivar{} \alt
                         \ltiTop{} \alt
                         \ltiBot{} \alt
                         \ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}} \alt
                         \ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}
                      &\mbox{Types} \\
\end{array}
$$
\caption{Internal Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(I-Var)]
    {}
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltivar{}}
                  {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [(I-Abs)]
    { 
    \ltitjudgement{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 }

    \infer [(I-App)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSp{}}
                  \\
    \ltisubtype{\ltiSp{}}{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                  {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
    }

    \infer [($\text{I-App}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiBot}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiR{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiT{}}}{\ltiE{}}}
                  {\ltiBot}
    }

    \infer [(I-Sel)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [($\text{I-Sel}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [(I-Rec)]
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \\\\

    \infer [(S-Bot)]
    {}
    {
    \ltisubtype{\ltiBot}{\ltiT{}}
    }

    \infer [(S-Top)]
    {}
    {
    \ltisubtype{\ltiT{}}{\ltiTop}
    }

    \infer [(S-Var)]
    {}
    {
    \ltisubtype{\ltitvar{}}{\ltitvar{}}
    }

    \infer [(S-Rec)]
    {
    \ltisubtype{\ltiT{1}}
               {\ltiTp{1}}
                 \\
                 ...
                 \\
    \ltisubtype{\ltiT{n}}
               {\ltiTp{n}}
    }
    {
    \ltisubtype{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}},
                        \hastype{\ltivar{n+1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{m}}}}
               {\ltiRec{\hastype{\ltivar{1}}{\ltiTp{1}}, ..., \hastype{\ltivar{n}}{\ltiTp{n}}}}
    }

    \infer [(S-Fun)]
    {
    \ltisubtype{\ltiT{1}}{\ltiTp{1}}
    \\
    \ltisubtype{\ltiT{2}}{\ltiTp{2}}
    }
    {
    \ltisubtype{\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
  \end{mathpar}
  \caption{Type system for internal language:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(CG-Top)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty{}}
    }

    \infer [(CG-Bot)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty{}}
    }

    \infer [(CG-Upper)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [(CG-Lower)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [(CG-Refl)]
    {
                     {\ltitvarp{}}
                     \not\in
                     {\overline{\ltitvar{}}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [(CG-Fun)]
    {
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }
  \end{mathpar}
  \caption{Constraint generation system
                 $\ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}$
                 where $\ltiV{} \cap {\overline{\ltitvar{}}} = \varnothing$.
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufun{\ltivar{}}{\ltiE{}} \alt
                         \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Synthesized types} \\
  \ltiChk{\ltiT{}}, \ltiChk{\ltiS{}}, \ltiChk{\ltiR{}} &::=& 
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Inherited types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                                    \\&\alt&
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}
                         \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                      &\mbox{General types} \\
  \ltiC{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiT{}}, ...,
                          \ltiCEntry{\ltiT{}}{\ltitvar{n}}{\ltiT{}}}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{External Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(W-var)]
    {}
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}{\ltivar{}}
                 {\ltimatchsuper{\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}{\ltiP{}}}
    }

    \infer [($\text{W-abs}_{tp,?}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-abs}_{tp}$)]
    {
    \ltijudgement{\ltiPp{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                                {\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}}
    }
    
    \infer [($\text{W-abs}_{tp,\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiTop}
    }
    
    \infer [(W-abs)]
    {
    \ltijudgement{\ltiP}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-app}_{tp}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{tp,\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [(W-app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }

    \infer [(W-sel)]
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{}}{\ltiP{}}}}{\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiRec{\hastype{\ltivar{}}{\ltiT{}}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltisel{\ltiF{}}{\ltivar{}}}
                 {\ltiT{}}
    }

    \infer [($\text{W-rec}_{\ltiWild{}}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [($\text{W-rec}_{\ltiTop}$)]
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [(W-rec)]
    {
    (
    \ltijudgement{\ltiP{1}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiP{m}}
                 {\ltiEnv{}}
                 {\ltiF{m}}
                 {\ltiT{m}}
                 )
    \\
    (
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{m+1}}
                 {\ltiT{m+1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
                 )
    }
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{1}}{\ltiP{1}}, ..., \hastype{\ltivar{m}}{\ltiP{m}}}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{m}}{\ltiT{m}}}}
    }
  \end{mathpar}
  \caption{Colored Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{Synthesized types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{General types} \\
  \ltiD{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{1}}{\ltitvar{1}}{\ltiTp{1}}, ...,
                          \ltiCEntry{\ltiT{n}}{\ltitvar{n}}{\ltiTp{n}},
                          \ltiDEntry{\ltiClosure{\ltiEnv{1}}{\ltiufun{\ltivar{1}}{\ltiE{1}}}}{\ltiT{}}
                          , ...,
                          \ltiDEntry{\ltiClosure{\ltiEnv{m}}{\ltiufun{\ltivar{m}}{\ltiE{m}}}}{\ltiT{m}}
}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{Extension Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
  \end{mathpar}
  \caption{Extension Type system:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(S-Closure)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
    {
    \ltisubtype{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }

    \infer [(CG-Closure)]
    {
    \ltidemote{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiS{1}}
    \\\\
    \ltijudgement{\ltiArrow{\ltiS{1}}{\overline{\ltitvarp{}}}
                           {\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiT{2}}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiS{1}}{\overline{\ltitvarp{}}}{\ltiS{2}}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup {\overline{\ltitvarp{}}}}
                     {\overline{\ltitvar{}}}{\ltiS{2}}{\ltiT{2}}
                     {\ltiC{}}
    \\\\
                     \ltiCDep{\ltitv{\ltiT{1}} \cap \overline{\ltitvar{}}}
                              {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}
                              \mathbin{<:}
                               \ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                              {\ltiC{}}
                              =
                              {\ltiCp{}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                     {\ltiCp{}}
    }
    \\
    \infer [(CG-Fun2)]
    {
    \ltitv{\ltiT{1}} \cap \overline{\ltitvar{}} = \overline{\ltitvarpp{}}
    \\
    \ltidemote{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiS{1}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarp{}}}
                     {\overline{\ltitvarpp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\\\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvarp{}}}
                     {\overline{\ltitvar{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvarp{}} \cap (\ltiV{} \cup \overline{\ltitvar{}}) = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvarp{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvarp{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }

    \infer [($\text{W-abs}_{\ltiWild{}\rightarrow}$)]
    {
    \ltijudgement{\ltiPp{}}
                 {\ltiEnv{},\overline{\ltitvar{}},
                  \hastype{\ltivar{}}{\ltimatchsuper{\ltiBot}{{\ltiP{}}}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [($\text{W-abs}_{\ltiTop}$)]
    {}
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiTop}
    }

    \infer [($\text{W-abs}_{\ltiWild{}}$)]
    {}
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [(W-app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }
    \\\\

    \infer [(CO-More)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \overline{\ltitvarp{}}
     \\
     \overline{\ltitvarp{}} \not= \varnothing
     \\\\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
     \\
     \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }

    \infer [(CO-Done)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \varnothing
     \\
     \overline{\ltitvar{}} \not= \varnothing
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
  \end{mathpar}

  $$
  \begin{array}{lllr}
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltitvar{1}} &=&  \{\ltitvar{1}\} 
         & \text{if } \ltitvar{1} \in \overline{\ltitvar{}} \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
      &=& (\bigcup \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{1}}
            ...
            \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{n}})
      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiArrow{\ltiT{}}{\overline{\ltitvarp{}}}{\ltiS{}}}
      &=& \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}}
         & \text{if } \ltitv{\ltiT{}} \cap \overline{\ltitvar{}} = \varnothing \\

      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} &=&  \varnothing & \text{otherwise}\\
  \end{array}
  $$
  \caption{Delayed checking Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\newpage
\begin{landscape}
\begin{figure}
  \small
  \begin{mathpar}
  \inferrule* [right=CG-LeftPoly]
  {
   \inferrule* [right=CG-Fn]
   { 
     {\inferrule*[right=CG-Delay,vdots=1.5em,leftskip=2em,rightskip=2em
                  ]
      { 
        \ltidemote{a}{a,b}{\ltiBot}
        \\\\
        \ltigenconstraint{r,a,b}
                         {x}
                         {\ltiBot}
                         {x}
                         {\ltiCSet{\ltiCEntry{\ltiBot}{x}{\ltiTop}}}
        \\\\
        \ltiSubst{\ltiCSet{\ltiCEntry{\ltiBot}{x}{\ltiTop}}}
                 {x}
                 {x}
                 =
                 \ltiBot
        \\\\
        \ltigenconstraint{r}
                         {a,b}
                         {\ltiBot}
                         {b}
                         {\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}}
      }
      { \ltigenconstraint{r}
                         {a,b}
                         {\ltiArrow{x}{x}{x}}
                         {\ltiArrow{a}{}{b}}
                         {\textbf{delay}^{a}({\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}})}
                         }
     }
     \\
     {\inferrule*[right=CG-Seq]
      {
       \ltigenconstraint{r}
                        {a,b}
                        {\ltiInt}
                        {a}
                        {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
      }
      {
       \ltigenconstraint{r}
                        {a,b}
                        {\ltiSeqable{\ltiInt}}
                        {\ltiSeqable{a}}
                        {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
                        }
     }
     \\
     {\inferrule*[]
       {}
       {
        \ltigenconstraint{}
                         {r}
                         {\ltiSeqable{b}}
                         {r}
                         {\ltiCSet{\ltiCEntry{\ltiSeqable{b}}{r}{\ltiTop}}}
                        }
     }
   }
   { \ltigenconstraint{r}
                      {a,b}
                      {\ltiArrow{(\ltiArrow{a}{}{b}, \ltiSeqable{a})}
                                {}
                                {\ltiSeqable{b}}}
                      {\ltiArrow{(\ltiArrow{x}{x}{x}, \ltiSeqable{\ltiInt})}
                                {}
                                {r}}
                      {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}},
                       \textbf{delay}^{a}({\ltiCSet{\ltiCEntry{\ltiBot}{b}{\ltiTop}}})}
                      }
  }
  {  \ltigenconstraint{}
                      {r}
                      {\ltiArrow{(\ltiArrow{a}{}{b}, \ltiSeqable{a})}
                                {a, b}
                                {\ltiSeqable{b}}}
                      {\ltiArrow{(\ltiArrow{x}{x}{x}, \ltiSeqable{\ltiInt})}
                                {}
                                {r}}
                      {}
  }

  \end{mathpar}
\caption{Derivation of \texttt{(map identity [1 2 3])}}
\end{figure}

\begin{figure}
  \small
  \begin{mathpar}
   \inferrule* [right=CG-Fn]
   { 
     {\inferrule*[%right=CG-Delay%,
                  vdots=1.5em,leftskip=2em,rightskip=2em
                  ]
      { {\ltigenconstraint{}
                          {a,b}
                          {\ltiBot}
                          {\ltiInt}
                          {\ltiCEmpty{}}
                         }
        \\
        {\ltigenconstraint{}
                          {a,b}
                          {\ltiInt}
                          {\ltiTop}
                          {\ltiCEmpty{}}
                         }
      }
      { \ltigenconstraint{}
                         {a,b}
                         {\ltiArrow{\ltiInt}{}{\ltiInt}}
                         {\ltiArrow{a}{}{b}}
                         {\texttt{delay}_{b}^{a}()}
                         }
     }
     \\
     {\ltigenconstraint{}
                       {a,b}
                       {\ltiInt}
                       {a}
                       {\ltiCSet{\ltiCEntry{\ltiInt}{a}{\ltiTop}}}
     }
   }
   { \ltigenconstraint{}
                      {a,b}
                      {(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}
                      {(\ltiArrow{a}{}{b}, a)}
                      {}
                      }


  \infer [(W-app)]
  {
  \ltijudgement{\ltiWild{}}
               {\ltiEnv{}}
               {\texttt{app}}
               {\ltiArrow{(\ltiArrow{a}{}{b}, a)}{a, b}{b}}
               %{\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
               \\
  \ltijudgement{(\ltiArrow{\ltiWild{}}{}{\ltiWild{}}, \ltiWild{})}
               {\ltiEnv{}}
               {(\texttt{inc}, \texttt{1})}
               {(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}
               %{\ltiSp{}}
               \\\\
  \ltigenconstraint{}{a,b}{(\ltiArrow{\ltiInt}{}{\ltiInt}, \ltiInt)}{(\ltiArrow{a}{}{b}, a)}{\ltiC{1}}
               \\
  \ltigenconstraint{}{a,b}{b}{\ltimatchsub{\ltiTop}{\ltiWild{}}}{\ltiC{2}}
  }
  {
  \ltijudgement{\ltiWild{}}%{\ltiP{}}
               {\ltiEnv{}}
               {\ltiapp{\texttt{app}}{\texttt{inc}, \texttt{1}}}
               {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{b}{\ltimatchsuper{b}{\ltiWild{}}}}
  }
  \end{mathpar}

  $$
  \begin{array}{l}
    \hastype{\texttt{app}}{\ltiArrow{(\ltiArrow{a}{}{b}, a)}{a, b}{b}}\\
    \hastype{\texttt{inc}}{\ltiArrow{\ltiInt}{}{\ltiInt}}\\
    \hastype{\texttt{1}}{\ltiInt}
  \end{array}
  $$
\caption{Derivation of \texttt{(app inc 1)}
  }
\end{figure}
\end{landscape}

\newpage

%helpful tikz references
% https://tex.stackexchange.com/questions/204417/how-can-i-draw-arrows-within-a-listing-to-explain-positional-association

\section{Introduction}

We apply the area of constrained types to a type system with Local Type Inference.
All top level functions are type-annotated, and we are left to infer the types of
unannotated anonymous functions and reconstruct the type arguments of polymorphic
applications.

Often, Clojure programmers write anonymous functions that are not recursive, and
are only used once. With that insight, we can start to design a local type inference
algorithm that attempts to infer parameter types for lambdas.

For example, take the following code. We draw an arrow to show how data flows
through this expression.

\begin{lstlisting}[escapeinside={(*@}{@*)}]
(let [f #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*)]
  (f (*@\tikz[overlay,remember picture] \node [] (a) {};@*)1))(*@\tikz[overlay,remember picture] \node [] (d) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
\end{tikzpicture} 

Checking this code, intuitively, is a matter of delaying checking
\clj{f} until it is called, and then using the type of the provided arguments
to check the body of \clj{f}.

In a higher order setting, this becomes slightly more complicated, as
the control flow is not readily apparent.

\begin{lstlisting}
(let [f #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*)]
  (map f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3(*@\tikz[overlay,remember picture] \node [] (a1) {};@*)]))(*@\tikz[overlay,remember picture] \node [] (d) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (OtherEnd) at (a1);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[decorate,decoration={brace,mirror,raise=2pt}](Start1.south) to coordinate [] (Mid) (OtherEnd.south) node {};
  \draw[->,in=-45, out=-45](Mid) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
\end{tikzpicture} 

Composing two anonymous functions with \clj{comp} and mapping
them over a collection has an even more interesting control flow.

\begin{lstlisting}
(let [f (comp #(dec (*@\tikz[overlay,remember picture] \node [] (d) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (e) {};@*)
              #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*))]
  (map f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3]))(*@\tikz[overlay,remember picture] \node [] (f) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[->](Start1.north) to (End1.south);
  \draw[->](Start2.north) to (End2.south);
  \draw[->](Start3.north) to (End3.south);
\end{tikzpicture} 

%\begin{lstlisting}
%(let [f (map #(inc %))]
%  (sequence f [1 2 3]))
%\end{lstlisting}
%

Transducers compose ``left-to-right'', so their control flow is inverted.

\begin{lstlisting}
(let [f (comp (map #(inc (*@\tikz[overlay,remember picture] \node [] (b) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (c) {};@*))
              (map #(dec %(*@\tikz[overlay,remember picture] \node [] (d) {};@*))(*@\tikz[overlay,remember picture] \node [] (e) {};@*)))]
  (sequence f [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)1 2 3]))(*@\tikz[overlay,remember picture] \node [] (f) {};@*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[->,in=180,  out=90](Start1.south) to (End1.east);
  \draw[->](Start2.east) to (End2.north east);
  \draw[->](Start3.north) to (End3.south);
\end{tikzpicture} 

%\begin{lstlisting}
%(let [f (map #(inc %))]
%  (sequence f [1 2 3]))
%\end{lstlisting}
%

\section{Easy cases}

In Clojure, many commonly used polymorphic higher-order functions satisfy
the following criteria:

\begin{itemize}
  \item Some of the function's type variables are left of the main arrow, but
        not under any other arrows.
  \item These type variables also occur inside a parameter type, but to the left of exactly one more arrow.
  \item The function's type variables can be topologically sorted.
  \item The function's type variables do not occur under an arrow in the return type.
\end{itemize}

Perhaps equivalently:

\begin{itemize}
  \item If a type variable occurrence is in a contravariant position,
        any other contravariant occurrences must occur in the same "position".
\end{itemize}

The following core functions satisfy this criteria: \texttt{
map, filter, filterv, remove, take-while, drop-while, split-with, some, sorted-set-by,
update, update-in, apply, sort, swap!, alter-var-root, commute, alter, every?, mapv,
mapcat, pmap, map-indexed, keep-indexed, send-via, send, send-off, max-key, min-key}.

\texttt{map} is a typical example of this kind of function. The type of \texttt{a} is immediately
provided by the second argument, then \texttt{a} is expected as the input to the first argument.
By the free theorems of \texttt{map}'s type, \texttt{a} can only be provided by the second argument, so
its most precise instantiation is exactly the type of the second argument.

\begin{lstlisting}
; Type of `map`

(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
\end{tikzpicture} 

Then, \texttt{a} does not occur in the output of the first argument, so we can topologically sort
the instantiation order of \texttt{a} and \texttt{b}---since \texttt{a} is provided immediately, and
\texttt{b} occurs to the right of an arrow with input \texttt{a}, then the instantiation
order is \texttt{a} then \texttt{b}.

\section{Types as control flow graphs}

%\begin{lstlisting}
%; Type of `map`
%
%(All [a b]
%  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)])
%\end{lstlisting}
%\begin{tikzpicture}[remember picture, overlay,
%                  text width = 2.5cm ]
%  \coordinate (Start1) at (a);
%  \coordinate (End1) at (b);
%  \coordinate (Start2) at (c);
%  \coordinate (End2) at (d);
%  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
%  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
%\end{tikzpicture} 

\begin{lstlisting}
; Type of partial `map`

(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] -> [(Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)]])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
\end{tikzpicture} 

\begin{lstlisting}
; Type of expanded `comp`

(All [a b c]
  [[(*@\tikz[overlay,remember picture] \node [] (d) {};@*)b -> (*@\tikz[overlay,remember picture] \node [] (e) {};@*)c] [(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (f) {};@*)c])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
  \draw[blue,->,bend right=-45](Start3.east) to (End3.north east);
\end{tikzpicture}

\begin{lstlisting}
; Type of `comp`

(All [a b c]
  [[(*@\tikz[overlay,remember picture] \node [] (d) {};@*)b -> (*@\tikz[overlay,remember picture] \node [] (e) {};@*)c] [(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] -> [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (f) {};@*)c]])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
  \draw[blue,->,bend right=-45](Start3.east) to (End3.north east);
\end{tikzpicture}

\begin{lstlisting}
; Type of partial `comp`

(All [a b c]
  [[(*@\tikz[overlay,remember picture] \node [] (d) {};@*)b -> (*@\tikz[overlay,remember picture] \node [] (e) {};@*)c] -> [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] -> [(*@\tikz[overlay,remember picture] \node [] (a) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (f) {};@*)c]]])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \coordinate (Start3) at (e);
  \coordinate (End3) at (f);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
  \draw[blue,->,bend right=-45](Start3.east) to (End3.north east);
\end{tikzpicture}

\begin{lstlisting}
; Type of the `map` transducer

(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] -> (All [r] [[r (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a -> r]])])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-20](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-20](Start2.east) to (End2.north east);
\end{tikzpicture}

\begin{lstlisting}
; Type of the `sequence` transducing function

(All [a b]
  [(All [r] [[r (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> r]]) (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-20](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-20](Start2.east) to (End2.north east);
\end{tikzpicture}

\begin{lstlisting}
; Call (sequence (map #(inc %)) [1 2 3])

                  #(inc (*@\tikz[overlay,remember picture] \node [] (d1) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (d2) {};@*)

(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (d) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (e1) {};@*)b] -> (All [r] [[r (*@\tikz[overlay,remember picture] \node [] (e2) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (c) {};@*)a -> r]])])

(All [a b]
  [(All [r] [[r (*@\tikz[overlay,remember picture] \node [] (f) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> r]]) (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (g) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (A) at (a);
  \coordinate (B) at (b);
  \coordinate (C) at (c);
  \coordinate (D) at (d);
  \coordinate (D1) at (d1);
  \coordinate (D2) at (d2);
  \coordinate (E1) at (e1);
  \coordinate (E2) at (e2);
  \coordinate (F) at (f);
  \coordinate (G) at (g);
  \draw[red,->,bend right=-20](A) to (B);
  \draw[blue,->,bend right=-20](B) to (C);
  \draw[blue,->,bend left=-20](C) to (D);
  \draw[blue,->,bend right=-20](D) to (D1);
  \draw[blue,->,bend left=-20](D1) to (D2);
  \draw[blue,->,bend left=-20](D2) to (E1);
  \draw[blue,->,bend left=-20](E1) to (E2);
  \draw[blue,->,bend right=-20](E2) to (F);
  \draw[blue,->,bend left=-20](F) to (G);
\end{tikzpicture}

\begin{figure}
\begin{lstlisting}
; Call (sequence (comp (map #(inc %)) (map #(dec %))) [1 2 3])

                     #(inc (*@\tikz[overlay,remember picture] \node [] (f1) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (f2) {};@*)           #(dec (*@\tikz[overlay,remember picture] \node [] (l1) {};@*)%)(*@\tikz[overlay,remember picture] \node [] (l2) {};@*)

;(map #(inc %))                            ;(map #(dec %))
(All [a b]                                 (All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (f) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (g) {};@*)b] ->                                 [[(*@\tikz[overlay,remember picture] \node [] (l) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (m) {};@*)b] ->
   (All [r] [[r (*@\tikz[overlay,remember picture] \node [] (h) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (e) {};@*)a -> r]])])        (All [r] [[r (*@\tikz[overlay,remember picture] \node [] (n) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (k) {};@*)a -> r]])])

;(comp ..)
(All [a b c]
  [[(*@\tikz[overlay,remember picture] \node [] (i) {};@*)b -> (*@\tikz[overlay,remember picture] \node [] (d) {};@*)c] [(*@\tikz[overlay,remember picture] \node [] (o) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (j) {};@*)b] -> [(*@\tikz[overlay,remember picture] \node [] (p) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)c]])

;(sequence ..)
(All [a b]
  [(All [r] [[r (*@\tikz[overlay,remember picture] \node [] (q) {};@*)b -> r] -> [r (*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> r]]) (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seqable (*@\tikz[overlay,remember picture] \node [] (r) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (A) at (a);
  \coordinate (B) at (b);
  \coordinate (C) at (c);
  \coordinate (D) at (d);
  \coordinate (E) at (e);
  \coordinate (F) at (f);
  \coordinate (F1) at (f1);
  \coordinate (F2) at (f2);
  \coordinate (G) at (g);
  \coordinate (H) at (h);
  \coordinate (I) at (i);
  \coordinate (J) at (j);
  \coordinate (K) at (k);
  \coordinate (L) at (l);
  \coordinate (L1) at (l1);
  \coordinate (L2) at (l2);
  \coordinate (M) at (m);
  \coordinate (N) at (n);
  \coordinate (O) at (o);
  \coordinate (P) at (p);
  \coordinate (Q) at (q);
  \coordinate (R) at (r);
  \draw[red,->,bend right=-20](A) to (B);
  \draw[blue,->,bend left=-20](B) to (C);
  \draw[blue,->,bend left=-20](C) to (D);
  \draw[blue,->,bend right=-20](D) to (E);
  \draw[blue,->,bend left=-60](E) to (F);
  \draw[red,->,bend left=-20](F) to (F1);
  \draw[red,->,bend left=-20](F1) to (F2);
  \draw[red,->,bend left=-20](F2) to (G);
  \draw[blue,->,bend left=-20](G) to (H);
  \draw[blue,->,bend left=-20](H) to (I);
  \draw[blue,->,bend left=-20](I) to (J);
  \draw[blue,->,bend left=-20](J) to (K);
  \draw[blue,->,bend left=-20](K) to (L);
  \draw[red,->,bend left=-20](L) to (L1);
  \draw[red,->,bend left=-20](L1) to (L2);
  \draw[red,->,bend left=-20](L2) to (M);
  \draw[blue,->,bend left=-20](M) to (N);
  \draw[blue,->,bend left=-20](N) to (O);
  \draw[blue,->,bend left=-20](O) to (P);
  \draw[blue,->,bend left=-20](P) to (Q);
  \draw[blue,->,bend left=-20](Q) to (R);
\end{tikzpicture}
\end{figure}

\begin{figure}
\begin{lstlisting}
(reduce + 0 [1 2 3])

     (IFn [(*@\tikz[overlay,remember picture] \node [] (b11) {};@*)Long (*@\tikz[overlay,remember picture] \node [] (b21) {};@*)Long -> (*@\tikz[overlay,remember picture] \node [] (c0) {};@*)Long]
          [Num Num -> Num])

(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b1) {};@*)a (*@\tikz[overlay,remember picture] \node [] (b2) {};@*)b -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)a] (*@\tikz[overlay,remember picture] \node [] (a1) {};@*)a (Seqable (*@\tikz[overlay,remember picture] \node [] (a2) {};@*)b) -> (*@\tikz[overlay,remember picture] \node [] (d) {};@*)a])

  (*@\tikz[overlay,remember picture] \node [] (init1) {};@*)Long             (Seqable (*@\tikz[overlay,remember picture] \node [] (init2) {};@*)Long)

\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (INIT1) at (init1);
  \coordinate (INIT2) at (init2);
  \coordinate (A1) at (a1);
  \coordinate (A2) at (a2);
  \coordinate (B1) at (b1);
  \coordinate (B11) at (b11);
  \coordinate (B2) at (b2);
  \coordinate (B21) at (b21);
  \coordinate (C0) at (c0);
  \coordinate (C) at (c);
  \coordinate (D) at (d);
  \draw[green,->,bend left=-20](INIT1) to (A1);
  \draw[green,->,bend left=-20](INIT2) to (A2);
  \draw[red,->,bend right=-20](A1) to (B1);
  \draw[red,->,bend left=-20](A2) to (B2);
  \draw[red,->,bend right=-20](B1) to (B11);
  \draw[red,->,bend left=-20](B2) to (B21);
  \draw[blue,->,bend left=-20](C0) to (C);
  %\draw[blue,->,bend left=-20](C) to (B1);
  \draw[blue,->,bend right=-20](C) to (D);
\end{tikzpicture}
\end{figure}

\section{Improved Error Messages}

\section{Avoiding infinite loops}

% syntactic restrictions
% y combinator

\section{Related Work}

Xie and Oliveira~\cite{xie2018let} present a type system where
argument type information flows to the function position in applications.
Then, defining `let` as sugar propagates enough information to avoid
a custom rule for `let`.
No information is propagated from functions to applications, so the benefits
of Colored Local Type Inference are negated.

% MLsub
% https://www.cl.cam.ac.uk/~sd601/thesis.pdf
% https://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
%
% Polar type system (Jim)
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8718&rep=rep1&type=pdf

% survey
% Expansion: the Crucial Mechanism for Type Inference with Intersection Types: A Survey and Explanation1
% https://www.sciencedirect.com/science/article/pii/S1571066105050656
% - "expansion" seems similar to inferring intersection types via symbolic closures
%   - Section 6.2 talks about type inference for rank-2 intersection types
%     - advantage is that expansion never has to introduce intersections under ->
%       - do we do this with symbolic closures?
% - "Expansion is an operation on typings that simulates the effect of splicing in typing rules
%    uses at nested positions in some derivation of that typing."
% - omega expansion looks very similar to symbolic closures types (Section 4)
%   - at least in that it embeds the term in the type to track its origin 
% - Section 5.2 talks about cost of type inference == beta reduction

% (Intersection type systems)
% Principal Types and Unification for Simple Intersection Type Systems
% https://www.sciencedirect.com/science/article/pii/S0890540185711418

% ML_F
% http://gallium.inria.fr/~remy/mlf/mlf-type-inference-long.pdf

% Pottier
% Simplifying Subtyping Constraints: A Theory
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.7032&rep=rep1&type=pdf
% A Framework for Type Inference with Subtyping%
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.2364&rep=rep1&type=pdf

\printbibliography

\end{document}
