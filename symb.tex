\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{symb-common}

\title{Symbolic execution in Typed Clojure}
%\title{Local Type Inference for Optional Type Systems}
%\title{Local Type Inference for Anonymous Functions in Higher-Order contexts}
%\title{Local Type Inference for Higher-Order usages of Anonymous Functions}
%\title{Delayed Local Type Inference with Free Theorems}
%\title{Lazy Local Type Inference with Free Theorems}
%\title{Free Theorems for Local Type Inference}
\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
Many type systems using local type inference do not reuse type information aggressively
enough to elide annotations for local functions.
Common solutions to checking an unannotated function is to try and
immediately check it with the top type, or a dynamic type, or simply
require annotations.

  We present a variant of System $F_{<:}$ that delays type checking until
the free theorems of a polymorphic type tells us there is enough information
available that further delay would threaten type-soundness.

We particularly target type systems for untyped languages, who require
top-level annotations, but allow annotations to be elided from local functions.
A key hypothesis we rely on is that re-checking the body of a local function
is resonable and cheap.
\end{abstract}

%\input{symb-proof-system}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& \ltivar{} \alt
                         \ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}} \alt
                         \ltiappinst{\ltiF{}}{\overline{\ltitvar{}}}{\ltiE{}} \alt
                         \ltisel{\ltiE{}}{\ltivar{}} \alt
                         \ltiRec{\ltivar{1} = \ltiE{1}, ..., \ltivar{n} = \ltiE{n}}
                      &\mbox{Terms} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& \ltivar{} \alt
                         \ltiTop{} \alt
                         \ltiBot{} \alt
                         \ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}} \alt
                         \ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}
                      &\mbox{Types} \\
\end{array}
$$
\caption{Internal Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(I-Var)]
    {}
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltivar{}}
                  {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
                 }

    \infer [(I-Abs)]
    { 
    \ltitjudgement{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 }

    \infer [(I-App)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiSp{}}
                  \\
    \ltisubtype{\ltiSp{}}{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                  {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
    }

    \infer [($\text{I-App}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}{\ltiF{}}
                  {\ltiBot}
                  \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiR{}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\overline{\ltiT{}}}{\ltiE{}}}
                  {\ltiBot}
    }

    \infer [(I-Sel)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiT{i}}
    }

    \infer [($\text{I-Sel}_{\ltiBot}$)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
                  {\ltiBot}
    }

    \infer [(I-Rec)]
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltitjudgement{\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \\\\

    \infer [(S-Bot)]
    {}
    {
    \ltisubtype{\ltiBot}{\ltiT{}}
    }

    \infer [(S-Top)]
    {}
    {
    \ltisubtype{\ltiT{}}{\ltiTop}
    }

    \infer [(S-Var)]
    {}
    {
    \ltisubtype{\ltitvar{}}{\ltitvar{}}
    }

    \infer [(S-Rec)]
    {
    \ltisubtype{\ltiT{1}}
               {\ltiTp{1}}
                 \\
                 ...
                 \\
    \ltisubtype{\ltiT{n}}
               {\ltiTp{n}}
    }
    {
    \ltisubtype{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}},
                        \hastype{\ltivar{n+1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{m}}}}
               {\ltiRec{\hastype{\ltivar{1}}{\ltiTp{1}}, ..., \hastype{\ltivar{n}}{\ltiTp{n}}}}
    }

    \infer [(S-Fun)]
    {
    \ltisubtype{\ltiT{1}}{\ltiTp{1}}
    \\
    \ltisubtype{\ltiT{2}}{\ltiTp{2}}
    }
    {
    \ltisubtype{\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
  \end{mathpar}
  \caption{Type system for internal language:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$.
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(CG-Top)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiTop}{\ltiCEmpty{}}
    }

    \infer [(CG-Bot)]
    {}
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiBot}{\ltiT{}}{\ltiCEmpty{}}
    }

    \infer [(CG-Upper)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltidemote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltitvar{1}}{\ltiS{}}
                     {\ltiCSet{\ltiCEntry{\ltiBot}{\ltitvar{1}}{\ltiT{}}}}
    }

    \infer [(CG-Lower)]
    {
    \ltitvar{1} \in \overline{\ltitvar{}}
    \\
    \ltipromote{\ltiS{}}{\ltiV{}}{\ltiT{}}
    \\
    \ltitv{\ltiS{}} \cap \overline{\ltitvar{}} = \varnothing
    }
    {
    \ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiS{}}{\ltitvar{1}}
                     {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiTop}}}
    }

    \infer [(CG-Refl)]
    {
                     {\ltitvarp{}}
                     \not\in
                     {\overline{\ltitvar{}}}
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvar{}}}
                     {\ltitvarp{}}
                     {\ltitvarp{}}
                     {\ltiCEmpty}
    }

    \infer [(CG-Fun)]
    {
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{1}}
                     {\ltiTp{1}}
                     {\ltiC{1}}
    \\
    \ltigenconstraint{\ltiV{} \cup \overline{\ltitvar{}}}
                     {\overline{\ltitvarp{}}}
                     {\ltiT{2}}
                     {\ltiTp{2}}
                     {\ltiC{2}}
    \\
    \overline{\ltitvar{}} \cap (\ltiV{} \cup \overline{\ltitvarp{}})
    }
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiArrow{\ltiTp{1}}{\overline{\ltitvar{}}}{\ltiT{2}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCIntersect{\ltiC{1}}{\ltiC{2}}}
    }
  \end{mathpar}
  \caption{Constraint generation system
                 $\ltigenconstraint{\ltiV{}}{\overline{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiC{}}$
                 where $\ltiV{} \cap {\overline{\ltitvar{}}} = \varnothing$.
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufun{\ltivar{}}{\ltiE{}} \alt
                         \ltiapp{\ltiF{}}{\ltiE{}}
                      &\mbox{Terms} \\
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Synthesized types} \\
  \ltiChk{\ltiT{}}, \ltiChk{\ltiS{}}, \ltiChk{\ltiR{}} &::=& 
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}} \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
                      &\mbox{Inherited types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                         \ltiSyn{\ltivar{}} \alt
                         \ltiSyn{\ltiTop{}} \alt
                         \ltiSyn{\ltiBot{}} \alt
                         \ltiSyn{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}} \alt
                         \ltiSyn{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                                    \\&\alt&
                         \ltiChk{\ltivar{}} \alt
                         \ltiChk{\ltiTop{}} \alt
                         \ltiChk{\ltiBot{}} \alt
                         \ltiChk{\ltiArrow{\ltiSynChk{\ltiT{}}}{\overline{\ltitvar{}}}{\ltiSynChk{\ltiS{}}}}
                         \alt
                         \ltiChk{\ltiRec{\hastype{\ltivar{1}}{\ltiSynChk{\ltiT{1}}},
                                    ..., \hastype{\ltivar{n}}{\ltiSynChk{\ltiT{n}}}}}
                      &\mbox{General types} \\
  \ltiC{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{}}{\ltitvar{1}}{\ltiT{}}, ...,
                          \ltiCEntry{\ltiT{}}{\ltitvar{n}}{\ltiT{}}}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{External Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(W-var)]
    {}
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}{\ltivar{}}
                 {\ltimatchsuper{\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}{\ltiP{}}}
    }

    \infer [($\text{W-abs}_{tp,?}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-abs}_{tp}$)]
    {
    \ltijudgement{\ltiPp{}}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                                {\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}}
    }
    
    \infer [($\text{W-abs}_{tp,\ltiTop}$)]
    {
    \ltijudgement{\ltiTop}{\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltifun{\overline{\ltitvar{}}}{\ltivar{}}{\ltiT{}}{\ltiE{}}}
                 {\ltiTop}
    }
    
    \infer [(W-abs)]
    {
    \ltijudgement{\ltiP}
                 {\ltiEnv{},\overline{\ltitvar{}},\hastype{\ltivar{}}{\ltiT{}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiP{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiArrow{\ltiT{}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }

    \infer [($\text{W-app}_{tp}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiS{}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltireplace{\overline{\ltiR{}}}{\overline{\ltitvar{}}}{\ltiT{}}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{tp,\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiappinst{\ltiF{}}{\overline{\ltiR{}}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [($\text{W-app}_{\ltiBot}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiBot}
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltimatchsuper{\ltiBot{}}
                                {\ltiP{}}}
    }

    \infer [(W-app)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiArrow{\ltiS{}}{\overline{\ltitvar{}}}{\ltiT{}}}
                 \\
    \ltijudgement{\ltireplace{\ltiWild{}}{\overline{\ltitvar{}}}{\ltiS{}}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
    \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiSubst{\ltiCUnion{\ltiC{1}}{\ltiC{2}}}{\ltiT{}}{\ltimatchsuper{\ltiT{}}{\ltiP{}}}}
    }

    \infer [(W-sel)]
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{}}{\ltiP{}}}}{\ltiEnv{}}
                 {\ltiF{}}
                 {\ltiRec{\hastype{\ltivar{}}{\ltiT{}}}}
    }
    {
    \ltijudgement{\ltiP{}}{\ltiEnv{}}
                 {\ltisel{\ltiF{}}{\ltivar{}}}
                 {\ltiT{}}
    }

    \infer [($\text{W-rec}_{\ltiWild{}}$)]
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [($\text{W-rec}_{\ltiTop}$)]
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
    }
    {
    \ltijudgement{\ltiTop{}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }

    \infer [(W-rec)]
    {
    (
    \ltijudgement{\ltiP{1}}
                 {\ltiEnv{}}
                 {\ltiF{1}}
                 {\ltiT{1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiP{m}}
                 {\ltiEnv{}}
                 {\ltiF{m}}
                 {\ltiT{m}}
                 )
    \\
    (
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{m+1}}
                 {\ltiT{m+1}}
                 \\
                 ...
                 \\
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiF{n}}
                 {\ltiT{n}}
                 )
    }
    {
    \ltijudgement{\ltiRec{\hastype{\ltivar{1}}{\ltiP{1}}, ..., \hastype{\ltivar{m}}{\ltiP{m}}}}
                 {\ltiEnv{}}
                 {\ltiRec{\ltivar{1} = \ltiF{1}, ..., \ltivar{n} = \ltiF{n}}}
                 {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{m}}{\ltiT{m}}}}
    }
  \end{mathpar}
  \caption{Colored Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiSyn{\ltiT{}}, \ltiSyn{\ltiS{}}, \ltiSyn{\ltiR{}} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{Synthesized types} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& 
                        ... \alt
                        \ltiSyn{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      &\mbox{General types} \\
  \ltiD{} &::=& {\ltiCSet{\ltiCEntry{\ltiT{1}}{\ltitvar{1}}{\ltiTp{1}}, ...,
                          \ltiCEntry{\ltiT{n}}{\ltitvar{n}}{\ltiTp{n}},
                          \ltiDEntry{\ltiClosure{\ltiEnv{1}}{\ltiufun{\ltivar{1}}{\ltiE{1}}}}{\ltiT{}}
                          , ...,
                          \ltiDEntry{\ltiClosure{\ltiEnv{m}}{\ltiufun{\ltivar{m}}{\ltiE{m}}}}{\ltiT{m}}
}}
                      &\mbox{Constraint sets} \\
\end{array}
$$
\caption{Extension Language}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [(S-Closure)]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
    {
    \ltisubtype{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
               {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
    }
    \\
    \infer [(CG-Closure)]
    {}
    {
    \ltigenconstraint{\ltiV{}}
                     {\overline{\ltitvarp{}}}
                     {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                     {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}
                     {\ltiCSet{\ltiDEntry{\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                                         {\ltiArrow{\ltiT{1}}{\overline{\ltitvar{}}}{\ltiTp{2}}}}}
    }
  \end{mathpar}
  \caption{Extension Type system:
  $\ltitjudgement{\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
                 and
                 $\ltisubtype{\ltiT{}}{\ltiS{}}$
  }
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [($\text{W-abs}_{\ltiWild{}\rightarrow}$)]
    {
    \ltijudgement{\ltiPp{}}
                 {\ltiEnv{},\overline{\ltitvar{}},
                  \hastype{\ltivar{}}{\ltimatchsuper{\ltiBot}{{\ltiP{}}}}}
                 {\ltiE{}}
                 {\ltiS{}}
    }
    {
    \ltijudgement{\ltiArrow{\ltiP{}}{\overline{\ltitvar{}}}{\ltiPp{}}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [($\text{W-abs}_{\ltiTop}$)]
    {}
    {
    \ltijudgement{\ltiTop}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiTop}
    }

    \infer [($\text{W-abs}_{\ltiWild{}}$)]
    {}
    {
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiufun{\ltivar{}}{\ltiE{}}}
                 {\ltiClosure{\ltiEnv{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
    }

    \infer [(W-appInaccessible)]
    {
    \ltijudgement{\ltiWild{}}{\ltiEnv{}}{\ltiF{}}
                 {\ltiT{}}
                 \\
    \ltijudgement{\ltiWild{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiSp{}}
                 \\\\
     %\ltigenconstraint{}{}
    }
    {
    \ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiapp{\ltiF{}}{\ltiE{}}}
                 {\ltiTp{}}
    }

    \\\\

    \infer [(CO-More)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \overline{\ltitvarp{}}
     \\
     \overline{\ltitvarp{}} \not= \varnothing
     \\\\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiSp{}}{\ltiS{}}{\ltiC{1}}
                 \\
     \ltigenconstraint{}{\overline{\ltitvar{}}}{\ltiT{}}{\ltimatchsub{\ltiTop}{\ltiP{}}}{\ltiC{2}}
     \\
     \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }

    \infer [(CO-Done)]
    {
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}} 
     \cup
     \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} 
     = \varnothing
     \\
     \overline{\ltitvar{}} \not= \varnothing
    }
    {
    \lticheckorder{\overline{\ltitvar{}}}{\ltiS{}}{\ltiT{}}{\ltiSp{}}{\ltiP{}}{\ltiTp{}}
    }
  \end{mathpar}

  $$
  \begin{array}{lllr}
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltitvar{1}} &=&  \{\ltitvar{1}\} 
         & \text{if } \ltitvar{1} \in \overline{\ltitvar{}} \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
      &=& (\bigcup \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{1}}
            ...
            \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{n}})
      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}
       {\ltiArrow{\ltiT{}}{\overline{\ltitvarp{}}}{\ltiS{}}}
      &=& \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiS{}}
         & \text{if } \ltitv{\ltiT{}} \cap \overline{\ltitvar{}} = \varnothing \\

      \\
    \ltiaccessibletv{\overline{\ltitvar{}}}{\ltiT{}} &=&  \varnothing & \text{otherwise}\\
  \end{array}
  $$
  \caption{Delayed checking Local type inference algorithmic rules
  $\ltijudgement{\ltiP{}}
                 {\ltiEnv{}}
                 {\ltiE{}}
                 {\ltiT{}}$
  }
\end{figure}

\section{Introduction}

\section{Related Work}

Xie and Oliveira~\cite{xie2018let} present a type system where
argument type information flows to the function position in applications.
Then, defining `let` as sugar propagates enough information to avoid
a custom rule for `let`.
No information is propagated from functions to applications, so the benefits
of Colored Local Type Inference are negated.

% MLsub
% https://www.cl.cam.ac.uk/~sd601/thesis.pdf
% https://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
%
% Polar type system (Jim)
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8718&rep=rep1&type=pdf

% survey
% Expansion: the Crucial Mechanism for Type Inference with Intersection Types: A Survey and Explanation1
% https://www.sciencedirect.com/science/article/pii/S1571066105050656

\printbibliography

\end{document}
