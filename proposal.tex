\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}

\usepackage{esop-common}
\usepackage{infer-common}

\title{Thesis Proposal: Typed Clojure in Theory and Practice}
\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
We present Typed Clojure, an optional type system for the Clojure programming language.
This thesis argues Typed Clojure is sound and practical,
that we can improve its usability by automatically generating type annotations based on runtime observations,
and then we can repurpose this annotation technology to generate clojure.spec runtime specifications
and evaluate these annotations in hundreds of projects.
%.
%and answer broad questions about how Clojure is used.

First, I will present Typed Clojure, an optional type system for Clojure.
I will develop a formal model of Typed Clojure that includes
key features like hash-maps, multimethods, Java interoperability, and occurrence typing,
and prove the model type sound.
Then, I will demonstrate that Typed Clojure's design is useful and corresponds to actual usage patterns
with an emperical study of real-world Typed Clojure usage in over 19,000 lines of code.

Second, we address a major usability flaw in Typed Clojure: users must \emph{manually}
write annotations.
To remedy this, 
I will present a tool that automatically generates Typed Clojure annotations based on observed
program behavior, including
a formal model of the tool, consisting of its runtime instrumentation phase that
collects samples from a running program, and type reconstruction phase
that creates useful annotations from these samples.
Then, I will give an overview of a practical implementation that generates Typed Clojure annotations for
real programs.
Next, I will study the effectiveness, accuracy, and usability of these annotations
by generating annotations for several projects, and then manually amending the annotations
until they type check.

Third, I will repurpose my automatic annotation tool to generate clojure.spec annotations (``specs'')
and subsequently test their effectiveness over hundreds of open source Clojure projects.
I will outline clojure.spec, the official runtime verification
library bundled with Clojure, and present a formal model of clojure.spec that highlights its
``generative testing'' function checking semantics.
Next, I will discuss how to extend my annotation tool to generate specs.
Finally, I will verify the effectiveness of generated specs in hundreds of open-source Clojure projects.
%Third, I will conduct a larger scale investigation of Clojure usage patterns by
%repurposing my automatic annotation tool to generate clojure.spec annotations (``specs'')
%and subsequently use them to enforce.
%I will outline clojure.spec, the official runtime verification
%library bundled with Clojure, and present a formal model of clojure.spec that highlights its
%``generative testing'' function checking semantics.
%Next, I will discuss how to extend my annotation tool to generate specs.
%Finally, I will automatically generate specs for hundreds of open-source Clojure projects,
%and use this data to investigate general questions like the effectiveness of unit and generative testing,
%the evolution of code over time, and the prevalence of idioms that Typed Clojure and clojure.spec
%have been designed around.
\end{abstract}

%\input{esop-full}
%\input{infer-full}

\section{Introduction}

To contextualize the thread of work I propose in this thesis, this section
gives a general introduction to Clojure and Typed Clojure,
then motivates the idea of automatically generating Typed Clojure annotations,
and finally describes clojure.spec along with some of its features.

\input{esop-intro}

\subsection{Automatic Type Annotations}

% - set the scene for inferring types
%   - Typed Clojure
%   - optional/gradual typing requires annotations

We now shift gears from introducing Typed Clojure to
addressing a major usability flaw that many
gradually and optionally typed languages share (including Typed Clojure):
writing type annotations is a \emph{manual} process.
%
Take \texttt{vertices} (below, written in Clojure)
a function that returnes the number of vertices
in a tree of tagged hash-maps.
As is good style, it comes with a unit test.
Our goal is to \textit{automatically generate} semi-accurate Typed Clojure %~\cite{bonnaire2016practical}
annotations
for this function, relieving most of the annotation
burden.

\begin{Verbatim}
(defn vertices [m]
  (case (:op m)
    :leaf 1
    :node (+ 1 (:left m) (:right m))))

(deftest test-vertices
  (is (= 3 {:op :node
            :left {:op :leaf :val 42} 
            :right {:op :leaf :val 24}})))
\end{Verbatim}

Our approach to automatic annotations features several stages.
First, we \textit{instrument} top-level functions.
Then, we \textit{exercise} the code by running its unit tests and \textit{observe}
the runtime behavior of the program.
If we pause at this point, we have collected enough data 
to generate a preliminary annotation:
%
\begin{Verbatim}
(ann vertices ['{:op ':node, :left '{:op ':leaf, :val Int}, :right '{:op ':leaf, :val Int}} -> Int]})
\end{Verbatim}
%
However, this type is too specific: trees are recursively defined
and the argument type is difficult to read and maintain.
To remedy this, we attempt to roll recursive-looking
types to be recursive from their example unrollings.
For example, below we have generalized the preliminary annotation's
depth 2 tree to the recursive \texttt{NodeLeaf}.
%
\begin{Verbatim}
(defalias NodeLeaf 
  (U '{:op ':node :left NodeLeaf :right NodeLeaf}
     '{:op ':leaf :val Int}))
(ann vertices [NodeLeaf -> Int])
\end{Verbatim}
%
%\begin{Verbatim}
%(declare Node Leaf)
%(defalias NodeLeaf (U Node Leaf))
%(defalias Node 
%  '{:op ':node :left NodeLeaf :right NodeLeaf})
%(defalias Leaf '{:op ':leaf :val int})
%(ann verbatim [NodeLeaf -> Int]})
%\end{Verbatim}
%
Now, if \texttt{NodeLeaf} is used in multiple positions
in the program, we don't want to repeat its definition multiple times.
Our type inference algorithm attempts merge recursive
types found throughout the program, reusing them in annotations.
For example,
if another function \texttt{sum-tree} accepts two
trees, we want reuse \texttt{NodeLeaf} in both annotations
like so:
%
\begin{Verbatim}
(ann vertices [NodeLeaf -> Int])
(ann sum-tree [NodeLeaf NodeLeaf -> NodeLeaf])
\end{Verbatim}

If minor variants of the recursive types occur
across a program,
we use optional \texttt{HMap} entries %~\cite{bonnaire2016practical}
to reduce redundancy.
%
\begin{Verbatim}
(defalias NodeLeaf 
  (U '{:op ':node :left NodeLeaf :right NodeLeaf}
     (HMap :mandatory {:op ':leaf :val Int}
           :optional {:label Str})))
\end{Verbatim}
%
After inserting these annotations, we can run the
type checker over them to check their usefulness.
Ideally, minimal changes will be needed to successfully type check
functions with the generated annotations,
mostly consisting of local function and loop annotations,
and renaming of type aliases.
Annotations should also be readable and minimize
redundancy, even when compared to hand-written annotations.
We will test this hypothesis with case studies
(\secref{sec:casestudy}).
%Generating and running \textit{tests} improved the quality
%of type annotations by exercising more paths through the
%program. %(Section \ref{experiment3})

\subsection{Automatic Annotation Approach}

Now that we have introduced the problem of automatic annotations and some
of its subtleties, we can flesh out our philosophy and overall approach.
At a high level, there are three phases to
generating annotations: instrumentation, runtime tracking, and type reconstruction.

The first phase, \textbf{instrumentation}, involves
rewriting the code we wish to annotate such
that we can record its runtime behavior.
In this phase, we usually require the programmer to
indicate which code we wish to generate types
for in advance, with a file-level granuality.

Once instrumented, we observe our running program
via \textbf{runtime tracking}. To exercise our programs,
we usually run their unit tests, generative tests,
or just normally run the program (eg. to generate types for
a game, we can simply play the game for a few minutes).
We accumulate the results of tracking via \textbf{paths}.
If we think of types as trees and supply a label
for each branching path, our inference results
specify the type down a particular path in this tree.

Finally, the information collected during runtime tracking
is combined into annotations by our \textbf{inference algorithm}.
We first combine all inference result into a large tree of
types. If we were to convert this tree into annotations directly,
our annotations would be too specific---they would be too
deep and fine-grained.
Instead, our algorithm iterates over several passes to massage
this tree, generating good names for the nodes, compacting similar
types across the tree, and
eventually converting the tree into a directed graph by reconstructing
recursive types.

%Let's demonstrate this pipeline, with our opening example.
%
%...
%
%\begin{verbatim}
%
%\end{verbatim}

An important question to answer is ``how accurate are these annotations?''.
Unlike some previous work in this area~\cite{An10dynamicinference}, we do not aim for soundness guarantees
in our generated types.
Our main contribution is a tool that Clojure programmers
can use to help learn about and specify their programs.
In that spirit, annotations should meet several criteria.

\paragraph{Good names}
Typed Clojure %and clojure.spec 
annotations are abundant
with useful names for types. A good name often increases
readability.
Good names can sometimes be reconstructed from the program source,
like function or parameter names, and other times 
we can use the shape of a type to summarize it.

\paragraph{Compact}
Idiomatic Clojure code rarely mixes certain types in the same position,
unless the program is polymorphic. Using this knowledge---which we observed
by the annotations and specs assigned to idiomatic Clojure 
code---we can rule out certain combinations of types to compact our
resulting output, without losing information that would help us
type check our programs.

\paragraph{Recursive}
Maps in Clojure are often heterogeneous, and recursively defined.
Typed Clojure %and clojure.spec 
supplies mechanisms for the most
common case: maps of known keyword entries.
We strategically \textbf{squash} flat types to be recursive
based on their unrolled shape.
For example, a recursively defined union of maps almost always
contains a known keyword ``tag'' mapped to a keyword.
By identifying this tag, we can reconstruct a good recursive
approximation of this type.

%\subsection{Naming}
%
%For a type to be immediately useful to a programmer, it helps
%to have a great name. We explored several avenues for
%generating good names.
%
%For types that occured as function arguments, the name of
%the argument often indicated its role in the program.
%Names like \textbf{config} or \textbf{env} are often used
%for an environment being functionally threaded through
%the program.
%
%Similarly, types that occur as values in configuration
%maps often have descriptive keys. In the Star Trek 
%game, the configuration map maps \textbf{:stardate}
%to a map that contains three number entries: 
%\textbf{:start},
%\textbf{:current}, and
%\textbf{:end}.
%
%What if a type occurs in the return position of a function?
%Sometimes these are named by \textbf{let} binding the result
%of the computation.
%
%Failing these heuristics, we fall back of several approaches
%to naming.
%First, if we are naming a keyword map which is part of a tagged
%union, we use the tag as the name. For example, if the tagged entry
%maps \textbf{:op} to \textbf{:fn}, we name this map \textbf{FnOp}.
%Failing that, for maps with less than three entries, we simply
%enumerate its entries as the name.
%Finally, for large keyword maps, we give an abbreviation
%of its keyset as a name.
%
%\begin{Verbatim}
%(defn f [x] (inc x))
%\end{Verbatim}

%\subsection{Overview of clojure.spec}
%
%This thesis claims that we can automatically generate annotations to other verification
%systems similar to Typed Clojure.
%We add a second usecase to strengthen our claim: generating annotations for \texttt{clojure.spec},
%a runtime verification library recently added to Clojure's core library.
%It resembles common approaches to runtime verification, such as Racket's contract
%system, but is different in several important ways.
%
%Firstly, \texttt{clojure.spec} is designed to treat most values as ``data at rest''. That is,
%at verification sites, values are eagerly traversed without waiting to see
%if or how the program actually uses them.
%When we consider that \texttt{clojure.spec} treats infinite streams
%and functions as data at rest, we begin to see the tradeoffs that have been
%made.
%
%Secondly, specifications (called ``specs'') are not enforced by default. Users must
%opt-in to enforcing specs via an explicit instrumentation phase.
%This is also different than most contract systems, many of which are enforced
%by default. There is no standard way to integrate spec enforcement into a
%test suite, so it is difficult to tell whether specific specs are primarily 
%unchecked documentation, or actually used for runtime verification.
%
%Since \texttt{clojure.spec} has a unique feature set amongst runtime verification
%libraries, it is interesting to consider how programmers use \texttt{clojure.spec}
%in practice. For example, do programmers find the semantics of treating functions
%as data at rest useful?
%
%%Unfortunately since specs are opt-in, it is difficult to
%%correlate someone writing a spec with that person \emph{using} the spec,
%%implying spec's semantics as being useful.
%%Nevertheless, in the following sections we attempt to draw conclusions about
%%spec's common usage based mostly on the frequency of spec annotations.
%
%\subsection{Function specifications in clojure.spec}
%
%We now give a brief introduction to what using clojure.spec is like,
%focussing on the semantics of the different kinds of function specifications
%it supports.
%
%(From here, we map the namespace prefix \texttt{s} to \texttt{clojure.spec.alpha},
%and \texttt{stest} to \texttt{clojure.spec.test.alpha}.)
%
%\begin{verbatim}
%(require '[clojure.spec.alpha :as s])
%(require '[clojure.spec.test.alpha :as stest])
%\end{verbatim}
%
%There are two kinds of function checking semantics in \texttt{clojure.spec}.
%We use \texttt{intmap}, a higher-order function that maps a function over 
%a collection of ints, to demonstrate both semantics.
%
%\begin{verbatim}
%(defn intmap
%  "Maps a collection of ints over a function."
%  [f c]
%  (map f c))
%\end{verbatim}
%
%If the programmer wants to write a higher-order function spec to
%verify \texttt{intmap}, they might write the following spec.
%
%\begin{verbatim}
%(s/fdef intmap
%  :args (s/cat :f (s/fspec :args (cat :x int?) :ret int?)
%               :c (s/coll-of int?))
%  :ret (s/coll-of int?))
%\end{verbatim}
%
%The \texttt{s/fdef} form signals we are annotating a top-level
%function, in this case \texttt{intmap}. Argument specs are
%provided with the \texttt{:args} keyword option
%in the form of the ``tagged'' heterogeneous collection spec
%\texttt{s/cat}---here 2 arguments are allowed, tagged as
%\texttt{:f} for the function and \texttt{:c} as the collection.
%
%The \texttt{s/fspec} spec is another kind of function spec,
%specifically for non-top-level functions (such as function arguments
%to top-level functions). It has a similar syntax to \texttt{s/fdef},
%but a function name is not provided.
%
%In a nutshell, \texttt{s/fdef} provides traditional proxy-based
%verification semantics while \texttt{s/fspec} uses eager \emph{generative testing}
%to exercise a function before letting it pass the spec boundary, bare (without a proxy).
%
%We will now demonstrate how the following call gets checked.
%
%\begin{verbatim}
%(intmap inc [1 2 3])
%;=> (2 3 4)
%\end{verbatim}
%
%First, the programmer instruments \texttt{intmap} with:
%
%\begin{verbatim}
%(stest/instrument `intmap)
%\end{verbatim}
%
%This mutates the top-level binding associated with \texttt{intmap}, wrapping a function
%proxy around the original value.
%
%Now, when checking \texttt{(intmap inc [1 2 3])}, the \texttt{inc} function is
%called several hundred times with generated values conforming to \texttt{int?},
%and checks each call returns an \texttt{int?}.
%Then, \texttt{[1 2 3]} is eagerly checked against \texttt{(s/coll-of int?)}.
%The original \texttt{intmap} function is then called with the original arguments,
%yielding a value \texttt{(2 3 4)}. Instrumentation does not check return value specs,
%so \texttt{(s/coll-of int?)} is ignored, and the original return value is passed to the calling
%context.
%
%\subsection{Automatic Annotations for clojure.spec}
%
%Having introduced \texttt{clojure.spec}, we now give an overview
%of how to repurpose our automatic annotation technology to generate specs.
%At a glance, the problems of generating annotations for Typed Clojure
%and \texttt{clojure.spec} are similar, and indeed we can reuse much
%of the machinery from our approach to generating Typed Clojure annotations.
%The differences lie mostly in the finally type reconstruction phase.
%
%There are several important components in \texttt{clojure.spec}'s
%philosophy and design that complicate its annotation story.
%First, \texttt{clojure.spec} does not support local key-type pairs
%in its heterogeneous map specification--instead you are forced
%to globally define map entries as \emph{spec aliases}.
%
%For example, the Typed Clojure type \clj{'\{:a Int\}} must be
%written \clj{(s/keys :req-un [:my-ns/a])}, along with the following
%global definition of the spec alias \clj{:my-ns/a}.
%\begin{verbatim}
%(s/def :my-ns/a int?)
%\end{verbatim}
%When \clj{(s/keys :req-un [:my-ns/a])} is checked against a value,
%it first locates the spec under \clj{:my-ns/a}, and (because
%we have declared the key to be \clj{:req-un}, that is, required
%but unqualified), we use the located \clj{int?} spec
%to check against the \clj{:a} entry of the value.
%Furthermore, if the key was declared as \clj{:req} instead of \clj{:req-un},
%the fully qualified keyword entry \clj{:my-ns/a} would be checked
%against \clj{int?}.
%This means that there is \emph{exactly one} spec for each fully
%qualified keyword entry.
%
%This raises several interesting design issues related to reusing
%specs that are very different from the simpler problem of generating
%Typed Clojure \clj{HMap} types. 
%How do we decide which namespace to register unqualified map entries?
%Should we assume similar looking keyword entries are in fact the same, and register their specs under the same namespace?
%How do we handle fully qualified keyword entries?
%
%The second component of

\section{Thesis Statement}

My thesis statement is:

\begin{quote}
Typed Clojure is a sound and practical optional type system for Clojure and the process of porting to Typed Clojure can be partially-automated, and this automation technology can be repurposed to further reveal how Clojure is used in real projects.
%Typed Clojure is a sound and practical optional type system for Clojure, and we can relieve the annotation burden for such verification systems by automatically annotating programs based on their runtime behavior.
%Typed Clojure is a sound and practical optional type system for Clojure whose annotation burden is partially-automatable, and this automation technology can be repurposed to generate clojure.spec annotations and test its effectiveness in hundreds of projects.
% to study how Clojure is used in real projects.
%Typed Clojure is sound, practical, and its annotation burden is partially-automatable,
%and we can repurpose this annotation technology to
%answer broad questions about how Clojure is used.
%Typed Clojure is a well-founded and practical optional type system for Clojure
%whose useability can be improved by
%developing a tool to automatically generate type annotations,
%and, by repurposing this tool, we can study general Clojure idioms and practices across
%hundreds of projects by generating, running, and exercising clojure.spec runtime specifications.
\end{quote}

I will support this thesis statement with the following:

\begin{itemize}
  \item \emph{Typed Clojure is sound} We formalize Typed Clojure, including
    its characteristic features like hash-maps, multimethods, and Java interoperability,
    and proven the model type sound.
  \item \emph{Typed Clojure is practical} We present an emperical study of real-world Typed Clojure usage
    in over 19,000 lines of code, showing its features correspond to actual usage patterns.
  \item \emph{Typed Clojure's annotation burden is partially-automatable} We formalize and implement a tool to generate
    type annotations, and emperically study the manual changes needed for the generated annotations
    to pass type checking.
  %\item \emph{clojure.spec model and Automatic Annotations} 
  \item \emph{Repurpose automation technology}
  %\item \emph{Repurpose automation technology}
  %\item \emph{clojure.spec spec's annotation burden is partially-automatable}
    We describe how to automatically generate clojure.spec annotations (``specs'') for existing programs by reusing
    most of the the infrastructure for automatic Typed Clojure annotations.
    We present a formal model of clojure.spec (an existing and popular runtime verification tool for Clojure)
    and implement the model in Redex.
  \item \emph{Study how Clojure is used in real projects}
    We conduct a study of general Clojure idioms and practices by generating, enforcing, and exercising specs
    across hundreds of projects, as well as analyzing design choices in Typed Clojure's type system,
    clojure.spec's features, and our automatic annotation tool.
  %\item \emph{Test effectiveness of clojure.spec annotation generation}
  %  We test the effectiveness of our generated specs by generating, enforcing, and exercising specs
  %  across hundreds of projects, as well as analyze design choices in Typed Clojure's type system and
  %  clojure.spec's features.


    % our annotation approach can be repurposed to generate clojure.spec which can be \emph{run}.
    % use results to explore both the quality of the tool and to explore what the inferred specs
    % tell us about clj programs.
\end{itemize}

\section{Technical Overview}

\input{esop-overview}

\input{esop-formal-model}

\input{esop-metatheory}

\subsection{Typed Clojure Evaluation}
\label{sec:casestudy}

\begin{figure*}[t]

\begin{tabular}{lll}
      \toprule


  & feeds2imap & CircleCI \\
  \midrule
  Total number of typed namespaces & 11 (825 LOC) & 87 (19,000 LOC) \\
  Total number of \clj{def} expressions & 93  & 1834 \\
  \tabitem
  checked & 52 (56\%) & 407 (22\%) \\
  \tabitem
  unchecked & 41 (44\%) & 1427 (78\%) \\
  Total number of Java interactions & 32 & 105 \\
  \tabitem
  static methods & 5 (16\%) & 26 (25\%) \\ 
  \tabitem
  instance methods & 20 (62\%) & 36 (34\%) \\
  \tabitem
  constructors & 6 (19\%) & 38 (36\%) \\
  \tabitem
  static fields & 1 (3\%) & 5 (5\%) \\
  Methods overriden to return non-nil & 0 & 35 \\
  Methods overriden to accept nil arguments & 0 & 1 \\
  Total HMap lookups & 27  & 328  \\
  \tabitem
  resolved to mandatory key & 20 (74\%) & 208 (64\%) \\
  \tabitem
  resolved to optional key & 6 (22\%) & 70 (21\%) \\
  \tabitem
  resolved of absent key & 0 (0\%) & 20 (6\%) \\
  \tabitem
  unresolved key & 1 (4\%) & 30 (9\%) \\
  Total number of \clj{defalias} expressions & 18  & 95 \\
  \tabitem
  contained HMap or union of HMap type & 7 (39\%)  & 62 (65\%) \\
  Total number of checked \clj{defmulti} expressions & 0  & 11 \\
  Total number of checked \clj{defmethod} expressions & 0  & 89 \\


\end{tabular}
\caption{Typed Clojure Features used in Practice}
\label{experience:featuretable}
\end{figure*}

Throughout this thesis, we will focus on three interrelated type
system features: heterogeneous maps, Java interoperability, and
multimethods. Our hypothesis is that these features are widely used in
existing Clojure programs in interconnecting ways, and that handling
them as we have done is required to type check realistic Clojure
programs.

To evaluate this hypothesis, we will present an analysis of two existing \coretyped{}
code bases, one from the open-source community, and one from a company
that uses \coretyped{} in production (\figref{experience:featuretable}).
%For our data gathering, we
%instrumented the \coretyped{} type checker to record how often
%various features were used (summarized in \figref{experience:featuretable}).


\subsection{Automatic Annotations}

We provide a preliminary grammar for our formal treatment of automatic
annotations, and a semantics for the instrumentation phase
of our automatic annotator.
The full thesis will describe the type reconstruction algorithm in
detail.

\figref{infer:grammar} presents the grammar. Similar to Typed Clojure's
formalism, we use paths $\inferpath{}$ to represent a path through
a value. Path elements consist of the domain of a function $\dompe{}$,
the range of a function $\rngpe{}$, and the result of a map lookup 
of key ${\kw2{}}$ on a map with key set ${\overrightarrow{\kw1{}}}$
$\inferkeype{\overrightarrow{\kw1{}}}{\kw2{}}$.
Inference results $\res{}$ are collected during execution, and
associate a path $\inferpath{}$ with the type of value observed
at that path $\tau$.

\figref{infer:semantics} gives a semantics for the instrumentation
phase of the automatic annotation tool.
Most rules are standard, with B-Get and B-Assoc responsible for
looking up and associating new entries onto maps.
The B-Track rule is the entry point for tracking values,
calling $\trackmeta{}$ (\figref{infer:track}), that
rewrites a value $\val{}$ to $\val{}'$ and generates inference
results $\res{}'$ based on the input that $\inferpath{}$
is the path of $\val{}$.

\input{infer-grammar}
\input{infer-semantics}
\input{infer-track}

\section{Related Work}

% Cite a few of the early papers here.
%http://www.cs.washington.edu/research/projects/cecil/www/pubs/
\paragraph{Typed Multimethods} 
Millstein and collaborators present a sequence of
systems~\cite{Chambers:1992:OMC,Chambers:1994:TMM,MS02} with statically-typed multimethods
and modular type checking.  In contrast to Typed Clojure, in these
system methods declare the types of arguments that they expect which
corresponds to exclusively using \clj{class} as the dispatch function
in Typed Clojure. However, Typed Clojure does not attempt to rule out
failed dispatches.

% one sentence
% TC based on TR, already covered

\paragraph{Occurrence Typing} 
Occurrence typing~\cite{TF08,TF10} extends the type 
system with a \emph{proposition environment} that represents 
the information on the types of bindings down conditional branches.
These propositions are then used to update the types associated
with bindings in the \emph{type environment} down branches
so binding occurrences are given different types 
depending on the branches they appear in, and the conditionals
that lead to that branch.

% What's diff about TC from the related work
% small summary for deisel....
% - diesel supports x
%- - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wand89typeinference,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

TeJaS~\cite{TeJaS}, another type system for JavaScript,
also supports similar HMaps, with the ability to
record the presence and absence of entries, but lacks a compositional
flow-checking approach like occurrence typing.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

\paragraph{Java Interoperability in Statically Typed Languages}
Scala~\cite{OCD+} has nullable references for compatibility with Java.
Programmers must manually check for
\java{null} as in Java to avoid null-pointer exceptions. 


\paragraph{Other optional and gradual type systems}
%In addition to Typed Racket, 
Several other gradual type
systems have been developed for existing
dynamically-typed languages.  Reticulated Python~\cite{Vitousek14} is
an experimental gradually typed system for Python, implemented as a
source-to-source translation that inserts dynamic checks at language
boundaries and supporting Python's first-class object system. 
Clojure's nominal classes avoids the need to support
first-class object system in Typed Clojure, however HMaps offer an alternative to
the structural objects offered by Reticulated. Similarly,
Gradualtalk~\cite{gradualtalk} offers gradual typing for Smalltalk,
with nominal classes.

Optional types
%, requiring less implementation effort and avoiding
%runtime cost, 
have been  adopted in industry, including Hack~\cite{hack}, and Flow~\cite{flow} and
TypeScript~\cite{typescript}, two extensions of JavaScript. These
systems  support  limited forms of occurrence typing,
and do not include the other features we
present.

\paragraph{Automatic annotations}
There are two common implementation strategies for such tools. The first
strategy, ``ruling-out'' (for invariant detection), assumes all invariants are true 
and then use runtime analysis results to rule out
impossible invariants. The second ``building-up'' strategy (for dynamic type inference)
assumes nothing and then uses runtime analysis results to build up invariant/type knowledge.

Examples of invariant detection tools include Daikon \cite{Ernst06thedaikon},
DIDUCE \cite{hangal2002tracking}, and Carrot \cite{pytlik2003automated}, and
typically enhance statically typed languages with more expressive types or contracts.
Examples of dynamic type inference include Rubydust \cite{An10dynamicinference},
JSTrace \cite{saftoiu2010jstrace}, and TypeDevil \cite{pradel2015typedevil},
and typically target untyped languages.

Both strategies have different space behavior with respect to representing
the set of known invariants.
The ruling-out strategy typically uses a lot of memory at the beginning,
but then can free memory as it rules out invariants. For example, if
\texttt{odd(x)} and \texttt{even(x)} are assumed, observing \texttt{x = 1}
means we can delete and free the memory recording \texttt{even(x)}.
Alternatively, the building-up strategy uses the least memory storing
known invariants/types at the beginning, but increases memory usage
as more the more samples are collected. For example, if we know
\texttt{x : Bottom}, and we observe \texttt{x = "a"} and \texttt{x = 1}
at different points in the program, we must use more memory to
store the union \texttt{x : String $\cup$ Integer} in our set of known invariants.

\paragraph{Daikon}
Daikon can reason about very expressive relationships between variables
using properties like ordering ($x < y$), linear relationships ($y = ax + b$),
and containment ($x \in y$). It also supports reasoning with ``derived variables''
like fields ($x.f$), and array accesses ($a[i]$).

Typed Clojure's dynamic inference can record heterogeneous data structures
like vectors and hash-maps, but otherwise cannot express relationships
between variables.

There are several reasons for this. The most prominent is that Daikon
primarily targets Java-like languages, so inferring simple type information
would be redundant with the explicit typing disciplines of these languages.
On the other hand, the process of moving from Clojure to Typed Clojure
mostly involves writing simple type signatures without dependencies
between variables. Typed Clojure recovers relevant dependent information
via occurrence typing, and gives the option to manually annotate necessary
dependencies in function signatures when needed.

%TODO \paragraph{TypeScript Annotation Generation} ..
% Inference and Evolution of TypeScript Declaration Files
% - they submit pull requests from their tool's output
% https://cs.au.dk/~amoeller/papers/tstools/paper.pdf

\section{Research Plan and Timeline}

I have already made progress towards my thesis:

\begin{itemize}
  \item I have formalized Typed Clojure, including
    its characteristic features like hash-maps, multimethods, and Java interoperability,
    and prove the model type sound.
  \item I have conducted an emperical study of real-world Typed Clojure usage
    in over 19,000 lines of code, showing its features correspond to actual usage patterns.
  \item I have implemented and publicly released a tool that generates
    Typed Clojure and clojure.spec annotations, and started on a formalism.
  \item I have started an emperical study the of manual changes needed for the generated annotations
    to pass type checking is in progress.
  \item I have successfully run my clojure.spec annotation tool on several hundred open-source projects that
    will be used to drive further studies.
\end{itemize}

To complete my thesis, I plan to follow this timeline:

\begin{itemize}
  \item \textbf{[June-July 2018]} Fix spec generation.
    \begin{itemize}
      \item devise and implement a one or more strategies to handle clojure.spec's
        heterogeneous map spec (and intelligently register global spec aliases)
      \item test out specs generation on candidate projects and improve the tool to fix obvious
        defects
    \end{itemize}
  \item \textbf{[July-August 2018]} Finish formal model of annotation tool.
    \begin{itemize}
      \item update formal model for annotation tool to include latest
        optimizations and fixes in recursive type reconstruction.
    \end{itemize}
  \item \textbf{[August-September 2018]} Devise and carry out automatic annotation experiments
    \begin{itemize}
      \item formulate and complete larger scale study on generation of specs for hundreds of projects.
    \end{itemize}
  \item \textbf{[September-November 2018]} Write paper (PLDI submission)
  \item \textbf{[November 2018-May 2019]} Write dissertation
  \item \textbf{[June 2019]} Defend
\end{itemize}

\subsection{Publications}

I plan to publish the following papers:

\begin{itemize}
  \item \textbf{ESOP 2016 - Published} \emph{Practical Optional Types for Clojure}~\cite{bonnaire2016practical}.
    A paper that provides a formal model of Typed Clojure and presents an emperical
    study of usage patterns.
  \item \textbf{Spring 2018} \emph{Squash the work: Automatic annotations for Typed Clojure and clojure.spec}
    A paper that presents a tool capable of generating Typed Clojure and clojure.spec
    annotations based on runtime observations of the program.
    We present a formal model of the tool, as well as several manual experiments in how
    accurate our annotations are.
    We conduct a larger study by sourcing several hundred projects and automatically
    generating types and specs, then using these annotations to answer various questions
    about how clojure.spec and Clojure is used.
\end{itemize}


\printbibliography

\end{document}
