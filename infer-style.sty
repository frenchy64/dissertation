% macros for Clojure grammars
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{mmm}

\newcommand\specialformfont[1]{\ma{\textbf{#1}}}
\newcommand\trackEOp[0]{\ma{\specialformfont{track}}}
\newcommand\trackE[2]{\ma{({\trackEOp{}}\ #1\ #2)}}
\newcommand\trackpolyE[3]{({\specialformfont{trackPoly}}\ #1\ #2\ #3)}
\newcommand\genE[0]{({\specialformfont{genInt}})}
\newcommand\inferletliteral[0]{{\specialformfont{let}}}
\newcommand\PairOfT[1]{{\mathsf{PairOf}}}
\newcommand\NatT[1]{{\mathsf{N}}}
\newcommand\IntT[1]{\ma{\mathsf{N}}}
\newcommand\UnknownT[1]{\ma{\mathrm{?}}}
\newcommand\HMapOp[0]{\ma{\mathsf{HMap}}}
\newcommand\HMaptwo[2]{\ma{(\HMapOp{}_{#2}^{#1})}}
\newcommand\HMapsplice[1]{\ma{(\HMapOp{}\ #1)}}
\newmeta\HMapreq{\ma{m}}
\newmeta\HMapreqp{\ma{m'}}
\newmeta\HMapopt{\ma{o}}
\newmeta\HMapoptp{\ma{o'}}
\newcommand\HMappretty[1]{\ma{\{#1\}}}
\newcommand\appendone[2]{#1 :: [#2]}
\newcommand\append[2]{#1 :: #2}
\newcommand\Proxy[0]{\specialformfont{Proxy}}
\newcommand\ProxyE[3]{(\Proxy{}\ #1\ #2\ #3)}
% types
\newcommand\arrow[2]{\ma{[#1 \rightarrow #2]}}
\newmeta\ty{\tau}

% semantics
\newcommand\opsemtrack[4]{\ma{#1 \vdash #2 \Downarrow #3\ ; #4}}
\newcommand\bigstepgen[6]{\ma{#1 ; #2 \vdash #3 \Downarrow #4\ ; #5 ; #6}}

% environments
\newmeta\aenv{\ma{A}}
\newmeta\aenvp{\ma{A'}}
\newmeta\tenv{\ma{\Gamma}}
\newmeta\atenv{\ma{\Delta}}
\newmeta\atenvp{\ma{\Delta'}}
\newcommand\emptytenv[0]{\ma{\{\}}}
\newcommand\emptyaenv[0]{\ma{\{\}}}
\newcommand\makeatenv[2]{\ma{(#1, #2)}}
\newcommand\emptyatenv[0]{\ma{\makeatenv{\emptyaenv{}}{\emptytenv{}}}}

%arrows
\newcommand\ova[1]{\ma{\overline{#1}}}

%env update
\newcommand\updatemap[3]{\ma{#1 [#2 \mapsto #3]}}

% algorithm
\newcommand\infermetafnfont[1]{\ma{\mathsf{#1}}}
\newcommand\squashlocal[0]{\ma{\infermetafnfont{squashLocal}}}
\newcommand\steptwohelper[0]{\ma{\infermetafnfont{h}}}
\newcommand\squashglobal[0]{\infermetafnfont{squashGlobal}}
\newcommand\aliashmap[0]{\infermetafnfont{aliasHMap}}
\newcommand\inferrecOp[0]{\infermetafnfont{inferRec}}
\newcommand\squashall[0]{\infermetafnfont{squashAll}}
\newcommand\squash[0]{\infermetafnfont{squash}}
\newcommand\trymergealias[0]{\infermetafnfont{mergeAlias}}
\newcommand\deepkeysets[0]{\infermetafnfont{keysets}}
\newcommand\aliasesin[0]{\infermetafnfont{aliasesIn}}
\newcommand\squashhorizonally[0]{squashHorizontally} %% TODO needs definition!
\newcommand\aliassinglehmap[0]{aliasSingleHMap}      %% TODO needs definition!
\newcommand\inferanns[0]{\ma{\infermetafnfont{infer}}}
\newcommand\inferannsnoalign[2]{\ma{\inferanns{}(#1) = #2}}
\newcommand\generatetenv[0]{\ma{\infermetafnfont{toEnv}}}
\newcommand\genupdate[0]{\ma{\infermetafnfont{genUpdate}}}
\newcommand\trackmetaOp[0]{\ma{\infermetafnfont{track}}}
\newcommand\trackmeta[4]{\ma{\trackmetaOp{}(#1, #2) = #3\ ; #4}}
\newcommand\trackmetaalign[4]{\ma{\trackmetaOp{}(#1, #2) &=& #3\ ; #4}}
\newcommand\trackpolymeta[0]{\ma{\infermetafnfont{trackPoly}}}
\newcommand\inferupdateOp[0]{\ma{\infermetafnfont{update}}}
\newcommand\inferupdate[3]{\inferupdateOp{}(#1, \resentry{#2}{#3})}
\newcommand\inferupdatecommon[5]{\inferupdate{#1}{#2}{#3} #4  #5} % takes the = sign to allow extra alignment
\newcommand\inferupdatenoalign[4]{\ma{\inferupdatecommon{#1}{#2}{#3}{=}{#4}}}
\newcommand\inferupdatealign[4]{\inferupdatecommon{#1}{#2}{#3}{&=&}{#4}}
\newcommand\joinOp[0]{\ma{\sqcup}}
\newcommand\joinlhs[2]{\ma{#1 \joinOp{} #2}}
\newcommand\joinalign[3]{\joinlhs{#1}{#2} &=& #3}
\newcommand\joinnoalign[3]{\ma{\joinlhs{#1}{#2} = #3}}
\newcommand\joinexpression[2]{\joinlhs{#1}{#2}}
\newcommand\joinHMapOp[0]{\ma{\sqcup^{\infermetafnfont{H}}}}
\newcommand\joinHMaplhs[2]{\ma{#1 \joinHMapOp{} #2}}
\newcommand\joinHMapnoalign[3]{\ma{\joinHMaplhs{#1}{#2} = #3}}
\newcommand\joinHMapexpression[2]{\ma{\joinHMaplhs{#1}{#2}}}
\newcommand\joinstarOp[0]{\ma{\bigsqcup}}
\newcommand\joinstaralign[2]{\ma{\joinstarOp{} #1  &=& #2}}
\newcommand\joinstarnoalign[2]{\ma{\joinstarOp{} #1  = #2}}
\newcommand\joinstarexpression[1]{\ma{\joinstarOp{} #1 }}
\newcommand\instrumentOp[0]{\ma{\infermetafnfont{instrument}}}
\newcommand\instrumentnoalign[3]{\ma{\instrumentOp{}(#1, #2) = #3}}
\newcommand\instrument[2]{\ma{\instrumentOp{}(#1, #2)}}
\newcommand\collectOp[0]{\ma{\infermetafnfont{collect}}}
\newcommand\collectnoalign[3]{\ma{\collectOp{}(#1, #2) = #3}}
\newcommand\annotateOp[0]{\ma{\infermetafnfont{annotate}}}
\newcommand\annotatenoalign[3]{\ma{\annotateOp{}(#1, #2) = #3}}

% aliases
\newmeta\alias{a}
\newmeta\aliasp{a'}
\newmeta\aliaspp{a''}

% expressions
\newmeta\val{v}
\newmeta\kw{k}
\newmeta\kwp{k'}
\newmeta\xvar{x}
\newmeta\yvar{y}
\newmeta\num{n}

% abstract syntax for pathelem
\newmeta\pth{l}
\newcommand\inferpefont[1]{\textbf{#1}}
\newcommand\keypeOp[0]{\ma{\inferpefont{key}}}
\newcommand\inferkeype[2]{\ma{\keypeOp{}_{#1}(#2)}}
\newcommand\inferkeypenokeyset[2]{\ma{\keypeOp{}(#2)}}
\newcommand\dompe[0]{\ma{\inferpefont{dom}}}
\newcommand\rngpe[0]{\ma{\inferpefont{rng}}}

% abstract syntax for paths
\newmeta\inferpath{\ma{\pi}}

% inference results
\newmeta\res{\ma{r}}
\newmeta\resp{\ma{r'}}
\newcommand\emptyres[0]{\ma{\{\}}}
\newcommand\resentry[2]{\ma{{#2}_{#1}}}
\newcommand\singletonres[2]{\ma{\{\resentry{#1}{#2}\}}}
\newcommand\resflat[1]{\ma{\{#1\}}}
\newcommand\resflatcolor[1]{\ma{\textcolor{red}{\resflat{#1}}}}
\newcommand\restwoarrow[2]{\ma{\{\overrightarrow{\resentry{#1}{#2}}\}}}
\newcommand\unionres[2]{\ma{{#1 \sqcup #2}}}
\newcommand\bigunionres[1]{\ma{\overrightarrow{\sqcup\ #1}}}
\newcommand\unionresthree[3]{\ma{{#1 \sqcup \unionres{#2}{#3}}}}

\newcommand\lambdatrack[0]{\ma{\lambda_{\trackmetaOp{}}}}
