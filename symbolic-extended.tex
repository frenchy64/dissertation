\chapter{Recursive types and Intersection types}

\subsection{Compiling to \ltiFsub}

There are a least two ways to approach our external language
with symbolic closures compiling to \ltiFsub.
The main challenge and incentive is to remove all symbolic
closure types from our program and to replace them with
explicit annotations.
Our first approach is to copy function code and annotate
parameter types at each usage.
This approach seems promising, except there is a tension between
copying function code and creating runtime closures.
Our second approach is to extend \ltiFsub with intersection types
and ascribe each function an intersection type that 
describes all the ways it was used as a symbolic closure.

We now explore our first approach, to copy function code as they
are checked.
First, for those functions ascribed symbolic closure types, we
copy their code and insert them at their usage sites.
For example, \clj{f} in 

\begin{cljlisting}
(let [f (fn [x] x)]
  (f 1)
  (f "a"))
\end{cljlisting}

would be given a symbolic closure type, and
the program would be expanded like so:

\begin{cljlisting}
(let [f (fn [x] x)]
  ((fn [x] x) 1)
  ((fn [x] x) "a"))
\end{cljlisting}

First, we notice that all occurrences of \clj{f} have disappeared,
so it is safe to assume \clj{f} will never be called. It seems
reasonable to us to annotate its argument as \clj{Bot}.

\begin{cljlisting}
(let [f (fn [x :- Bot] x)]
  ((fn [x] x) 1)
  ((fn [x] x) "a"))
\end{cljlisting}

Next, the two unannotated functions would be checked as symbolic closures.
These checks would succeed, and then we could ascribe a parameter type on
each function.

\begin{cljlisting}
(let [f (fn [x :- Bot] x)]
  ((fn [x :- Int] x) 1)
  ((fn [x :- Str] x) "a"))
\end{cljlisting}

This program type checks with the rules of \ltiFsub.
However, subtle variations on this program are much
more puzzling to account for.

If \clj{f} closes over a variable, like \clj{v}
here

\begin{cljlisting}
(let [f (let [v 1] (fn [x] (print v) x))]
  (f 1)
  (f "a"))
\end{cljlisting}

then simply copying its function code will
not suffice.
If we do so, \clj{v} is no longer in scope:

\begin{cljlisting}
(let [f (let [v 1] (fn [x] (print v) x))]
  ((fn [x] (print v) x) 1)
  ((fn [x] (print v) x) "a"))
\end{cljlisting}

We could imagine inlining the value of 
\clj{v} to work around this issue, but this is not a
full solution.
If instead, \clj{v} was an annotated function parameter
as in the next example

\begin{cljlisting}
(let [f (fn [v :- Int]
          (fn [x] (print v) x))]
  ((f 42) 1)
  ((f 42) "a"))
\end{cljlisting}

it's even unclear how to inline the
unannotated function at all.
It seems the only choice is to inline \clj{f}
in its entirety, regardless if it was a symbolic closure.

\begin{cljlisting}
(let [f (fn [v :- Int]
          (fn [x] (print v) x))]
  (((fn [v :- Int]
      (fn [x] (print v) x))
    42)
   1)
  (((fn [v :- Int]
      (fn [x] (print v) x))
    42)
   "a"))
\end{cljlisting}

This way we can at least annotate the missing \clj{Int} and \clj{Str}
parameter types.
It is now tempting to inline \emph{all} local variables with their
definitions.
This doesn't work in a language with side effects.
For example, inlining \clj{f} to ``fix'' the issues
in one of our previous examples would repeat side
effects, like printing \clj{"I only print once"} in the following
program (it, instead, prints thrice if \clj{f} is inlined).

\begin{cljlisting}
(let [f (let [v 1]
          (print "I only print once.")
          (fn [x] (print v) x))]
  (f 1)
  (f "a"))
\end{cljlisting}

Symbolic closures can also get their types by being passed
to annotated functions.
For example, \clj{id}
gets the type \clj{[Int -> Int]}
by being passed to \clj{f}, whose definition we will treat
as opaque, emulating a top-level function.

\begin{cljlisting}
(let [f (fn [g :- [Int -> Int]] ...)
      id (fn [x] x)]
  (f id))
\end{cljlisting}

By inlining \clj{id} and annotating its parameter \clj{Int},
this program does not pose any particular challenge.

\subsubsection{Intersection types}

If we allow ordered function intersection types,
featured in several optional type systems,
we arrive at an impasse.
Here, we assert that \clj{g} must \emph{both}
be
\clj{[Int -> Int]}
and
\clj{[Num -> Num]}.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (fn [x] x)]
  (f id))
\end{cljlisting}

Clearly \clj{id} inhabits both these types,
however attempting to inline its definition
gets us nowhere.
Introducing intersection types gives us
one more trick up our sleeve: ascribing
\clj{id} as an \emph{intersection} of function types.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (fn [x :- Bot] x)]
  (f (ann (fn [x] x)
          (IFn [Int -> Int]
               [Num -> Num]))))
\end{cljlisting}

This seems to help immensely, but now it seems a waste
to inline \clj{id} at all.
Instead, we could simplify this program by only annotating \clj{id}'s
right-hand-side.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Num -> Num])] ...)
      id (ann (fn [x] x)
              (IFn [Int -> Int]
                   [Num -> Num]))]
  (f id))
\end{cljlisting}

We can use this technique to help check our previous examples
without having to work around closed-over variables.
For example, our thrice-printing example requires
a single intersection type annotation, based on
the two symbolic reductions of \clj{f}.

\begin{cljlisting}
(let [f (let [v 1]
          (print "I only print once.")
          (ann (fn [x] (print v) x)
               (IFn [Int -> Int]
                    [Str -> Str])))]
  (f 1)
  (f "a"))
\end{cljlisting}

Unfortunately, inferring ordered intersection types for unannotated
functions introduce other issues,
most prominently determining the ``best'' ordering of
arities.

Compared to unordered intersections, ordered intersections
have a simple application rule: first arity wins.
A ``best'' ordering would yield the same or more accurate return type
for every possible application, compared to every other ordering.
For now, we assume that a best ordering
exists for every ordered function intersection type, although
we are not sure.

There are several interesting cases we sketch to give an idea
of the character of this algorithm.
First, if arity 1's domain is a subtype of arity 2's
domain, then arity 1 should come first,
using subtyping of the range to break ties in a similar fashion.
For example, \clj{[Int -> Int]}
goes before  \clj{[Num -> Int]},
but
\clj{[Int -> Int]}
precedes
\clj{[Int -> Num]}.
Second, if the domains of two arities
are incomparable via subtyping, their ordering does not matter.
For example,
\clj{[(Pair Int Num) -> Int]},
\clj{[(Pair Num Int) -> Num]},
and
\clj{[Int -> Num]}
may occur in any order in relation to each other.
This also accounts for multiple arguments,
by considering them as a list passed to a single argument.

Going back to checking programs, we now explore some
other ways in which inferring ordered function intersections has
interesting interactions with \ltiFsub.
The next example is similar to the one that helped motivate
intersection types earlier, except we omit the annotation
on \clj{f}.

\begin{cljlisting}
(let [f (fn [g]
          (g 1)
          (g "a"))
      id (fn [x] x)]
  (f id))
\end{cljlisting}

Here, the annotation on \clj{g} is the interesting part.

\begin{cljlisting}
(let [f (fn [g :- (IFn [Int -> Int] [Str -> Str])]
          (g 1)
          (g "a"))
      id (ann (fn [x] x)
              (IFn [Int -> Int] [Str -> Str]))]
  (f id))
\end{cljlisting}

Unfortunately, we can't retroactively annotate all programs in this way.
Take the following program.

\begin{cljlisting}
(let [f (fn [g]
          (fn [x]
            (g x)))]
  ((f (fn [y] y)) 1)
  ((f (fn [z] z)) "a"))
\end{cljlisting}

Ideally, we would give \clj{f} the polymorphic type
\clj{(All [a] [[a -> a] -> [a -> a]])}.
Then, we would use the type variable to annotate its return
as \clj{[a -> a]}.
Instead, we infer \clj{f} as type

\begin{cljlisting}
(IFn [[Int -> Int] -> [Int -> Int]]
     [[Str -> Str] -> [Str -> Str]])
\end{cljlisting}

This means that \clj{f}'s body will be checked twice.
The first time, \clj{g} will be assumed \clj{[Int -> Int]},
and then return checked as \clj{[Int -> Int]}.
The second, \clj{g} will be assumed \clj{[Str -> Str]},
and then return checked as \clj{[Str -> Str]}.

The problem now is annotating the function in \clj{f}'s body once-and-for-all.
It inhabits the type \clj{(U [Int -> Int] [Str -> Str])},
but that is too broad to be compatible with \clj{f}'s return---on the other hand,
it does not inhabit \clj{(IFn [Int -> Int] [Str -> Str])},
because \clj{g} cannot accept both \clj{Int} and \clj{Str}.
To handle these cases, we borrow \emph{conditional types} from TypeScript.

A conditional type is type-level dependency between types.
It is of the form \clj{(if (subtype? S T) U V)},
and returns type \clj{U} if \clj{S} is a subtype of \clj{T},
and \clj{V} otherwise.
This construct is particularly useful in combination with
the ability to reference the types of \emph{variables}.
In TypeScript, the type \clj{typeof f} resolves to the type of \clj{f}
in the current type environment. Here, we equivalently write \clj{(TypeOf f)}.

Applying these new type constructs to our example, we get the following annotation:

\begin{cljlisting}
(let [f (ann (fn [g]
               (fn [x :- (if (subtype? (TypeOf g) [Int -> Int]) Int Str)]
                 (g x)))
             (IFn [[Int -> Int] -> [Int -> Int]]
                  [[Str -> Str] -> [Str -> Str]]))]
  ((f (fn [y :- Int] y)) 1)
  ((f (fn [z :- Str] z)) "a"))
\end{cljlisting}

Now when \clj{f}'s first function type is checked,
\clj{g} will be of type \clj{[Int -> Int]}, which annotates
\clj{x} as \clj{Int}.
Correspondingly for the second function type,
\clj{g} will be of type \clj{[Str -> Str]}, which annotates
\clj{x} as \clj{Str} via the conditional type's else-branch.
We note that special consideration of variable shadowing is required when using \clj{TypeOf}---for
example, if \clj{g} was shadowed above, we would be branching on the wrong type.

\subsubsection{Polymorphism}

We have not addressed how symbolic closures interact with polymorphic types.
For now, we consider a restricted subset of polymorphic functions, but which happens to be
common in Clojure code.
Anecdotally, they are higher-order functions that take in functions cannot be iterated.

For example, the \clj{map} function is roughly of type:

\begin{cljlisting}
(All [a b]
  [[a -> b] (Seqable a) -> (Seqable b)])
\end{cljlisting}

We can immediately see the data flow by the occurrences of type variables.
The function argument takes an \clj{a} from the collection argument,
and then returns a \clj{b} to the return collection.
The function argument cannot be called on its own output in the body
of \clj{map} because \clj{b} is not compatible with \clj{a}.
We can draw these dependencies as arrows---notice that there is no arrow
from \clj{b} to \clj{a}. There are implicit dependencies from
\clj{a} to \clj{b} because everything to the right of an arrow type depends
on everything to the left of the arrow (or, output values depend
on input values).


\begin{lstlisting}
(All [a b]
  [[(*@\tikz[overlay,remember picture] \node [] (b) {};@*)a -> (*@\tikz[overlay,remember picture] \node [] (c) {};@*)b] (Seqable (*@\tikz[overlay,remember picture] \node [] (a) {};@*)a) -> (Seq (*@\tikz[overlay,remember picture] \node [] (d) {};@*)b)])
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay,
                  text width = 2.5cm ]
  \coordinate (Start1) at (a);
  \coordinate (End1) at (b);
  \coordinate (Start2) at (c);
  \coordinate (End2) at (d);
  \draw[red,->,bend right=-45](Start1.south) to (End1.east);
  \draw[blue,->,bend right=-45](Start2.east) to (End2.north east);
\end{tikzpicture} 

Inferring the data flow is crucial to checking symbolic closures.
Take the following example, where the function argument is inferred
as a symbolic closure.

\begin{cljlisting}
(map (fn [x] x) [1 2 3])
\end{cljlisting}

We now have two jobs: to infer the type arguments to \clj{map}
and to infer the type of \clj{x}.
Both can be found simultaneously by solving constraints
to find optimal instantiations for \clj{a} and \clj{b}.
First, we collect the constraints that make
\clj{(Closure \{\} (fn [x] x))}
a subtype of
\clj{[a -> b]}.
By checking the function with annotations
\clj{(fn [x :- a] x)},
we know that \clj{a} flows into \clj{b}, so
we get the constraint
\clj{Bot <: a <: b}.
For the second argument to \clj{map}
we infer
\clj{Int <: a <: Top}.
Since both type variables occur invariantly, we use their smallest instantiations,
so the optimal solution to these constraints
is \clj{a = Int, b = Int}.
We use this substitution to both
both provide the type arguments to \clj{map} (via \clj{inst})
and function argument (by substituting away the \clj{a} that
exercised the symbolic closure).


\begin{cljlisting}
((inst map Int Int) (fn [x :- Int] x) [1 2 3])
\end{cljlisting}

We can combine this inference technique with the same approach
we used to check our previous let-bound function examples,
like in the following code.

\begin{cljlisting}
(let [f (fn [x] x)]
  (map f [1 2 3])
  (map f ["a" "b" "c"]))
\end{cljlisting}

Here, we infer type arguments for each usage of \clj{map},
and combine the information collected for \clj{f} from both
inferences into an intersection type, yielding:

\begin{cljlisting}
(let [f (ann (fn [x] x)
             (IFn [Int -> Int]
                  [Str -> Str]))]
  ((inst map Int Int) f [1 2 3])
  ((inst map Str Str) f ["a" "b" "c"]))
\end{cljlisting}

Furthermore, this approach plays nicely with inferring conditional types,
like in the next example:

\begin{cljlisting}
(let [f (fn [g]
          (fn [x]
            (map g x)))]
  ((f (fn [y] y)) [1 2 3])
  ((f (fn [z] z)) ["a" "b" "c"]))
\end{cljlisting}

Now we must both infer an annotation for \clj{x} and
the type arguments to \clj{map}, but, as
in example motivating conditional types,
this is aggravated by \clj{f} being given a
intersection type, and thus forcing its body to be checked twice.
The solution is to to use more conditional types, particularly
as in the instantiation of \clj{map}:

\begin{cljlisting}
(let [f (ann (fn [g]
               (fn [x :- (Seqable (if (subtype? (TypeOf g) [Int -> Int]) Int Str))]
                 ((inst map
                        (if (subtype? (TypeOf x) (Seqable Int)) Int Str)
                        (if (subtype? (TypeOf x) (Seqable Int)) Int Str))
                  g x)))
             (IFn [[Int -> Int] -> [(Seqable Int) -> (Seqable Int)]]
                  [[Str -> Str] -> [(Seqable Str) -> (Seqable Str)]]))]
  ((f (fn [y :- Int] y)) [1 2 3])
  ((f (fn [z :- Str] z)) ["a" "b" "c"]))
\end{cljlisting}

\subsubsection{Inferring Conditional types}

The most attractive use of conditional types is to check the
same piece of code at different types.

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltifuntparaminterface{\ova{\ltitvar{}}}
                                               {\ova
                                                {\ltistackmapping{\ltiEnv{}}
                                                                 {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiT{}}}}}}}
                                               {\ltivar{}}
                                               {\ltiE{}}
                         \alt
                         \ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}{\ltiE{}} \alt
                      &\mbox{Terms} \\
  \ltiappinst{\ltiF{}}{\ova{\ltiR{}}}{\ltiE{}} &\Leftrightarrow&
         \ltiappinst{\ltiF{}}{\ltistackmapping{\ltiEmptyEnv{}}{\ova{\ltiR{}}}}{\ltiE{}}\\
   \ltifuntparaminterface{\ova{\ltitvar{}}}
                         {\ltiT{}}
                         {\ltivar{}}
                         {\ltiE{}}
         &\Leftrightarrow&
   \ltifuntparaminterface{\ova{\ltitvar{}}}
                         {\ltistackmapping{\ltiEmptyEnv{}}{\ltiT{}}}
                         {\ltivar{}}
                         {\ltiE{}}
                      &\mbox{Term abbreviations} \\
  \ltiT{}, \ltiS{}, \ltiR{} &::=& ...
                         \alt
                         \ltiMu{\ltitvar{}}{\ltiT{}}
                         \alt 
                         \ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiT{}}}}
                      &\mbox{Types} \\
  \ltiSubtypeSeen{} &::=& \ova{\ltiSeenEntry{\ltiT{}}{\ltiT{}}}
                      &\mbox{Subtype Seen List} \\

\end{array}
$$
\caption{Internal Language Syntax Extensions}
\label{symbolic:figure:internal-language-mu-intersection}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \infer [I-AppInst]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiT{}^f}
                  {\ltiFp{}}
                    \\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiT{}^a}
                  {\ltiEp{}}
                  \\
         \ltiunfold{\ltiT{}^f}
                   {\ltiPoly{\ova{\ltitvar{}}}{\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                  \\\\
                  \exists i \in 1...m.
                        \ltiunifyContexts{\ltiInternalOrExternalLang{}}{\ltistackmapping{\ltiEnvp{i}}{\ova{\ltiRp{}}_i}}{\ltiEnv{}}{\ova{\ltiR{}}} \}
                  \\\\
                  \ova{\ltiSp{}}
                  =
                  \left\{ {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{i}}}
                  \middle| i \in 1 ... n, 
                  \text{ if }
                  \ltiisubtype{\ltiEnv{}}{\ltiT{}^a}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{i}}}
                  \right\}
                  \\
                  |\ova{\ltiSp{}}|>0
    }
    {
      \ltitjudgement{\ltiEnv{}}
                    {\ltiappinst{\ltiF{}}
                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}^m}
                                {\ltiE{}}}
                    {\ltiMeetMany{\ova{\ltiSp{}}}}
                    {\ltiappinst{\ltiFp{}}
                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}^m}
                                {\ltiEp{}}}
    }

    \infer [I-App\Bot]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiF{}}
                  {\ltiT{}}
                  {\ltiFp{}}
                  \\\\
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
                  {\ltiEp{}}
                  \\\\
    \ltiunfold{\ltiT{}}{\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiR{}}}}}{\ltiE{}}}
                  {\ltiBot{}}
                  {\ltiappinst{\ltiFp{}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiR{}}}}}{\ltiEp{}}}
    }

    \infer [I-Abs]
    { 
    \exists i \in 1...m.
    \ltiunifyContexts{\ltiInternalOrExternalLang{}}
                     {\ltistackmapping{\ltiEnvp{i}}{\ltiTp{i}}}
                     {\ltiEnv{}}
                     {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}
    \\\\
    n>0
    \\
    \overrightarrow{
    \ltitjudgement{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ltiT{i}}}}}
                  {\ltiE{}}
                  {\ltiSp{i}}
                  {\ltiF{i}}
                  \ \ \
          \ltiisubtype{\ltiEnv{}}{\ltiSp{i}}{\ltiS{i}}
                  }^{1 \leq i \leq n}
          \\\\
          \ltimergeTaggedTermsLHS{\ltiE{}}{\ltimergeTaggedTermsLHS{\ltiF{1}}{\ltimergeTaggedTermsLHS{...}{\ltiF{n}}}}
          = \ltiEp{}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                         {\ova{\ltistackmapping{\ltiEnvp{}}{\ltiTp{}}}^m}
                                         {\ltivar{}}
                                         {\ltiE{}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                  {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                         {\ova{\ltistackmapping{\ltiEnvp{}}{\ltiTp{}}}^m}
                                         {\ltivar{}}
                                         {\ltiEp{}}}
                 }

    \infer [I-Sel]
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiE{}}
                  {\ltiS{}}
                  {\ltiF{}}
                     \\\\
    \ltiunfold{\ltiS{}}
              {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}}, ..., \hastype{\ltivar{i}}{\ltiT{i}} , ..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{i}}}
                  {\ltiT{i}}
                  {\ltisel{\ltiF{}}{\ltivar{i}}}
    }

    \infer [I-Sel\ltiBot]
    {
    \ltitjudgement{\ltiEnv{}}
                     {\ltiE{}}
                     {\ltiT{}}
                     {\ltiF{}}
                     \\\\
                     \ltiunfold{\ltiT{}}{\ltiBot}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltisel{\ltiE{}}{\ltivar{}}}
                  {\ltiBot}
                  {\ltisel{\ltiF{}}{\ltivar{}}}
    }
  \end{mathpar}
  \caption{Internal language type system extensions
  }
  \label{symbolic:figure:internal-language-type-system-mu-intersection}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
    \ltiunfold{\ltiT{}}{\ltiS{}}
    \\\\
    \text{ Unfold top-level recursion in \ltiT{} to \ltiS{}.}
    }
    }

    \begin{array}{lcl}
      \ltiunfoldalign{\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                     {\ltiPoly{\ova{\ltitvar{}}}{\ltiunfoldLHS{\ltiT{}}}}\\
      \ltiunfoldalign{\ltiMu{\ltitvar{}}{\ltiT{}}}
                     {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}
                                 {\ltitvar{}}
                                 {\ltiunfoldLHS{\ltiT{}}}}
                                                                \\
      \ltiunfoldalign{\ltiT{}}{\ltiT{}} \text{, otherwise}\\
    \end{array}

    \boxed{
    \infer[]
    {}
    {
    \ltimergeTaggedTerms{\ltiE{1}}{\ltiE{2}}{\ltiF{}}
    \\\\
    \text{Merge terms \ltiE{i} as \ltiF{}.}
    }
    }

    \boxed{
    \infer[]
    {}
    {
    \ltiunifyContexts{\ltiInternalOrExternalLang{}}{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}{\ltiEnv{}}{\ova{\ltiS{}}}
    \\\\
    \text{Prepare \ova{\ltiT{}} for use in current context \ltiEnv{}.}
    }
    }

    \begin{array}{lllll}
      \ltiunifyContextsalign{\ltiInternalOrExternalLang{}}
                             {\ltistackmapping{\ltiEmptyEnv{}}{\ova{\ltiT{}}}}
                             {\ltiEnv{}}
                             {\ova{\ltiT{}}} \\
      \ltiunifyContextsalign{\ltiInternalOrExternalLang{}}
                             {\ltistackmapping{\ltiEnvConcatParen{\ltitvarp{}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                             {\ltiEnvConcatParen{\ltitvar{}}{\ltiEnv{}}}
                             {\ltiunifyContextsLHS{\ltiInternalOrExternalLang{}}
                                                   {\ltireplace{\ltitvar{}}{\ltitvarp{}}
                                                               {(\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}})}}
                                                   {\ltiEnv{}}}\\
      \ltiunifyContextsalign{\ltiInternalOrExternalLang{}}
                             {\ltistackmapping{\ltiEnvConcatParen{\hastype{\ltivarp{}}{\ltiSp{}}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                            {\ltiEnvConcatParen{\hastype{\ltivar{}}{\ltiS{}}}{\ltiEnv{}}}
                            {\ltiunifyContextsLHS{\ltiInternalOrExternalLang{}}
                                                  {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                                  {\ltiEnv{}}},
                                                 &\text{ if } \ltiisubtype{\ltiEnvpp{}}{\ltiS{}}{\ltiSp{}}
    \end{array}

  \begin{array}{llll}
    \ltimergeTaggedTermsalign{\ltifuntparaminterface{\ova{\ltitvar{}}}{\ltiT{}}{\ltivar{}}{\ltiE{1}}}
                             {\ltifuntparaminterface{\ova{\ltitvar{}}}{\ltiT{}}
                                              {\ltivar{}}
                                              {\ltiE{2}}}
                             {\ltifuntparaminterface{\ova{\ltitvar{}}}{\ltiT{}}
                                              {\ltivar{}}
                                              {\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
                             \\
    \ltimergeTaggedTermsalign{\ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}{\ltiE{}}}
                             {\ltiappinst{\ltiFp{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}{\ltiEp{}}}
                             {\ltiappinst{\ltimergeTaggedTermsLHS{\ltiF{}}{\ltiFp{}}}
                                         {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}
                                         {\ltimergeTaggedTermsLHS{\ltiE{}}{\ltiEp{}}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltisel{\ltiE{1}}{\ltivar{}}}
                             {\ltisel{\ltiE{2}}{\ltivar{}}}
                             {\ltisel{\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}{\ltivar{}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltiRec{\ova{\ltivar{} = \ltiE{}}}}
                             {\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                             {\ltiRec{\ova{\ltivar{} = \ltimergeTaggedTermsLHS{\ltiE{}}{\ltiF{}}}}}
                                     \\
    \ltimergeTaggedTermsalign{\ltivar{}}
                             {\ltivar{}}
                             {\ltivar{}}
  \end{array}

  \end{mathpar}
  \caption{Extended Type System Metafunctions}
  \label{symbolic:figure:internal-language-metafunctions}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
      \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiT{}}{\ltiS{}}
      \\\\
      \text{\ltiT{} is a subtype of \ltiS{},
      }
      \\\\
      \text{with seen queries \ltiSubtypeSeen{}.
                 }
                 }
                 }

    \infer [S-MuL]
    {
     \ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltiS{}} \in \ltiSubtypeSeen{}
     \\\\
    \text{ or }
     \\\\
    \ltiisubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}
                                                 {\ltiS{}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiEnv{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}{\ltiS{}}
    }
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
                    {\ltiS{}}
    }

    \infer [S-MuR]
    {
     \ltiSeenEntry{\ltiS{}}{\ltiMu{\ltitvar{}}{\ltiT{}}} \in \ltiSubtypeSeen{}
     \\\\
    \text{ or }
     \\\\
    \ltiisubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiS{}}
                                                 {{\ltiMu{\ltitvar{}}{\ltiT{}}}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}
    }
    {
    \ltiisubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
    }

    \infer [S-IFn]
    { 
      \forall i \in 1...n.\ 
        \exists j \in 1...m.\ 
          \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}{\ltiS{j}}{\ltiT{i}}
    }
    { \ltiisubtypeseen{\ltiSubtypeSeen{}}{\ltiEnv{}}
                      {\ltiIFn{\ova{\ltiS{}}^m}}
                      {\ltiIFn{\ova{\ltiT{}}^n}}
                   }

%    \infer [SF-ContextBoth]
%    {
%     \ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnvpp{}}
%                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvpp{}}{\ltiS{}}}{\ltiEnvp{}}}
%                     {\ltiT{}}
%    }
%    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnv{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
%                     {(\ltistackmapping{\ltiEnvpp{}}{\ltiT{}})}
%    }
%
%    \infer [SF-ContextL]
%    {
%     \ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnv{}}
%                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvp{}}{\ltiS{}}}{\ltiEnv{}}}
%                     {\ltiT{}}
%    }
%    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnv{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
%                     {\ltiT{}}
%    }
%
%    \infer [SF-ContextR]
%    {
%     \ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnv{}}
%                     {\ltiS{}}
%                     {\ltiunifyContextsLHS{\ltiinternallabel}{\ltistackmapping{\ltiEnvp{}}{\ltiT{}}}{\ltiEnv{}}}
%    }
%    {\ltiisubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiEnv{}}
%                     {\ltiS{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiT{}})}
%    }

  \end{mathpar}
  \caption{Internal language subtyping extensions
  }
  \label{symbolic:figure:internal-language-subtyping-mu-intersection}
\end{figure}

\begin{figure}
  \begin{mathpar}

%    \infer [Var]
%    {}
%    {
%       \ltitSdjudgement{\ltiEnv{}}
%                       {\ltivar{}}
%                       {\ltiEnvLookup{\ltiEnv{}}{\ltivar{}}}
%                       {\ltivar{}}
%                 }

%    \infer [Sel]
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiF{}}
%                    {\ltiS{}}
%                    {\ltiFp{}}
%                     \\\\
%    \ltiSdsubtype{\ltiEnv{}}{\ltiS{}}{\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},...,\hastype{\ltivar{i}}{\ltiT{i}},...,\hastype{\ltivar{n}}{\ltiT{n}}}}
%    }
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                  {\ltisel{\ltiF{}}{\ltivar{i}}}
%                  {\ltiT{i}}
%                  {\ltisel{\ltiFp{}}{\ltivar{i}}}
%    }
%
%    \infer [Rec]
%    {
%    \overrightarrow{
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiF{i}}
%                    {\ltiT{i}}
%                    {\ltiFp{i}}
%                    }
%                    ^{1 \leq i \leq n}
%    }
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiRec{\ova{\ltivar{} = \ltiF{}}^n}}
%                    {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n}}
%                    {\ltiRec{\ova{\ltivar{} = \ltiFp{}}^n}}
%    }

    \infer [E-AppInf]
    {
    \ltitjudgement{\ltiEnv{}}
                    {\ltiF{}}
                    {\ltiS{}^f}
                    {\ltiFp{}}
                    \\
    \ltitjudgement{\ltiEnv{}}
                    {\ltiE{}}
                    {\ltiS{}^a}
                    {\ltiEp{}}
                    \\\\
          \ltiisubtype{\ltiEnv{}}
                    {\ltiS{}^f}
                    {\ltiPoly{\ova{\ltitvar{}}}
                             {\ltiIFn{\ltiFn{\ltiT{}}{\ltiS{}}}}}
                  \\
                       |\ova{\ltitvar{}}|>0
                  \\\\
                  \forall \ltiRp{}.
                    \left(
                    \begin{array}{lll}
                      \ltiisubtype{\ltiEnv{}}{\ltiS{}^a}{\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiT{}}}
                      \text{ implies}
                      \arcr
                      \ltiisubtype{\ltiEnv{}}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}^a}}
                                   {\ltireplace{\ova{\ltiRp{}}}{\ova{\ltitvar{}}}{\ltiS{}^a}}
                    \end{array}
                  \right)
    }
    {
    \ltitjudgement{\ltiEnv{}}
                    {\ltiapp{\ltiF{}}{\ltiE{}}}
                    {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiS{}}}
                    {\ltiappinst{\ltiFp{}}
                                {\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}
                                {\ltiEp{}}}
    }

    \infer [E-UAbs]
    { 
    \exists i \in 1...m.
    \ltiunifyContexts{\ltiInternalOrExternalLang{}}
                     {\ltistackmapping{\ltiEnvp{i}}{\ltiTp{i}}}
                     {\ltiEnv{}}
                     {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}
    \\\\
    n>0
    \\\\
    \overrightarrow{
    \ltitjudgement{\ltiEnvConcat{\ltiEnv{}}
                                {\ltiEnvConcat{\ova{\ltitvar{}}}
                                              {\hastype{\ltivar{}}{\ova{\ltiT{i}}}}}}
                  {\ltiE{}}
                  {\ltiSp{i}}
                  {\ltiF{i}}
                  \ \ \
          \ltiisubtype{\ltiEnv{}}{\ltiSp{i}}{\ltiS{i}}
                  }^{1 \leq i \leq n}
    \\\\
          \ltimergeTaggedTermsLHS{\ltiE{}}{\ltimergeTaggedTermsLHS{\ltiF{1}}{\ltimergeTaggedTermsLHS{...}{\ltiF{n}}}} = \ltiEp{}
    }
    {
    \ltitjudgement{\ltiEnv{}}
                  {\ltiufun{\ltivar{}}{\ltiE{}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                  {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                         {\ova{\ltistackmapping{\ltiEnvp{}}{\ltiTp{}}}}
                                         {\ltivar{}}
                                         {\ltiEp{}}}
                 }

%    \infer [AppInst]
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiF{}}
%                    {\ltiT{}^f}
%                    {\ltiFp{}}
%                    \\
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiE{}}
%                    {\ltiTp{}}
%                    {\ltiEp{}}
%                  \\\\
%                  \ltiSdsubtype{\ltiEnv{}}{
%         \ltiresolveLHS{\ltiexternallanglabel}
%                    {\ltiEnv{}}
%                    {\ltiT{}^f}}
%                    {
%                    {\ltiPoly{\ova{\ltitvar{}}}{\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}
%                                                            {\ova{\ltiContextualFn{\ltiEnvpp{}}{\ltiTpp{}}{\ltiSpp{}}}}}}
%                                                            }
%                  \\\\
%                  m > 0
%                  \\
%                  \ltiLfindTA{\ltiexternallanglabel}{\ltiEnv{}}{\ova{\ltitvar{}}}{\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}{\ova{\ltiR{}}}
%                  \\\\
%                  \ova{\ltiSp{}}^m
%                  =
%                  \{ \ltiS{i}\ |\ i \in 1 ... n, \ltiSdsubtype{\ltiEnv{}}{\ltiT{}^a}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiT{i}}}
%                  \}
%    }
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltiappinst{\ltiF{}}
%                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
%                                {\ltiE{}}}
%                    {\ltiMeetMany{\ova{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{}}}}}
%                    {\ltiappinst{\ltiFp{}}
%                                {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}}
%                                {\ltiEp{}}}
%    }


%    \infer [Abs]
%    {
%    \ltiunfold{\ltiTp{}}{\ltiPoly{\ova{\ltitvar{}}}
%                                    {\ltiSplitIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^{1...n}}
%                                                 {\ova{\ltiContextualFn{\ltiEnvp{}}{\ltiT{}}{\ltiS{}}}^{n+1...m}}}}
%    \\\\
%                     m>0
%                     \\
%    \overrightarrowcaption{
%     \ltitSdjudgement{\ltiEnvConcat{\ltiEnv{}}
%                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
%                                                 {\hastype{\ltivar{}}{\ltiT{i}}}}}
%                     {\ltiEp{0}}
%                     {\ltiSp{i}}
%                     {\ltiE{i}}
%                     }^{1 \leq i \leq n}
%                     \\\\
%    \overrightarrowcaption{
%     \ltitSdjudgement{\ltiEnvConcat{\ltiEnvMissingTVarsLHS{\ltiEnv{}}{\ltiEnvp{i}}}
%                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
%                                                 {\hastype{\ltivar{}}
%                                                          {\ltiT{i}}}}}
%                     {\ltiEp{0}}
%                     {\ltiSp{i}}
%                     {\ltiE{i}}
%                     }^{n < i \leq m}
%                     \\\\
%                     \overrightarrowcaption{\ltiSdsubtype{\ltiEnv{}}{\ltiSp{i}}
%                                                  {\ltiS{i}}
%                                                  ,
%                                                  \ 
%                                                  \ltimergeTaggedTerms{\ltiEp{i-1}}{\ltiE{i}}{\ltiEp{i}}
%                                                  }^{1 \leq i \leq m}
%    }
%    {
%    \ltitSdjudgement{\ltiEnv{}}
%                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{0}}}
%                    {\ltiTp{}}
%                    {\ltifuninterface{\ltiTp{}}{\ltivar{}}{\ltiEp{m}}}
%                 }
  \end{mathpar}

  \caption{Extended External Language Specification
  }
  \label{symbolic:figure:external-language-declarative-type-system-mu-intersection}
\end{figure}


\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {
    \ltimergeTaggedTerms{\ltiE{1}}{\ltiE{2}}{\ltiF{}}
    \\\\
    \text{Merge terms \ltiE{i} as \ltiF{} (extends \figref{symbolic:figure:internal-language-metafunctions}).}
    }
    }

  \begin{array}{llll}
    \ltimergeTaggedTermsalign{\ltifuntparaminterface{\ova{\ltitvar{}}}
                                                    {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}^n}
                                                    {\ltivar{}}{\ltiE{1}}}
                             {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                                    {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}^{n+1...m}}
                                                    {\ltivar{}}
                                                    {\ltiE{2}}}
                             {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                                    {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}^m}
                                                    {\ltivar{}}
                                                    {\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
                             \\
    \ltimergeTaggedTermsalign{\ltiappinst{\ltiF{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^n}{\ltiE{}}}
                             {\ltiappinst{\ltiFp{}}{\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^{n+1...m}}{\ltiEp{}}}
                             {\ltiappinst{\ltimergeTaggedTermsLHS{\ltiF{}}{\ltiFp{}}}
                                         {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}^m}
                                         {\ltimergeTaggedTermsLHS{\ltiE{}}{\ltiEp{}}}}
    \end{array}
  \end{mathpar}

  \caption{Extended External Language Metafunctions
  }
  \label{symbolic:figure:external-language-metafunctions}
\end{figure}

\begin{figure}
$$
\begin{array}{lrll}
  \ltiE{}, \ltiF{} &::=& ... \alt
                         \ltiufunelab{\ova{\ltiufunelabentry{\ltiClosureID{}}}}
                                     {\ltivar{}}
                                     {\ltiE{}}
                      &\mbox{Terms} \\
  \ltiClosureCache{} &::=& \ova{\ltiClosureCacheEntry
                                {\ltiClosureID{}}
                                {\ltiClosure{\ltiEnv{}}
                                            {\ltifuntparaminterface
                                             {\ova{\ltitvar{}}}
                                             {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}}
                                             {\ltiE{}}}}}
                      &\mbox{Closure Cache} \\
  \ltiCombinedThreadedEnv{} &::=& \ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiClosureCache{}}
                      &\mbox{Combined Threaded Environments} \\
\end{array}
$$
\caption{Extended Symbolic Closure Language Syntax (extends \figref{symbolic:figure:external-language-syntax-mu-intersection})}
\label{symbolic:figure:SC-language-syntax}
\end{figure}

\begin{figure}
  \begin{mathpar}
    % TODO thread seen subtypings
    \boxed
    {
    \infer[]
    {}
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiT{}}
                      {\ltiClosureCachep{}}
                      {\ltiEp{}}
                     \\\\
                     \text{Given symbolic closure cache \ltiClosureCache{}
                     and context \ltiEnv{}, external term \ltiE{} 
                     is of symbolic-closure-language type \ltiT{}
                     }
                     \\\\
                     \text{
                     with updated symbolic closure cache \ltiClosureCachep{},
                     and elaborated symbolic-closure-language term \ltiEp{}.
                     }
                     }
                     }

    \infer [AppInst]
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnvp{}}
                      {\ltiF{}}
                      {\ltiT{}^f}
                      {\ltiClosureCache{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgement{\ltiClosureCache{2}}
                      {\ltiEnvp{}}
                      {\ltiE{}}
                      {\ltiT{}^a}
                      {\ltiClosureCachep{0}}
                      {\ltiEp{}}
                  \\
    \ltiunfold{\ltiT{}^f}
              {\ltiPoly{\ova{\ltitvar{}}}
                       {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                  \\\\
                  \exists i \in 1...m.
                        \ltiunifyContextsSC{\ltiClosureCachep{0}}
                                           {\ltistackmapping{\ltiEnv{i}}{\ova{\ltiRp{}}_i}}
                                           {\ltiEnvp{}}
                                           {\ova{\ltiR{}}}
                                           {\ltiClosureCachep{1}}
    \\
    \ltiClosureCachepp{0} = \ltiClosureCachep{n}
    \\
    \ova{\ltiSpp{}}_0 = \varnothing
                   \\
                   |\ova{\ltiSpp{}}_n| > 0
    \\\\
    \overrightarrowcaption{
      (\ova{\ltiSpp{}}_i, \ltiClosureCachepp{i})
        = \left\{
                     \begin{array}{llll}
                       (\ova{\ltiSpp{}}_{i-1}{\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiSp{i}}}, \ltiClosureCachepp{i})
                       , &\text{if } 
                       \ltiSsubtype{\ltiClosureCachepp{i-1}}
                                   {\ltiEnvp{}}
                                   {\ltiT{}^a}
                                   {\ltireplace{\ova{\ltiR{}}}{\ova{\ltitvar{}}}{\ltiTp{i}}}
                                   {\ltiClosureCachepp{i}}
                       \arcr
                       (\ova{\ltiSpp{}}_{i-1}, \ltiClosureCachepp{i-1}),  &\text{otherwise}
                     \end{array}
                   \right.
                   }^{1 \leq i \leq n}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnvp{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}^m}
                                  {\ltiE{}}}
                      {\ltiMeetMany{\ova{\ltiSpp{}}_n}}
                      {\ltiClosureCachepp{n}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiRp{}}}}^m}
                                  {\ltiEp{}}}
    }

    \infer [AppInf-Closure]
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiTpp{}}
                      {\ltiClosureCache{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgement{\ltiClosureCache{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiTp{}}
                      {\ltiClosureCache{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiunfold{\ltiTpp{}}{\ltiClosureWithStkID{\ltiEnvp{}}
                                              {\ltiClosureID{}}
                                              {\ltiufun{\ltivar{}}{\ltiEpp{}}}}
                  \\\\
                  \ltilookup{\ltiClosureCache{3}}{\ltiClosureID{}} =
                  \ltiClosureCacheVal{\ltiFuel{}}{\ltiClosureElab{}}
                  \\
    0 < \ltiFuel{}
    \\\\
    \ltitSstkjudgement{\ltimapsto{\ltiClosureCache{3}}{\ltiClosureID{}}{\ltiClosureCacheVal{\ltiFuel{}-1}{\ltiClosureElab{}}}}
                      {\ltiEnvConcat{\ltiEnvp{}}{\hastype{\ltivar{}}{\ltiTp{}}}}
                      {\ltiEpp{}}
                      {\ltiS{}}
                      {\ltiClosureCache{4}}
                      {\ltiFpp{}}
                      \\\\
    \ltiupdateClosureCache{\ltiClosureCache{4}}{\ltiEnv{}}{\ltiClosureID{}}{\varnothing}{\ltiTp{}}{\ltiS{}}{\ltiFpp{}}{\ltiClosureCache{5}}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiS{}}
                      {\ltiClosureCache{5}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }

    \infer [AppInf\Bot]
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltiClosureCache{2}}
                      {\ltiFp{}}
                  \\\\
    \ltitSstkjudgement{\ltiClosureCache{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiClosureCache{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiunfold{\ltiT{}}{\ltiBot}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiapp{\ltiF{}}{\ltiE{}}}
                      {\ltiTpp{}}
                      {\ltiClosureCache{3}}
                      {\ltiappinst{\ltiFp{}}
                                  {}
                                  {\ltiEp{}}}
    }

    \infer [AppInst\Bot]
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiT{}}
                      {\ltiClosureCache{2}}
                      {\ltiFp{}}
                  \\
    \ltitSstkjudgement{\ltiClosureCache{2}}
                      {\ltiEnv{}}
                      {\ltiE{}}
                      {\ltiS{}}
                      {\ltiClosureCache{3}}
                      {\ltiEp{}}
                  \\\\
    \ltiunfold{\ltiT{}}{\ltiBot}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{1}}
                      {\ltiEnv{}}
                      {\ltiappinst{\ltiF{}}
                                  {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}
                                  {\ltiE{}}}
                      {\ltiTpp{}}
                      {\ltiClosureCache{3}}
                      {\ltiappinst{\ltiFp{}}
                                  {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}
                                  {\ltiEp{}}}
    }

    \infer [Sel]
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiS{}}
                      {\ltiClosureCachep{}}
                      {\ltiFp{}}
                      \\\\
    \ltiunfold{\ltiS{}}
              {\ltiRec{\hastype{\ltivar{1}}{\ltiT{1}},..., \hastype{\ltivar{i}}{\ltiT{i}},..., \hastype{\ltivar{n}}{\ltiT{n}}}}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{i}}}
                      {\ltiT{i}}
                      {\ltiClosureCachep{}}
                      {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }

    \infer [Sel\Bot]
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltiF{}}
                      {\ltiS{}}
                      {\ltiClosureCachep{}}
                      {\ltiFp{}}
                      \\\\
    \ltiunfold{\ltiS{}}{\ltiBot}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltisel{\ltiF{}}{\ltivar{i}}}
                      {\ltiBot}
                      {\ltiClosureCachep{}}
                      {\ltisel{\ltiFp{}}{\ltivar{i}}}
    }

    \infer [Abs]
    {
    \exists i \in 1...m.
    \ltiunifyContexts{\ltiInternalOrExternalLang{}}
                     {\ltistackmapping{\ltiEnvp{i}}{\ltiTp{i}}}
                     {\ltiEnv{}}
                     {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}
                     \\\\
                     n>0
                     \\\\
                     \text{TODO if $|\ova{\ltitvar{}}|>0$, erase SC's in \ltiEnv{}}
                     \\\\
    \overrightarrowcaption{
     \ltitSstkjudgement{\ltiClosureCache{i-1}}
                    {\ltiEnvConcat{\ltiEnv{}}
                                   {\ltiEnvConcat{\ova{\ltitvar{}}}
                                                 {\hastype{\ltivar{}}
                                                          {\ltiT{i}}}}}
                     {\ltiE{}}
                     {\ltiSp{i}}
                     {\ltiF{i}}
                     {\ltiClosureCache{i}}
                     }^{1 \leq i \leq n}
                     \\\\
                     \overrightarrowcaption{
                        \ltiSsubtype{\ltiClosureCache{n+i-1}}
                                                  {\ltiEnv{}}
                                                  {\ltiSp{i}}
                                                  {\ltiS{i}}
                                                  {\ltiClosureCache{n+i}}
                                                  }^{1 \leq i \leq n}
                                                  \\
        \ltimergeTaggedTermsLHS{\ltiE{}}{\ltimergeTaggedTermsLHS{\ltiF{1}}{\ltimergeTaggedTermsLHS{...}{\ltiF{n}}}} = \ltiEp{}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{0}}
                    {\ltiEnv{}}
                    {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                           {\ova{\ltistackmapping{\ltiEnvp{}}{\ltiTp{}}}^m}
                                           {\ltivar{}}
                                           {\ltiE{}}}
                    {\ltiPoly{\ova{\ltitvar{}}}{\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                    {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                           {\ova{\ltistackmapping{\ltiEnvp{}}{\ltiTp{}}}^m}
                                           {\ltivar{}}
                                           {\ltiEp{}}}
                    {\ltiClosureCache{2n}}
                 }

    \infer [UAbs]
    {
    \ltiClosureID{} \not\in dom(\ltiClosureCache{})
    \\\\
    \ltiClosureCachep{}
    =
    \ltimapsto{\ltiClosureCache{}}
              {\ltiClosureID{}}
              {\ltiClosureCacheVal
               {\ltiFuel{0}}
               {\ltiufun{\ltivar{}}{\ltiE{}}}}
               \\
               for some initial fuel {\ltiFuel{0}}
    }
    {
    \ltitSstkjudgement{\ltiClosureCache{}}
                      {\ltiEnv{}}
                      {\ltiufun{\ltivar{}}{\ltiE{}}}
                      {\ltiClosureWithStkID
                                           {\ltiEnv{}}
                                           {\ltiClosureID{}}
                                           {\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltiClosureCachep{}}
                      {\ltiufunelab{\ltiClosureID{}}
                                   {\ltivar{}}
                                   {\ltiE{}}}
                 }
  \end{mathpar}

  \caption{Extended Algorithmic Type system for Symbolic Closure Language (\textsc{AppInf} omitted)
  }
  \label{symbolic:figure:SC-language-algorithmic-type-system-mu-intersection}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \boxed{
    \infer[]
    {}
    {\ltiSsubtypeseen{\ltiSubtypeSeen{}}
                 {\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltiS{}}
                 {\ltiT{}}
                 {\ltiCombinedThreadedEnvp{}}
                 \\\\
                 \text{
                 With closure cache \ltiCombinedThreadedEnv{}
                 and seen subtypings \ltiSubtypeSeen{},
                 \ltiS{} is a subtype of \ltiT{}
                 with updated cache
                 \ltiCombinedThreadedEnvp{}.
                 }
    }
    }

    \infer [S-TVar]
    {}
    {
     \ltiSsubtypeseen{\ltiSubtypeSeen{}}
                 {\ltiCombinedThreadedEnv{}}
                 {\ltiEnv{}}
                 {\ltitvar{}}
                 {\ltitvar{}}
                 {\ltiCombinedThreadedEnv{}}
    }

    \infer [S-Top]
    {}
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiT{}}{\Top}{\ltiCombinedThreadedEnv{}}}

    \infer [S-Bot]
    {}
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\Bot}{\ltiT{}}{\ltiCombinedThreadedEnv{}}}

    \infer [S-MuL]
    {
     (\ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltiS{}} \in \ltiSubtypeSeen{}
     \text{ and } \ltiCombinedThreadedEnv{} = \ltiCombinedThreadedEnvp{}
     )
     \\\\
    \text{ or }
     \\\\
    \ltiSsubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiMu{\ltitvar{}}{\ltiT{}}}
                                                 {\ltiS{}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}{\ltiS{}}
                    {\ltiCombinedThreadedEnvp{}}
    }
    {
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
                    {\ltiS{}}
                    {\ltiCombinedThreadedEnvp{}}
    }

    \infer [S-MuR]
    {
     (\ltiSeenEntry{\ltiS{}}{\ltiMu{\ltitvar{}}{\ltiT{}}} \in \ltiSubtypeSeen{}
     \text{ and } \ltiCombinedThreadedEnv{} = \ltiCombinedThreadedEnvp{})
     \\\\
    \text{ or }
     \\\\
    \ltiSsubtypeseen{\ltiSeenConcat{\ltiSeenEntry{\ltiS{}}
                                                 {{\ltiMu{\ltitvar{}}{\ltiT{}}}}}
                                   {\ltiSubtypeSeen{}}}
                    {\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltireplace{\ltiMu{\ltitvar{}}{\ltiT{}}}{\ltitvar{}}{\ltiT{}}}
                    {\ltiCombinedThreadedEnvp{}}
    }
    {
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiCombinedThreadedEnv{}}
                    {\ltiEnv{}}
                    {\ltiS{}}
                    {\ltiMu{\ltitvar{}}{\ltiT{}}}
                    {\ltiCombinedThreadedEnvp{}}
    }

    \infer [S-Rec]
    {
    \overrightarrow{\ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{i-1}}{\ltiEnv{}}
                                {\ltiT{}}
                                {\ltiS{}}
                                {\ltiCombinedThreadedEnv{i}}
                                }
    }
    {
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{0}}
                {\ltiEnv{}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}^n,
                         \ova{\hastype{\ltivarp{}}{\ltiTp{}}}}}
                {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiS{}}}^n}}
                {\ltiCombinedThreadedEnv{n}}
    }

    \infer [S-Poly]
    {
    \text{TODO erase SC's in \ltiS{} and \ltiT{}}
    \\
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{}}
                {\ltiEnvConcat{\ltiEnv{}}{\ova{\ltitvar{}}}}
                {\ltiT{}}
                {\ltiS{}}
                {\ltiCombinedThreadedEnvp{}}
    }
    {
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{}}
                {\ltiEnv{}}
                {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                {\ltiPoly{\ova{\ltitvar{}}}{\ltiS{}}}
                {\ltiCombinedThreadedEnvp{}}
    }

    \infer [S-IFn]
    { 
      \overrightarrowcaption{
        \exists j \in 1...m.\ 
          \ltiSsubtypeseen{\ltiSubtypeSeen{}}
                          {\ltiCombinedThreadedEnv{i-1}}
                          {\ltiEnv{}}
                          {\ltiS{j}}
                          {\ltiT{i}}
                          {\ltiCombinedThreadedEnv{i}}
                          }^{1 \leq i \leq n}
    }
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{0}}{\ltiEnv{}}
                      {\ltiIFn{\ova{\ltiS{}}^m}}
                      {\ltiIFn{\ova{\ltiT{}}^n}}
                      {\ltiCombinedThreadedEnv{n}}
                   }

                   % FIXME don't push in the Poly, just duplicate the logic in SF-Closure
                   % this is because we only get to choose the type arguments once
    \infer [S-Closure]
    {
    \overrightarrowcaption{
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}
                    {\ltiCombinedThreadedEnv{i-1}}
                    {\ltiEnvpp{}}
                    {\ltiClosureWithStkID{\ltiEnv{}}
                                         {\ltiClosureID{}}
                                         {\ltiufun{\ltivar{}}{\ltiE{}}}}
                    {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{i}}{\ltiS{i}}}}
                    {\ltiCombinedThreadedEnv{i}}
                    }^{1 \leq i \leq n}
    }
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{0}}
                  {\ltiEnvpp{}}
                  {\ltiClosureWithStkID{\ltiEnv{}}
                                       {\ltiClosureID{}}
                                       {\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}^n}}}
                  {\ltiCombinedThreadedEnv{n}}
                  }

    % eg (IFn [Int -> Int] [Number -> Number]) <: [Nothing -> Any]
    \infer [SF-Fn]
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{1}}{\ltiEnv{}}{\ltiS{}}{\ltiSp{}}{\ltiCombinedThreadedEnv{2}}
      \\\\
      \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{2}}{\ltiEnv{}}{\ltiT{}}{\ltiTp{}}{\ltiCombinedThreadedEnv{3}}
    }
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{1}}{\ltiEnv{}}
                  {\ltiFn{\ltiSp{}}{\ltiT{}}}
                  {\ltiFn{\ltiS{}}{\ltiTp{}}}
                  {\ltiCombinedThreadedEnv{3}}
       }

    \infer [SF-Closure]
    {
    0 < \ltiFuel{}
    \\
    \text{TODO propagate \ltiSubtypeSeen{} through type system} 
    \\
    \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}-1}
                                                  {\ltiClosureCache{}}}
                      {\ltiEnvConcat{\ltiEnv{}}{\hastype{\ltivar{}}{\ltiT{}}}}
                      {\ltiE{}}
                      {\ltiSp{}}
                      {\ltiCombinedThreadedEnv{}}
                      {\ltiEp{}}
                      \\\\
    \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltiCombinedThreadedEnv{}}{\ltiEnv{}}{\ltiSp{}}{\ltiS{}}
                {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                            {\ltiClosureCachep{}}}
                      \\
    \ltiupdateClosureCache{\ltiClosureCachep{}}{\ltiEnv{}}{\ltiClosureID{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiEp{}}{\ltiClosureCachepp{}}
    }
    { \ltiSsubtypeseen{\ltiSubtypeSeen{}}{\ltimakeCombinedThreadedEnv{\ltiFuel{}}
                                              {\ltiClosureCache{}}}
                  {\ltiEnvp{}}
                  {\ltiClosureWithStkID
                                       {\ltiEnv{}}
                                       {\ltiClosureID{}}
                                       {\ltiufun{\ltivar{}}{\ltiE{}}}}
                  {\ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}}}
                  {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                              {\ltiClosureCachepp{}}}
                  }

%    \infer [SF-ContextBoth]
%    {
%     \ltiunifyContextsSC{\ltiCombinedThreadedEnv{1}}
%                        {\ltistackmapping{\ltiEnvpp{}}{\ltiS{}}}
%                        {\ltiEnvp{}}
%                        {\ltiSp{}}
%                        {\ltiCombinedThreadedEnv{2}}
%     \\\\
%     \ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{2}}
%                     {\ltiEnvpp{}}
%                     {\ltiSp{}}
%                     {\ltiT{}}
%                     {\ltiCombinedThreadedEnv{3}}
%    }
%    {\ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{1}}
%                     {\ltiEnv{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
%                     {(\ltistackmapping{\ltiEnvpp{}}{\ltiT{}})}
%                     {\ltiCombinedThreadedEnv{3}}
%    }
%    \ 
%%
%    \infer [SF-ContextL]
%    {
%    \ltiunifyContextsSC{\ltiCombinedThreadedEnv{1}}
%                       {\ltistackmapping{\ltiEnvp{}}{\ltiS{}}}
%                       {\ltiEnv{}}
%                       {\ltiSp{}}
%                       {\ltiCombinedThreadedEnv{2}}
%                       \\\\
%     \ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{2}}
%                     {\ltiEnv{}}
%                     {\ltiSp{}}
%                     {\ltiT{}}
%                     {\ltiCombinedThreadedEnv{3}}
%    }
%    {\ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{1}}
%                     {\ltiEnv{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiS{}})}
%                     {\ltiT{}}
%                     {\ltiCombinedThreadedEnv{3}}
%    }
%    \ 
%%
%    \infer [SF-ContextR]
%    {
%     \ltiunifyContextsSC{\ltiCombinedThreadedEnv{1}}
%                        {\ltistackmapping{\ltiEnvp{}}{\ltiT{}}}
%                        {\ltiEnv{}}
%                        {\ltiTp{}}
%                        {\ltiCombinedThreadedEnv{2}}
%     \\\\
%     \ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{2}}
%                     {\ltiEnv{}}
%                     {\ltiS{}}
%                     {\ltiTp{}}
%                     {\ltiCombinedThreadedEnv{3}}
%    }
%    {\ltiSsubtypeseen{\ltiSubtypeSeen{}}
%                     {\ltiCombinedThreadedEnv{1}}
%                     {\ltiEnv{}}
%                     {\ltiS{}}
%                     {(\ltistackmapping{\ltiEnvp{}}{\ltiT{}})}
%                     {\ltiCombinedThreadedEnv{3}}
%    }

  \end{mathpar}

  \caption{Extended Symbolic Closure Language Subtyping}
  \label{symbolic:figure:SC-language-subtype-mu-intersection}
\end{figure}

\begin{figure}
  \begin{mathpar}
   \boxed{
   \infer[]
   {}
   {
   \ltimergeTaggedTerms{\ltiE{1}}{\ltiE{2}}{\ltiE{3}}
   \\\\
    \text{Merge terms \ltiE{1} and \ltiE{2}}
    \\\\
    \text{
  (extends \figref{symbolic:figure:external-language-metafunctions}).}
   }}

  \begin{array}{llll}
    \ltimergeTaggedTermsalign{\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^n}
                                     {\ltivar{}}
                                     {\ltiE{1}}}
                             {\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^{n+1...m}}
                                     {\ltivar{}}
                                     {\ltiE{2}}}
                             {\ltiufunelab{\ova{\ltiufunelabentry
                                                            {\ltiClosureID{}}}^m
                                                            }
                                     {\ltivar{}}
                                     {\ltimergeTaggedTermsLHS{\ltiE{1}}{\ltiE{2}}}}
  \end{array}

    \boxed{
    \infer[]
    {}
    {\ltiupdateClosureCache{\ltiClosureCache{}}{\ltiEnv{}}{\ltiClosureID{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiE{}}{\ltiClosureCachep{}}
    \\\\
    \text{Record symbolic closure \ltiClosureID{} as \ltiPoly{\ova{\ltitvar{}}}{\ltiFn{\ltiT{}}{\ltiS{}}} under}
    \\\\
    \text{application context \ltiEnv{}, with elaboration \ltiE{}.}
    }}

    \infer[]
    {
    % we want to only set type variables once, we probably need to distinguish
    % between zero type variables and a never-exercised closure
    \text{TODO merge type variables}
    \\
    \ltilookup{\ltiClosureCache{}}{\ltiClosureID{}} = 
    \ltiClosure{\ltiEnv{}}
               {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                      {\ltiIFn{\ova{\ltiFn{\ltiTp{}}{\ltiSp{}}}}}
                                      {\ltivar{}}
                                      {\ltiF{}}}
    \\\\
    \ltiClosureCachep{} = 
    \ltimapsto{\ltiClosureCache{}}
              {\ltiClosureID{}}
              {\ltiClosure{\ltiEnv{}}
                          {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                                 {\ltiIFn{\ltiFn{\ltiT{}}{\ltiS{}} \ova{\ltiFn{\ltiTp{}}{\ltiSp{}}}}}
                                                 {\ltivar{}}
                                                 {\ltimergeTaggedTermsLHS{\ltiE{}}{\ltiF{}}}}}
    }
    {\ltiupdateClosureCache{\ltiClosureCache{}}{\ltiEnvp{}}{\ltiClosureID{}}{\ova{\ltitvar{}}}{\ltiT{}}{\ltiS{}}{\ltiE{}}{\ltiClosureCachep{}}
    }

    \boxed{
    \infer[]
    {}
    {
    \ltiunifyContextsSC{\ltiCombinedThreadedEnv{}}{\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}{\ltiEnv{}}{\ova{\ltiS{}}}{\ltiCombinedThreadedEnvp{}}
    \text{ Use \ova{\ltiT{}}'s context \ltiEnvp{} to prepare \ova{\ltiT{}} for use in current context \ltiEnv{}.
    }
    }
    }

    \begin{array}{lllll}
      \ltiunifyContextsSCalign{\ltiCombinedThreadedEnv{}}
                              {\ltistackmapping{\ltiEmptyEnv{}}{\ova{\ltiT{}}}}
                              {\ltiEnv{}}
                              {\ltiunifyContextsSCRHS{\ova{\ltiT{}}}
                                                     {\ltiCombinedThreadedEnv{}}}
                                                     \\
      \ltiunifyContextsSCalign{\ltiCombinedThreadedEnv{}}
                              {\ltistackmapping{\ltiEnvConcatParen{\ltitvarp{}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                              {\ltiEnvConcatParen{\ltitvar{}}{\ltiEnv{}}}
                              {\ltiunifyContextsSCLHS{\ltiCombinedThreadedEnv{}}
                                                    {\ltireplace{\ltitvar{}}{\ltitvarp{}}
                                                                {(\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}})}}
                                                    {\ltiEnv{}}}\\
      \ltiunifyContextsSCalign{\ltiCombinedThreadedEnv{}}
                              {\ltistackmapping{\ltiEnvConcatParen{\hastype{\ltivarp{}}{\ltiSp{}}}{\ltiEnvp{}}}{\ova{\ltiT{}}}}
                              {\ltiEnvConcatParen{\hastype{\ltivar{}}{\ltiS{}}}{\ltiEnv{}}}
                              {\ltiunifyContextsSCLHS{\ltiCombinedThreadedEnvp{}}
                                                     {\ltistackmapping{\ltiEnvp{}}{\ova{\ltiT{}}}}
                                                     {\ltiEnv{}}},
                                                 \text{ if } \ltiSsubtype{\ltiCombinedThreadedEnv{}}
                                                                          {\ltiEnvpp{}}
                                                                          {\ltiS{}}
                                                                          {\ltiSp{}}
                                                                          {\ltiCombinedThreadedEnvp{}}
    \end{array}
  \end{mathpar}
  \caption{Metafunctions for Extended Symbolic Closure language}
\end{figure}

\begin{figure}

  \[
    \boxed{\ltielabDriver{\ltiE{}}{\ltiEp{}}{\ltiT{}}
    \text{ Elaborates external language term \ltiE{} to internal language term \ltiEp{} and type \ltiT{}.
    }
    }
  \]

  \begin{mathpar}
    \infer[ElabDriver]
    {
     \exists \ltiFuel{}.\ 
     \ltitSstkjudgement{\ltimakeCombinedThreadedEnv{\ltiFuel{}}{\ltiEmptyClosureCache}}
                       {\ltiEmptyEnv}
                       {\ltiE{1}}
                       {\ltiT{}}
                       {\ltimakeCombinedThreadedEnv{\ltiFuelp{}}
                                                   {\ltiClosureCache{}}}
                       {\ltiE{2}}
                       \\
     \ltielimClos{\ltiClosureCache{}}{\ltiE{2}}{\ltiE{3}}
     \\
     \ltielimClosT{\varnothing}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    }
    {
    \ltielabDriver{\ltiE{1}}{\ltiE{3}}{\ltiTp{}}
    }
  \end{mathpar}

  \[
    \boxed{\ltielimClos{\ltiClosureCache{}}{\ltiE{}}{\ltiEp{}}
    \text{ Converts symbolic closures in \ltiE{} to explicit types in \ltiEp{}}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosalign{\ltiClosureCache{}}{\ltivar{}}
                     {\ltivar{}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltiappinst{\ltiF{}}
                                 {\ova{\ltistackmapping{\ltiEnv{}}{\ova{\ltiR{}}}}}
                                 {\ltiE{}}}
                     {\ltiappinst{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}
                                 {\ova{\ltistackmapping{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}
                                                       {\ova{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiR{}}}}}}
                                 {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
                             \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltisel{\ltiF{}}{\ltivar{}}}
                     {\ltisel{\ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}{\ltivar{}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}{\ltiRec{\ova{\ltivar{} = \ltiF{}}}}
                     {\ltiRec{\ova{\ltivar{} = \ltielimClosLHS{\ltiClosureCache{}}{\ltiF{}}}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                            {\ova{\ltistackmapping{\ltiEnv{}}{\ltiT{}}}}
                                            {\ltivar{}}
                                            {\ltiE{}}}
                     {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                            {\ova{\ltistackmapping{\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}
                                                                  {\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}}}
                                            {\ltivar{}}
                                            {\ltielimClosLHS{\ltiClosureCache{}}{\ltiE{}}}}
                     \\
    \ltielimClosalign{\ltiClosureCache{}}
                     {\ltiufunelab{\ova{\ltiufunelabentry{\ltiClosureID{}}}^n}
                                  {\ltivar{}}
                                  {\ltiE{}}}
                     {\ltielimClosLHS{\ltiClosureCache{}}
                                     {\ltimergeTaggedTermsLHS{\ltiF{1}}
                                                             {\ltimergeTaggedTermsLHS{...}{\ltiF{n}}}}}
                    , &n>0
                     \\
                     &&\text{where } \overrightarrowcaption{
                                      \ltilookup{\ltiClosureCache{}}{\ltiClosureID{i}}
                                      = \ltistackmapping{\ltiEnv{i}}{\ltiF{i}}
                                      }^{1 \leq i \leq n}
  \end{array}
  \]


  \[
    \boxed{\ltielimClosEnv{\ltiClosureCache{}}{\ltiEnv{}}{\ltiEnvp{}}
    \text{ Eliminates symbolic closures in \ltiEnv{} using \ltiClosureCache{}.
    }
    }
  \]

  \[
  \begin{array}{llllll}
    \ltielimClosEnvalign{\ltiClosureCache{}}{\ltiEmptyEnv}{\ltiEmptyEnv}
    \\
    \ltielimClosEnvalign{\ltiClosureCache{}}
                        {\ltiEnvConcatParen{\hastype{\ltivar{}}{\ltiT{}}}{\ltiEnv{}}}
                        {\ltiEnvConcat{\hastype{\ltivar{}}{\ltielimClosTLHS{\varnothing}{\ltiClosureCache{}}{\ltiT{}}}}
                                      {\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}}
    \\
    \ltielimClosEnvalign{\ltiClosureCache{}}
                        {\ltiEnvConcatParen{\ltitvar{}}{\ltiEnv{}}}
                        {\ltiEnvConcat{\ltitvar{}}
                                      {\ltielimClosEnvLHS{\ltiClosureCache{}}{\ltiEnv{}}}}
  \end{array}
  \]

  \[
    \boxed{\ltielimClosT{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}{\ltiTp{}}
    \text{ Converts symbolic closures in \ltiT{} to explicit types in \ltiTp{}}
    }
  \]

  \[
  \begin{array}{llll}
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltitvar{}}{\ltitvar{}}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiTop}{\ltiTop}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiBot}{\ltiBot}\\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiIFn{\ova{\ltiFn{\ltiT{}}{\ltiS{}}}}}
                      {\ltiIFn{\ova{\ltiFn{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}
                                          {\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiS{}}}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltiT{}}}}}
                      {\ltiRec{\ova{\hastype{\ltivar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}}}
                                          \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiMu{\ltitvar{}}{\ltiT{}}}
                      {\ltiMu{\ltitvar{}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}
                      , &\ltitvar{} \not\in \ova{\ltiClosureID{}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltiT{}}}
                      {\ltiPoly{\ova{\ltitvar{}}}{\ltielimClosTLHS{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}{\ltiT{}}}}
                      , &\ova{\ltitvar{}} \cap \ova{\ltiClosureID{}} = \varnothing
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltiClosureIDp{}}
                      , & \ltiClosureIDp{} \in \ova{\ltiClosureID{}}
                      \\
    \ltielimClosTalign{\ova{\ltiClosureID{}}}{\ltiClosureCache{}}
                      {\ltiClosureWithStkID{\ltiEnv{}}{\ltiClosureIDp{}}{\ltiufun{\ltivar{}}{\ltiE{}}}}
                      {\ltiPoly{\ova{\ltitvar{}}}
                               {\ltiMu{\ltiClosureIDp{}}
                                      {\ltielimClosTLHS{(\ltiClosureIDp{}, \ova{\ltiClosureID{}})}
                                                       {\ltiClosureCache{}}
                                                       {\ltiT{}}}}}
                      , & \ltiClosureIDp{} \not\in \ova{\ltiClosureID{}},
                          \ltiClosureID{} \not\in \ltifvLHS{\ltiT{}}
                      \\
                      &&\text{where } 
                      \ltilookup{\ltiClosureCache{}}{\ltiClosureIDp{}}
                      = \ltiClosure{\ltiEnv{}}
                                   {\ltifuntparaminterface{\ova{\ltitvar{}}}
                                                          {\ltiT{}}
                                                          {\ltivar{}}
                                                          {\ltiE{}}}

  \end{array}
  \]
  \caption{Elaboration Metafunctions for Extended Symbolic Closure language}
\end{figure}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let f = $\ltiufun{\text{x}}{\text{x}}$ in
  {left = $\ltiapp{\text{f}}{\text{1}}$, right = $\ltiapp{\text{f}}{\text{"a"}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiIFn{\ltiFn{\text{Int}}{\text{Int}} \ltiFn{\text{Str}}{\text{Str}}}}}%
                                                         {\text{x}}%
                                                         {\text{x}}}}}}$ *)
let f = $\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}$ in
  {left = $\ltiapp{\text{f}}{\text{1}}$, right = $\ltiapp{\text{f}}{\text{"a"}}$}
(* fully annotated *)
let f = $\ltifuninterface{\ltiInferred{\ltiIFn{\ltiFn{\text{Int}}{\text{Int}} \ltiFn{\text{Str}}{\text{Str}}}}}{\text{x}}{\text{x}}$ in
  {left = $\ltiapp{\text{f}}{\text{1}}$, right = $\ltiapp{\text{f}}{\text{"a"}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let f = ${\ltiufun{\text{x}}{\text{x}}}$ in
  $\ltiapp{\text{f}}{\text{f}}$
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\ltiClosureWithStkIDParens{\ltiEmptyEnv}{\text{c1}}{\ltiufun{\text{x}}{\text{x}}}}%
                                                                             {\ltiClosureWithStkIDParens{\ltiEmptyEnv}{\text{c1}}{\ltiufun{\text{x}}{\text{x}}}}}}%
                                                         {\text{x}}%
                                                         {\text{x}}}}}}$ *)
let f = $\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\text{x}}$ in
  $\ltiapp{\text{f}}{\text{f}}$
(* Fully annotated *)
let f = $\ltifuninterface{\ltiInferred{\ltiFn{\ltiMu{\text{a}}{\ltiFn{\text{a}}{\text{a}}}}{\ltiMu{\text{a}}{\ltiFn{\text{a}}{\text{a}}}}}}{\text{x}}{\text{x}}$ in
  $\ltiapp{\text{f}}{\text{f}}$
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let f = $\ltiufun{\text{x}}{\text{x}}$ in
  {left  = $\ltiapp{\text{map}}{\text{f},\ltiapp{\text{Some}}{\text{1}}}$,
   right = $\ltiapp{\text{map}}{\text{f},\ltiapp{\text{Some}}{\text{"a"}}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiClosureCache{} =%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiIFn{\ltiFn{\text{Int}}{\text{Int}}%
                                                                               \ltiFn{\text{Str}}{\text{Str}}}}}%
                                                         {\text{f,x}}%
                                                         {\ltiappinst{\text{f}}{\ltiInferred{\text{Int}}}{\text{x}}}}}}}$ *)
let f = $\ltiufunelab{\text{c1}}{\text{x}}{\text{x}}$ in
  {left  = $\ltiappinst{\text{map}}{\ltiInferred{\text{Int,Int}}}{\text{f},\ltiappinst{\text{Some}}{\ltiInferred{\text{Int}}}{\text{1}}}$,
   right = $\ltiappinst{\text{map}}{\ltiInferred{\text{Str,Str}}}{\text{f},\ltiappinst{\text{Some}}{\ltiInferred{\text{Str}}}{\text{"a"}}}$}
(* Fully annotated *)
let f = $\ltifuninterface{\ltiInferred{\ltiIFn{\ltiFn{\text{Int}}{\text{Int}}%
                                               \ltiFn{\text{Str}}{\text{Str}}}}}%
                         {\text{x}}%
                         {\text{x}}$ in
  {left  = $\ltiappinst{\text{map}}{\ltiInferred{\text{Int,Int}}}{\text{f},\ltiappinst{\text{Some}}{\ltiInferred{\text{Int}}}{\text{1}}}$,
   right = $\ltiappinst{\text{map}}{\ltiInferred{\text{Str,Str}}}{\text{f},\ltiappinst{\text{Some}}{\ltiInferred{\text{Str}}}{\text{"a"}}}$}
\end{lstlisting}
}

{
\singlespacing
\begin{lstlisting}[language=ml,mathescape=true]
let f = $\ltiufun{\text{x}}{\ltiapp{\text{map}}{\ltiufun{\text{y}}{\text{y}},\text{x}}}$ in
  {left  = $\ltiapp{\text{f}}{\ltiapp{\text{Some}}{\text{1}}}$,
   right = $\ltiapp{\text{f}}{\ltiapp{\text{Some}}{\text{"a"}}}$}
(* SC annotated *)
(* $\ltiInferred{\ltiEnv{1} = {\hastype{\text{x}}{\text{Option[Int]}}}}$ *)
(* $\ltiInferred{\ltiEnv{2} = {\hastype{\text{x}}{\text{Option[Str]}}}}$ *)
(* $\ltiInferred{\ltiClosureCache{}} =$
     $\ltiInferred{%
      \ltiClosureCacheEntry{\text{c1}}%
                           {\ltiClosure{\ltiEmptyEnv}%
                                       {\ltiNotInferred%
                                        {\ltifuninterfaceLHS{\ltiInferred{\ltiIFn{\ltiFn{\text{Option[Int]}}{\text{Option[Int]}}%
                                                                                  \ltiFn{\text{Option[Str]}}{\text{Option[Str]}}}}}%
                                                         {\text{x}}}}}}$
              $\ltiappinst{\text{map}}% <- do not change indentation!
                           {\ltiInferred%
                            {\ltistackmapping{\ltiEnv{1}}{\text{[Int,Int]}},%
                             \ltistackmapping{\ltiEnv{2}}{\text{[Str,Str]}}}}%
                           {\ltiufunelab{\text{c1-1,c1-2}}{\text{y}}{\text{y}},\text{x}}$
     $\ltiInferred{%
      \ltiClosureCacheEntry{\text{c1-1}}%
                           {\ltiClosure{\ltiEnv{1}}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\text{Int}}{\text{Int}}}}%
                                                         {\text{y}}%
                                                         {\text{y}}}}}}$
     $\ltiInferred{%
      \ltiClosureCacheEntry{\text{c1-2}}%
                           {\ltiClosure{\ltiEnv{2}}%
                                       {\ltiNotInferred%
                                        {\ltifuninterface{\ltiInferred{\ltiFn{\text{Str}}{\text{Str}}}}%
                                                         {\text{y}}%
                                                         {\text{y}}}}}}$ *)
let f = $\ltiufunelab{\ltiInferred{\text{c1}}}{\text{x}}{\ltiapp{\text{map}}{\ltiufunelab{\ltiInferred{\text{c1-1,c1-2}}}{\text{y}}{\text{y}},\text{x}}}$ in
  {left  = $\ltiapp{\text{f}}{\ltiappinst{\text{Some}}{\ltiInferred{\text{Int}}}{\text{1}}}$,
   right = $\ltiapp{\text{f}}{\ltiappinst{\text{Some}}{\ltiInferred{\text{Str}}}{\text{"a"}}}$}
(* Fully elaborated *)
let f = $\ltifuninterfaceLHS{\ltiInferred{\ltiIFn{\ltiFn{\text{Option[Int]}}{\text{Option[Int]}}%
                                               \ltiFn{\text{Option[Str]}}{\text{Option[Str]}}}}}%
                         {\text{x}}$
          ${\ltiappinst{\text{map}}%<- do not change indentation!
                       {\ltiInferred%
                        {\ltistackmapping{\ltiEnv{1}}{\text{[Int,Int]}},%
                         \ltistackmapping{\ltiEnv{2}}{\text{[Str,Str]}}}}%
                       {\ltifuninterface{\ltiInferred%
                                         {\ltistackmapping{\ltiEnv{1}}{\ltiFn{\text{Int}}{\text{Int}}},%
                                          \ltistackmapping{\ltiEnv{2}}{\ltiFn{\text{Str}}{\text{Str}}}}}%
                                        {\text{y}}%
                                        {\text{y}},%
                        \text{x}}}$ in
  {left  = $\ltiapp{\text{f}}{\ltiappinst{\text{Some}}{\ltiInferred{\text{Int}}}{\text{1}}}$,
   right = $\ltiapp{\text{f}}{\ltiappinst{\text{Some}}{\ltiInferred{\text{Str}}}{\text{"a"}}}$}
\end{lstlisting}
}
