\documentclass[11pt]{iuthesis}
%\documentclass[11pt,final]{iuthesis}

% this is the dissertation, not the paper
\newcommand{\DISSERTATION}{}
\newcommand{\either}[2]{#1}

%\usepackage[margin=1in]{geometry}
\usepackage{savesym}
\savesymbol{r}
\savesymbol{AA}
\usepackage{esop-common}
\usepackage{infer-common}
\usepackage{symb-common}
\usepackage{quals-common}

% related to typesetting theorems, moved here for compatibility with acmart.cls
%\newcommand\@dotsep{12}

\usepackage[doublespacing]{setspace}

%\usepackage{hyperref}

\newcommand{\thesisauthor}[0]{Ambrose Bonnaire-Sergeant}
\newcommand{\thesistitle}[0]{Typed Clojure in Theory and Practice}
%\newcommand{\thesiskeywords}[0]{Kwd1, Kwd2, Kwd3}
\newcommand{\thesismonth}[0]{TODO}
\newcommand{\thesisyear}[0]{TODO}
\newcommand{\thesisdate}[0]{\today}

%% Setup for hyperref.
%\hypersetup{
%  pdftitle={\thesistitle{}},
%  pdfauthor={\thesisauthor{}},
%  colorlinks=true,
%  linkcolor=black,
%  citecolor=black,
%  urlcolor=black,
%}

%\usepackage[T1]{fontenc}

\advisor{Sam Tobin-Hochstadt}
\secondreader{Chung-chieh Shan}
\thirdreader{Ryan R. Newton}
\fourthreader{Lawrence S. Moss}
\departmentname{School}
\department{Informatics, Computing, and Engineering}
\copyrightyear{2019}
\submitdate{TODO}
\acceptdate{TODO}

% For use with iuthesis-alt.cls.
\parskip=6pt
\parindent=0pt
\normalparindent=0pt

\usepackage[top=1in,bottom=1.25in,left=1in,right=1in]{geometry}
\renewcommand{\thepart}{\Roman{part}}
\renewcommand{\thechapter}{\arabic{chapter}}

% The annoying section-only section numbering is inherited from
% amsbook, on which iuthesis-alt is based.  This is to bring back
% chapter numbers in the section headings.
\renewcommand{\thesection}{\thechapter.\arabic{section}}
\renewcommand{\thesubsection}{\thechapter.\arabic{section}.\arabic{subsection}}

% Also, put chapter numbers in figure and table numbering.
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
\renewcommand{\thetable}{\arabic{chapter}.\arabic{figure}}

% fix badly formatted toc
% https://tex.stackexchange.com/questions/22983/list-of-figures-and-list-of-tables-overlaps-figure-table-indices-with-proceeding
\makeatletter
\renewcommand*\l@figure{\@dottedtocline{1}{1.5em}{3em}}% 3em instead of 2.3em
\let\l@table\l@figure
\makeatother


\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

%\addtolength{\textwidth}{.5in}
%\addtolength{\textheight}{.5in}
%\setlength{\topmargin}{.25in}
%\usepackage{fontspec}
%\usepackage{hanging}
%\usepackage{xltxtra}
%\setlength{\oddsidemargin}{.75in}
%\setlength{\evensidemargin}{.25in}



\usepackage{thmtools}
%\declaretheorem[numberwithin=chapter]{example}
%\declaretheorem[numberwithin=chapter]{theorem}
%\declaretheorem[numberwithin=chapter]{lemma}
%\declaretheorem[numberwithin=chapter]{corollary}
%\declaretheorem[numberwithin=chapter]{definition}

\begin{document}

\frontmatter %turns off chapter numbering and uses roman numerals for page numbers
\title{\thesistitle{}}
\author{\thesisauthor{}}

%\begin{acknowledgements}
%\end{acknowledgements}

%\begin{dedication}
%\end{dedication}


\maketitle
\signaturepage
\copyrightpage
%\makeack
%\makededication
%\makeabstract

\input{abstract}

\singlespacing
\tableofcontents

%\listoffigures

%\listoftheorems
\doublespacing

\newpage

%turns on chapter numbering, resets page numbering and uses arabic numerals for page numbers;
\mainmatter

%\input{thesis-statement}

\chapter{Introduction}

\section{My Thesis}

\emph{Typed Clojure is a sound and practical optional type system for Clojure.}

\section{Structure of this Dissertation}

This document progresses in several parts that support my thesis statement, presented in chronological order
in which they were developed.

Part~\ref{part:types} motivates and presents the design of Typed Clojure.
It addresses both parts of my thesis statement.

\begin{itemize}
  \item \emph{Typed Clojure is sound} I formalize Typed Clojure, including
    its characteristic features like hash-maps, multimethods, and Java interoperability,
    and prove the model type sound.
  \item \emph{Typed Clojure is practical} 
      I present an empirical study of real-world Typed Clojure usage
        in over 19,000 lines of code, showing its features correspond to actual usage patterns.
\end{itemize}

The results and industry feedback of this work inspired three distinct research directions
to help improve the experience of using Typed Clojure.

\begin{itemize}
  \item
\partref{part:autoann} presents a solution to lower the annotation burden in real-world Typed Clojure programs.
I formalize and implement a tool to automatically annotate types for top-level
user and library definitions, and empirically study the manual changes needed for the generated annotations
to pass type checking.
  \item
\partref{part:implementations} describes the design and implementation of a 
new code analyzer for Clojure, in service of enabling user-provided type rules for Clojure macros
    to help make type checking complex macro usages more robust.
\item \partref{part:symbolic-closures} motivates and describes \emph{symbolic closure types},
      a technique that enhances type checking with symbolic execution, that helps check some
      common Clojure idioms via a compatible extension of Typed Clojure's original design.
\end{itemize}

\part{Practical Optional Types for Clojure}
\label{part:types}

\input{esop-abstract}
\input{esop-intro}
\input{esop-overview}
\input{esop-formal-model}
\input{esop-metatheory}
\input{esop-experience}
\input{esop-conclusion}

\part{Automatic Annotations for Typed Clojure}
\label{part:autoann}

%\chapter{Abstract}

\input{infer-abstract}

\input{infer-intro}
\input{infer-overview}
%\input{infer-algorithm} % old stuff
\input{infer-formalism}
\input{infer-evaluation}
\input{infer-extensions}
% infer-comparison == performance analysis vs Daikon
% this isn't in the PLDI submission so might not really fit yet
%\input{infer-comparison}
\input{infer-conclusion}

% Quals
%\part{Investigation of clojure.spec}
%\label{part:spec}
%
%\input{spec-intro}
%\input{spec-study}
%\input{spec-model}

\part{Typed Clojure Implementations}
\label{part:implementations}
\input{analyzer}

\part{%Local Type Argument Synthesis with Symbolic Closures
Symbolic Closures}
\label{part:symbolic-closures}

\input{symbolic}

\part*{Related and Future Work}

\input{esop-related-work}

\input{infer-related-work}

%% NOTE: Haven't pursued the following work yet

%\paragraph{How dynamic languages are used}
%Several languages have seen similar investigations
%into their idioms as I am proposing for Clojure.
%
%A popular motivation is to discover which type system features to support
%when retrofitting a type system.
%% FIXME the is \AAkerblom but there's an error.. also in the bibliography
%Akerblom et. al~\cite{Akerblom:2014:TDF:2597073.2597103} trace dynamic features in Python programs
%via instrumentation. They measured the prevalence of dynamic features in startup versus
%user code, and recorded usage frequencies for a set of dynamic features.
%They concluded dynamism is prevalent in Python, and thus should be supported
%in a retrofitted type system for Python.
%A study along similar lines is also applicable to Clojure, in particular analysing Typed
%Clojure's support for Clojure's dynamic features.
%
%Calla{\'u} et al. \cite{Callau2013} also conducted a large-scale study of
%dynamic Smalltalk idioms to inform future language extensions tooling support.
%Notably, they further perform a qualitative analysis aiming to identify
%the reasons why Smalltalk use these features in the first place, and
%whether they can be replaced with more predictable features. They also 
%measure which kinds of projects (e.g., testing frameworks, user-level libraries, or core system libraries) 
%use particular features more frequently.
%Due to the their prevalence in the open-source Clojure ecosystem,
%Typed Clojure has mainly been tested on user-level libraries.
%We could predict Typed Clojure's applicability to other kinds of projects
%by gathering similar data on how frequently different types of Clojure libraries use
%Clojure's various features.
%
%Andreasen et. al~\cite{Andreasen2016TraceTA} developed
%\emph{trace typing} to explore the design space of JavaScript type systems. 
%Using runtime observations, they studied which control flow techniques
%are used most often in JavaScript programs, and thus, which should
%be supported by an effective type system for JavaScript.
%Typed Clojure implements occurrence typing to reason about control
%flow in Clojure which seems to work well in practice, but a similar
%quantitative analysis could reveal further insights.

%Runtime analysis \cite{Mastrangelo:2015:UYO:2814270.2814313}

\chapter{Future work}

%\cite{Mastrangelo:2015:UYO:2814270.2814313} 

\paragraph{Interleaving Type Checking with Expansion, Extensible type systems and Symbolic Analysis}

Turnstile~\cite{Chang2017TSM} type checks a program during expansion
by repurposing the Racket macro system.
Instead of the more standard approach of providing separate rules to check a macro, Turnstile
typing rules specify both the expansion and checking semantics, and so ensuring the
two are compatibile becomes automatic.
On the other hand, Typed Clojure does not have the goal of allowing users to override
how language primitives type check. Instead, our goal is to provide
a simple interface to write type rules for library functions and macros
in a style that hides the necessary bookkeeping surrounding occurrence
typing and scope management.

SugarJ~\cite{Erdweg2011SJ}
adds syntactic language extensibility to languages like Java, such as pair
syntax, embedded XML, and closures.
Desugarings are expressed as rewrite rules to plain Java.
Similarly, work on \emph{type-specific languages}~\cite{omar2014safely}
adds extensible systems for the definitions of specialized syntax literals
to existing languages.
The \emph{type} of an expression determines how it is parsed and elaborated.

% this paper has a great related works section that differentiates
% the strategies of several typed metaprogramming techniques
SoundX~\cite{Lorenzen2016STS} presents a solution to a common
dilemma in typed metaprogramming: whether to desugar before
type checking, or vice-versa.
The authors present a system where a form is type checked before 
being desugared, with a guarantee that only well-typed code is generated.
Programmers specify desugarings with a combination of typing and rewriting rules, 
which are then connected to form a valid type derivation
in a process called \emph{forwarding}.
We will explore whether we can get the same effect in Typed Clojure
without requiring the user to understand typing rules.
%For example, Scala macros~\cite{Burmako2013SML} interleave type checking and
%desugaring

Ziggurat~\cite{Fisher06staticanalysis} allows programmers to define
the static and dynamic semantics of macros separately. To demonstrate its
broad applicability, they choose Scheme-like macros that generate assembly code
for the dynamic semantics.
They advocate building towers of static analyses, so
macros can be statically checked in terms the static semantics of other macros, instead
of just their assembly code expansions which would otherwise be too difficult to check.
This idea resembles our prototypes in defining custom typing rules for functions and macros in Typed Clojure,
where the dynamic semantics are defined by runtime Clojure constructs (\texttt{defn}
and \texttt{defmacro}), and towers of static semantics are progressively specified in terms of the static
analysis of other Clojure forms.

Mix~\cite{Khoo2010MTC} cleanly separates symbolic execution~\cite{King1976SEP} from type checking
in the same system, specifying a mode for (nested) regions of code.
They argue this tradeoff keeps the predictability of type checking, while preserving enough
symbolic execution to drive further checking.
In Typed Clojure, symbolic execution is managed by occurrence typing~\cite{TF10}.
Our preliminary explorations in symbolic execution for Typed Clojure, for example, type checks an
anonymous function if annotated, otherwise treats it symbolically.
As the authors envision, this is akin to automatically inserting
the mode of a code region based on its context, with a Mix-like language
becoming the intermediate language.

Type Tailoring~\cite{greenmanttailoring} is an approach to provide more information
to a host type system than it might be capable of by itself.
In particular, the authors use the host platform's metaprogramming functionality
to refine the types of calls based on the program syntax alone, as well as improve
error messages by incorporating surface syntax. Their experiments are based in Typed Racket, that fully expands
syntax before checking it. Since Typed Clojure recently changed to interleave macroexpansion
and type checking, we could extend this technique to also refine calls based on the
types of their arguments (like SoundX).

% Spine-local type inference
% - Judgement \vdash^P digs down an application to find the head
%   - happens naturally with symbolic closures
% - they use metavariables to solve direct applications
%   - can they check things like (let [x (fn [y] (inc y))] (x 1)) ?
% - they have polymorphism but not subtyping (plain System F)
%   - they speculate about extending to Fsub in related works
%   - they mention Hosoya & Pierce's "challenges" to fix hard-to-synthesize terms
% - they type check arguments left-to-right in a polymorphic application
%   - can't tell if that's different from inferring the data flow from a polytype 
%     and then checking in that order
% - their sense of "locality" is less ambitious than symbolic closures
%   - see "Type Inference Failures" section
% - good related works section for "Impredicative Polymorphism"

% Possible future work on Higher-rank types
% - see https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/
%   - looks like the journal version of boxy types?
%   - some notes from the paper
%     - a predicative type system only allows a polytype to be instantiated with monotypes
%     - ML_F is both impredicative and supports type inference (but costly to implement & formalize)
%       - also infers principal types
%     - higher-kinded types are orthogonal to higher-rank types, and Haskell's implementation of the former
%       happen to work well with higher-rank types (but no explanation)
%     - the concept of "syntax-directed" rules is given lots of a explanation
%     - \vdash^inst compares two _polytypes_
%     - Kfoury and Wells 1994 show that typeability of System F (with completely erased annotations) is decidable for rank 2 
%       but undecidable for rank 3>=
%     - LTI == "partial" type inference
%       - in the sense that it's not-complete (can't check all programs)
%     - nice discussion of partial type inference

% Dunfield works I need to compare to
% - Greedy Bidirectional Polymorphism
% - Sound and complete bidirectional typechecking for higher-rank polymorphism with existentials and indexed types
% - Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism

% Other works with undecidable type checking
% - Hybrid type checking - Knowles, Flanagan

Other work is relevant to our investigations of improving the user experience
of Typed Clojure. SweetT~\cite{pombrio2018inferring} automatically infers type rules
for syntactic sugar. Helium~\cite{Heeren2003STI} provides hooks into the type inference
process for domain-specific type error messages.

\printbibliography


\newpage
\input{esop-appendix}

\end{document}
