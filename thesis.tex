\documentclass[9pt]{extarticle}

\usepackage[margin=1in]{geometry}
\usepackage{savesym}
\savesymbol{r}
\savesymbol{AA}
\usepackage{esop-common}
\usepackage{infer-common}
\usepackage{quals-common}

\title{Typed Clojure in Theory and Practice}
\author{Ambrose Bonnaire-Sergeant}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

\begin{document}

\maketitle

\begin{abstract}
  \input{abstract}
\end{abstract}

\input{auto-ann-intro}

\input{thesis-statement}

\section{Practical Optional Types for Clojure}

\input{esop-abstract}
\input{esop-intro}
\input{esop-overview}
\input{esop-formal-model}
\input{esop-metatheory}
\input{esop-experience}
\input{esop-related-work}
\input{esop-conclusion}

\section{Automatic Annotations for Typed Clojure}


\input{infer-abstract}

\input{infer-intro}
%\input{auto-ann-intro}
\input{infer-grammar}
\input{infer-semantics}
\input{infer-overview}
\input{infer-track}
\input{infer-algorithm}
\input{infer-formalism}
\input{infer-evaluation}
\input{infer-extensions}
\input{infer-related-work}

\section{Spec}

\input{spec-intro}

\input{quals-q1}
\input{quals-q2}
\input{quals-q3}


\section{Related Work}

% Cite a few of the early papers here.
%http://www.cs.washington.edu/research/projects/cecil/www/pubs/
\paragraph{Typed Multimethods} 
Millstein and collaborators present a sequence of
systems~\cite{Chambers:1992:OMC,Chambers:1994:TMM,MS02} with statically-typed multimethods
and modular type checking.  In contrast to Typed Clojure, in these
system methods declare the types of arguments that they expect which
corresponds to exclusively using \clj{class} as the dispatch function
in Typed Clojure. However, Typed Clojure does not attempt to rule out
failed dispatches.

% one sentence
% TC based on TR, already covered

\paragraph{Occurrence Typing} 
Occurrence typing~\cite{TF08,TF10} extends the type 
system with a \emph{proposition environment} that represents 
the information on the types of bindings down conditional branches.
These propositions are then used to update the types associated
with bindings in the \emph{type environment} down branches
so binding occurrences are given different types 
depending on the branches they appear in, and the conditionals
that lead to that branch.

% What's diff about TC from the related work
% small summary for diesel....
% - diesel supports x
%  - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wand89typeinference,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

TeJaS~\cite{TeJaS}, another type system for JavaScript,
also supports similar HMaps, with the ability to
record the presence and absence of entries, but lacks a compositional
flow-checking approach like occurrence typing.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

\paragraph{Java Interoperability in Statically Typed Languages}
Scala~\cite{OCD+} has nullable references for compatibility with Java.
Programmers must manually check for
\java{null} as in Java to avoid null-pointer exceptions. 


\paragraph{Other optional and gradual type systems}
%In addition to Typed Racket, 
Several other gradual type
systems have been developed for existing
dynamically-typed languages.  Reticulated Python~\cite{Vitousek14} is
an experimental gradually typed system for Python, implemented as a
source-to-source translation that inserts dynamic checks at language
boundaries and supporting Python's first-class object system. 
Clojure's nominal classes avoids the need to support
first-class object system in Typed Clojure, however HMaps offer an alternative to
the structural objects offered by Reticulated. Similarly,
Gradualtalk~\cite{gradualtalk} offers gradual typing for Smalltalk,
with nominal classes.

Optional types
%, requiring less implementation effort and avoiding
%runtime cost, 
have been  adopted in industry, including Hack~\cite{hack}, and Flow~\cite{flow} and
TypeScript~\cite{typescript}, two extensions of JavaScript. These
systems  support  limited forms of occurrence typing,
and do not include the other features we
present.

\paragraph{Automatic annotations}
There are two common implementation strategies for such tools. The first
strategy, ``ruling-out'' (for invariant detection), assumes all invariants are true 
and then use runtime analysis results to rule out
impossible invariants. The second ``building-up'' strategy (for dynamic type inference)
assumes nothing and then uses runtime analysis results to build up invariant/type knowledge.

Examples of invariant detection tools include Daikon \cite{Ernst06thedaikon},
DIDUCE \cite{hangal2002tracking}, and Carrot \cite{pytlik2003automated}, and
typically enhance statically typed languages with more expressive types or contracts.
Examples of dynamic type inference include Rubydust \cite{An10dynamicinference},
JSTrace \cite{saftoiu2010jstrace}, and TypeDevil \cite{pradel2015typedevil},
and typically target untyped languages.

Both strategies have different space behavior with respect to representing
the set of known invariants.
The ruling-out strategy typically uses a lot of memory at the beginning,
but then can free memory as it rules out invariants. For example, if
\texttt{odd(x)} and \texttt{even(x)} are assumed, observing \texttt{x = 1}
means we can delete and free the memory recording \texttt{even(x)}.
Alternatively, the building-up strategy uses the least memory storing
known invariants/types at the beginning, but increases memory usage
as more the more samples are collected. For example, if we know
\texttt{x : Bottom}, and we observe \texttt{x = "a"} and \texttt{x = 1}
at different points in the program, we must use more memory to
store the union \texttt{x : String $\cup$ Integer} in our set of known invariants.

\paragraph{Daikon}
Daikon can reason about very expressive relationships between variables
using properties like ordering ($x < y$), linear relationships ($y = ax + b$),
and containment ($x \in y$). It also supports reasoning with ``derived variables''
like fields ($x.f$), and array accesses ($a[i]$).

Typed Clojure's dynamic inference can record heterogeneous data structures
like vectors and hash-maps, but otherwise cannot express relationships
between variables.

There are several reasons for this. The most prominent is that Daikon
primarily targets Java-like languages, so inferring simple type information
would be redundant with the explicit typing disciplines of these languages.
On the other hand, the process of moving from Clojure to Typed Clojure
mostly involves writing simple type signatures without dependencies
between variables. Typed Clojure recovers relevant dependent information
via occurrence typing, and gives the option to manually annotate necessary
dependencies in function signatures when needed.


% Inference and Evolution of TypeScript Declaration Files
% - they submit pull requests from their tool's output
% https://cs.au.dk/~amoeller/papers/tstools/paper.pdf
\paragraph{TypeScript Annotation Generation}
Kristensen and M{\o}ller~\cite{kristensen2017inference}
present TSInfer and TSEvolve that generate TypeScript annotation
files using static analysis of JavaScript code. They
submitted corrections back to libraries they found descrepancies in,
which were accepted with little to no changes in the tool's output.

NoRegrets~\cite{noregrets2018} uses dynamic analysis to learn how a program
is used, and automatically runs the tests of downstream projects to
improve test coverage. Its concept of representing a program sample as
a path paired with a type is very similar to Typed Clojure's approach.

\paragraph{How dynamic languages are used}
Several languages have seen similar investigations
into their idioms as I am proposing for Clojure.

A popular motivation is to discover which type system features to support
when retrofitting a type system.
% FIXME the is \AAkerblom but there's an error.. also in the bibliography
Akerblom et. al~\cite{Akerblom:2014:TDF:2597073.2597103} trace dynamic features in Python programs
via instrumentation. They measured the prevalence of dynamic features in startup versus
user code, and recorded usage frequencies for a set of dynamic features.
They concluded dynamism is prevalent in Python, and thus should be supported
in a retrofitted type system for Python.
A study along similar lines is also applicable to Clojure, in particular analysing Typed
Clojure's support for Clojure's dynamic features.

Calla{\'u} et al. \cite{Callau2013} also conducted a large-scale study of
dynamic Smalltalk idioms to inform future language extensions tooling support.
Notably, they further perform a qualitative analysis aiming to identify
the reasons why Smalltalk use these features in the first place, and
whether they can be replaced with more predictable features. They also 
measure which kinds of projects (e.g., testing frameworks, user-level libraries, or core system libraries) 
use particular features more frequently.
Due to the their prevalence in the open-source Clojure ecosystem,
Typed Clojure has mainly been tested on user-level libraries.
We could predict Typed Clojure's applicability to other kinds of projects
by gathering similar data on how frequently different types of Clojure libraries use
Clojure's various features.

Andreasen et. al~\cite{Andreasen2016TraceTA} developed
\emph{trace typing} to explore the design space of JavaScript type systems. 
Using runtime observations, they studied which control flow techniques
are used most often in JavaScript programs, and thus, which should
be supported by an effective type system for JavaScript.
Typed Clojure implements occurrence typing to reason about control
flow in Clojure which seems to work well in practice, but a similar
quantitative analysis could reveal further insights.

%Runtime analysis \cite{Mastrangelo:2015:UYO:2814270.2814313}

%\cite{Mastrangelo:2015:UYO:2814270.2814313} 

\paragraph{Interleaving Type Checking with Expansion, Extensible type systems and Symbolic Analysis}

Turnstile~\cite{Chang2017TSM} type checks a program during expansion
by repurposing the Racket macro system. It provides a fully extensible framework
for specifying and combining core typing rules.
On the other hand, Typed Clojure does not have the goal of allowing users to override
how language primitives type check. Instead, our goal is to provide
a simple interface to write type rules for library functions and macros
in a style that hides the necessary bookkeeping surrounding occurrence
typing and scope management.

SugarJ~\cite{Erdweg2011SJ}
adds syntactic language extensibility to languages like Java, such as pair
syntax, embedded XML, and closures.
Desugarings are expressed as rewrite rules to plain Java.
Similarly, work on \emph{type-specific languages}~\cite{omar2014safely}
adds extensible systems for the definitions of specialized syntax literals
to existing languages.
The \emph{type} of an expression determines how it is parsed and elaborated.

% this paper has a great related works section that differentiates
% the strategies of several typed metaprogramming techniques
SoundX~\cite{Lorenzen2016STS} presents a solution to a common
dilemma in typed metaprogramming: whether to desugar before
type checking, or vice-versa.
The authors present a system where a form is type checked before 
being desugared, with a guarantee that only well-typed code is generated.
Programmers specify desugarings with a combination of typing and rewriting rules, 
which are then connected to form a valid type derivation
in a process called \emph{forwarding}.
We will explore whether we can get the same effect in Typed Clojure
without requiring the user to understand typing rules.
%For example, Scala macros~\cite{Burmako2013SML} interleave type checking and
%desugaring

Ziggurat~\cite{Fisher06staticanalysis} allows programmers to define
the static and dynamic semantics of macros separately. To demonstrate its
broad applicability, they choose Scheme-like macros that generate assembly code
for the dynamic semantics.
They advocate building towers of static analyses, so
macros can be statically checked in terms the static semantics of other macros, instead
of just their assembly code expansions which would otherwise be too difficult to check.
This idea resembles our prototypes in defining custom typing rules for functions and macros in Typed Clojure,
where the dynamic semantics are defined by runtime Clojure constructs (\texttt{defn}
and \texttt{defmacro}), and towers of static semantics are progressively specified in terms of the static
analysis of other Clojure forms.

Mix~\cite{Khoo2010MTC} cleanly separates symbolic execution~\cite{King1976SEP} from type checking
in the same system, specifying a mode for (nested) regions of code.
They argue this tradeoff keeps the predictability of type checking, while preserving enough
symbolic execution to drive further checking.
In Typed Clojure, symbolic execution is managed by occurrence typing~\cite{TF10}.
Our preliminary explorations in symbolic execution for Typed Clojure, for example, type checks an
anonymous function if annotated, otherwise treats it symbolically.
As the authors envision, this is akin to automatically inserting
the mode of a code region based on its context, with a Mix-like language
becoming the intermediate language.

Type Tailoring~\cite{greenmanttailoring} is an approach to provide more information
to a host type system than it might be capable of by itself.
In particular, the authors use the host platform's metaprogramming functionality
to refine the types of calls based on the program syntax alone, as well as improve
error messages by incorporating surface syntax. Their experiments are based in Typed Racket, that fully expands
syntax before checking it. Since Typed Clojure recently changed to interleave macroexpansion
and type checking, we could extend this technique to also refine calls based on the
types of their arguments (like SoundX).


Other work is relevant to our investigations of improving the user experience
of Typed Clojure. SweetT~\cite{pombrio2018inferring} automatically infers type rules
for syntactic sugar. Helium~\cite{Heeren2003STI} provides hooks into the type inference
process for domain-specific type error messages.

\printbibliography

\newpage

\input{esop-appendix}

\end{document}
