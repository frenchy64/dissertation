\documentclass[11pt]{iuthesis}
%\documentclass[11pt,final]{iuthesis}

% this is the dissertation, not the paper
\newcommand{\DISSERTATION}{}
\newcommand{\either}[2]{#1}

%\usepackage[margin=1in]{geometry}
\usepackage{savesym}
\savesymbol{r}
\savesymbol{AA}
\usepackage{esop-common}
\usepackage{infer-common}
\usepackage{quals-common}

% related to typesetting theorems, moved here for compatibility with acmart.cls
%\newcommand\@dotsep{12}

\usepackage[doublespacing]{setspace}

%\usepackage{hyperref}

\newcommand{\thesisauthor}[0]{Ambrose Bonnaire-Sergeant}
\newcommand{\thesistitle}[0]{Typed Clojure in Theory and Practice}
%\newcommand{\thesiskeywords}[0]{Kwd1, Kwd2, Kwd3}
\newcommand{\thesismonth}[0]{TODO}
\newcommand{\thesisyear}[0]{TODO}
\newcommand{\thesisdate}[0]{\today}

%% Setup for hyperref.
%\hypersetup{
%  pdftitle={\thesistitle{}},
%  pdfauthor={\thesisauthor{}},
%  colorlinks=true,
%  linkcolor=black,
%  citecolor=black,
%  urlcolor=black,
%}

%\usepackage[T1]{fontenc}

\advisor{Sam Tobin-Hochstadt}
\secondreader{Chung-chieh Shan}
\thirdreader{Ryan R. Newton}
\fourthreader{Lawrence S. Moss}
\departmentname{School}
\department{Informatics, Computing, and Engineering}
\copyrightyear{2019}
\submitdate{TODO}
\acceptdate{TODO}

% For use with iuthesis-alt.cls.
\parskip=6pt
\parindent=0pt
\normalparindent=0pt

\usepackage[top=1in,bottom=1.25in,left=1in,right=1in]{geometry}
\renewcommand{\thepart}{\Roman{part}}
\renewcommand{\thechapter}{\arabic{chapter}}

% The annoying section-only section numbering is inherited from
% amsbook, on which iuthesis-alt is based.  This is to bring back
% chapter numbers in the section headings.
\renewcommand{\thesection}{\thechapter.\arabic{section}}
\renewcommand{\thesubsection}{\thechapter.\arabic{section}.\arabic{subsection}}

% Also, put chapter numbers in figure and table numbering.
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
\renewcommand{\thetable}{\arabic{chapter}.\arabic{figure}}

% fix badly formatted toc
% https://tex.stackexchange.com/questions/22983/list-of-figures-and-list-of-tables-overlaps-figure-table-indices-with-proceeding
\makeatletter
\renewcommand*\l@figure{\@dottedtocline{1}{1.5em}{3em}}% 3em instead of 2.3em
\let\l@table\l@figure
\makeatother


\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography.bib}

%\addtolength{\textwidth}{.5in}
%\addtolength{\textheight}{.5in}
%\setlength{\topmargin}{.25in}
%\usepackage{fontspec}
%\usepackage{hanging}
%\usepackage{xltxtra}
%\setlength{\oddsidemargin}{.75in}
%\setlength{\evensidemargin}{.25in}



\usepackage{thmtools}
%\declaretheorem[numberwithin=chapter]{example}
%\declaretheorem[numberwithin=chapter]{theorem}
%\declaretheorem[numberwithin=chapter]{lemma}
%\declaretheorem[numberwithin=chapter]{corollary}
%\declaretheorem[numberwithin=chapter]{definition}

\begin{document}

\frontmatter %turns off chapter numbering and uses roman numerals for page numbers
\title{\thesistitle{}}
\author{\thesisauthor{}}

%\begin{acknowledgements}
%\end{acknowledgements}

%\begin{dedication}
%\end{dedication}

\begin{abstract}
\input{abstract}
\end{abstract}

\maketitle
\signaturepage
\copyrightpage
%\makeack
%\makededication
\makeabstract

\singlespacing
\tableofcontents

\listoffigures

\listoftheorems
\doublespacing

\newpage

%turns on chapter numbering, resets page numbering and uses arabic numerals for page numbers;
\mainmatter

\input{thesis-statement}

\part{Practical Optional Types for Clojure}
\label{part:types}

\input{esop-abstract}
\input{esop-intro}
\input{esop-overview}
\input{esop-formal-model}
\input{esop-metatheory}
\input{esop-experience}
\input{esop-conclusion}

\part{Automatic Annotations for Typed Clojure}
\label{part:autoann}

%\chapter{Abstract}

\input{infer-abstract}

\input{infer-intro}
\input{infer-overview}
%\input{infer-algorithm} % old stuff
\input{infer-formalism}
\input{infer-evaluation}
\input{infer-extensions}
% performance analysis vs Daikon
\input{infer-comparison}
\input{infer-conclusion}

\part{Investigation of clojure.spec}
\label{part:spec}

\input{spec-intro}
\input{spec-study}
\input{spec-model}

\part{Typed Clojure Implementations}

\input{analyzer}

\part*{Related and Future Work}

\input{esop-related-work}

\input{infer-related-work}

%% NOTE: Haven't pursued the following work yet

%\paragraph{How dynamic languages are used}
%Several languages have seen similar investigations
%into their idioms as I am proposing for Clojure.
%
%A popular motivation is to discover which type system features to support
%when retrofitting a type system.
%% FIXME the is \AAkerblom but there's an error.. also in the bibliography
%Akerblom et. al~\cite{Akerblom:2014:TDF:2597073.2597103} trace dynamic features in Python programs
%via instrumentation. They measured the prevalence of dynamic features in startup versus
%user code, and recorded usage frequencies for a set of dynamic features.
%They concluded dynamism is prevalent in Python, and thus should be supported
%in a retrofitted type system for Python.
%A study along similar lines is also applicable to Clojure, in particular analysing Typed
%Clojure's support for Clojure's dynamic features.
%
%Calla{\'u} et al. \cite{Callau2013} also conducted a large-scale study of
%dynamic Smalltalk idioms to inform future language extensions tooling support.
%Notably, they further perform a qualitative analysis aiming to identify
%the reasons why Smalltalk use these features in the first place, and
%whether they can be replaced with more predictable features. They also 
%measure which kinds of projects (e.g., testing frameworks, user-level libraries, or core system libraries) 
%use particular features more frequently.
%Due to the their prevalence in the open-source Clojure ecosystem,
%Typed Clojure has mainly been tested on user-level libraries.
%We could predict Typed Clojure's applicability to other kinds of projects
%by gathering similar data on how frequently different types of Clojure libraries use
%Clojure's various features.
%
%Andreasen et. al~\cite{Andreasen2016TraceTA} developed
%\emph{trace typing} to explore the design space of JavaScript type systems. 
%Using runtime observations, they studied which control flow techniques
%are used most often in JavaScript programs, and thus, which should
%be supported by an effective type system for JavaScript.
%Typed Clojure implements occurrence typing to reason about control
%flow in Clojure which seems to work well in practice, but a similar
%quantitative analysis could reveal further insights.

%Runtime analysis \cite{Mastrangelo:2015:UYO:2814270.2814313}

\chapter{Future work}

%\cite{Mastrangelo:2015:UYO:2814270.2814313} 

\paragraph{Interleaving Type Checking with Expansion, Extensible type systems and Symbolic Analysis}

Turnstile~\cite{Chang2017TSM} type checks a program during expansion
by repurposing the Racket macro system. It provides a fully extensible framework
for specifying and combining core typing rules.
On the other hand, Typed Clojure does not have the goal of allowing users to override
how language primitives type check. Instead, our goal is to provide
a simple interface to write type rules for library functions and macros
in a style that hides the necessary bookkeeping surrounding occurrence
typing and scope management.

SugarJ~\cite{Erdweg2011SJ}
adds syntactic language extensibility to languages like Java, such as pair
syntax, embedded XML, and closures.
Desugarings are expressed as rewrite rules to plain Java.
Similarly, work on \emph{type-specific languages}~\cite{omar2014safely}
adds extensible systems for the definitions of specialized syntax literals
to existing languages.
The \emph{type} of an expression determines how it is parsed and elaborated.

% this paper has a great related works section that differentiates
% the strategies of several typed metaprogramming techniques
SoundX~\cite{Lorenzen2016STS} presents a solution to a common
dilemma in typed metaprogramming: whether to desugar before
type checking, or vice-versa.
The authors present a system where a form is type checked before 
being desugared, with a guarantee that only well-typed code is generated.
Programmers specify desugarings with a combination of typing and rewriting rules, 
which are then connected to form a valid type derivation
in a process called \emph{forwarding}.
We will explore whether we can get the same effect in Typed Clojure
without requiring the user to understand typing rules.
%For example, Scala macros~\cite{Burmako2013SML} interleave type checking and
%desugaring

Ziggurat~\cite{Fisher06staticanalysis} allows programmers to define
the static and dynamic semantics of macros separately. To demonstrate its
broad applicability, they choose Scheme-like macros that generate assembly code
for the dynamic semantics.
They advocate building towers of static analyses, so
macros can be statically checked in terms the static semantics of other macros, instead
of just their assembly code expansions which would otherwise be too difficult to check.
This idea resembles our prototypes in defining custom typing rules for functions and macros in Typed Clojure,
where the dynamic semantics are defined by runtime Clojure constructs (\texttt{defn}
and \texttt{defmacro}), and towers of static semantics are progressively specified in terms of the static
analysis of other Clojure forms.

Mix~\cite{Khoo2010MTC} cleanly separates symbolic execution~\cite{King1976SEP} from type checking
in the same system, specifying a mode for (nested) regions of code.
They argue this tradeoff keeps the predictability of type checking, while preserving enough
symbolic execution to drive further checking.
In Typed Clojure, symbolic execution is managed by occurrence typing~\cite{TF10}.
Our preliminary explorations in symbolic execution for Typed Clojure, for example, type checks an
anonymous function if annotated, otherwise treats it symbolically.
As the authors envision, this is akin to automatically inserting
the mode of a code region based on its context, with a Mix-like language
becoming the intermediate language.

Type Tailoring~\cite{greenmanttailoring} is an approach to provide more information
to a host type system than it might be capable of by itself.
In particular, the authors use the host platform's metaprogramming functionality
to refine the types of calls based on the program syntax alone, as well as improve
error messages by incorporating surface syntax. Their experiments are based in Typed Racket, that fully expands
syntax before checking it. Since Typed Clojure recently changed to interleave macroexpansion
and type checking, we could extend this technique to also refine calls based on the
types of their arguments (like SoundX).


Other work is relevant to our investigations of improving the user experience
of Typed Clojure. SweetT~\cite{pombrio2018inferring} automatically infers type rules
for syntactic sugar. Helium~\cite{Heeren2003STI} provides hooks into the type inference
process for domain-specific type error messages.

\printbibliography


\newpage
\input{esop-appendix}

\end{document}
